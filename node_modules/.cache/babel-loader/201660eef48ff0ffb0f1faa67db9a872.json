{"ast":null,"code":"import { __assign, __spreadArrays, __extends, __rest } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, clamp, distance, mix, progress, mixColor, interpolate, wrap } from '@popmotion/popcorn';\nimport { invariant, warning } from 'hey-listen';\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage, rgba } from 'style-value-types';\nimport { useRef, createElement, createContext, useContext, useMemo, useEffect, Component, forwardRef, Fragment, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear, circOut } from '@popmotion/easing';\n\nvar isRefObject = function (ref) {\n  return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\n};\n\nvar isFloat = function (value) {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\n\nvar MotionValue =\n/** @class */\nfunction () {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n\n\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n\n    this.lastUpdated = 0;\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n\n    this.canTrackVelocity = false;\n\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n\n      _this.prev = _this.current;\n      _this.current = v;\n\n      if (_this.updateSubscribers && _this.prev !== _this.current) {\n        _this.updateSubscribers.forEach(_this.notifySubscriber);\n      }\n\n      if (render && _this.renderSubscribers) {\n        _this.renderSubscribers.forEach(_this.notifySubscriber);\n      } // Update timestamp\n\n\n      var _a = getFrameData(),\n          delta = _a.delta,\n          timestamp = _a.timestamp;\n\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync.postRender(_this.scheduleVelocityCheck);\n      }\n    };\n    /**\n     * Notify a subscriber with the latest value.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @param subscriber - The subscriber to notify.\n     *\n     * @internal\n     */\n\n\n    this.notifySubscriber = function (subscriber) {\n      subscriber(_this.current);\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.scheduleVelocityCheck = function () {\n      return sync.postRender(_this.velocityCheck);\n    };\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n      }\n    };\n\n    this.set(init, false);\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\n   * Subscribes a subscriber function to a subscription list.\n   *\n   * @param subscriptions - A `Set` of subscribers.\n   * @param subscription - A subscriber function.\n   */\n\n\n  MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\n    var _this = this;\n\n    var updateSubscriber = function () {\n      return subscription(_this.current);\n    };\n\n    subscriptions.add(updateSubscriber);\n    return function () {\n      return subscriptions.delete(updateSubscriber);\n    };\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * @library\n   *\n   * ```jsx\n   * function MyComponent() {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <Frame x={x} />\n   * }\n   * ```\n   *\n   * @motion\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @internalremarks\n   *\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n   *\n   * ```jsx\n   * useOnChange(x, () => {})\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.onChange = function (subscription) {\n    if (!this.updateSubscribers) this.updateSubscribers = new Set();\n    return this.subscribeTo(this.updateSubscribers, subscription);\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` requests a render.\n   *\n   * @param subscriber - A function that's provided the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    if (!this.renderSubscribers) this.renderSubscribers = new Set(); // Render immediately\n\n    this.notifySubscriber(subscription);\n    return this.subscribeTo(this.renderSubscribers, subscription);\n  };\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\n   * @public\n   */\n\n\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers && this.updateSubscribers.clear();\n    this.renderSubscribers && this.renderSubscribers.clear();\n    this.stop();\n  };\n\n  return MotionValue;\n}();\n/**\n * @internal\n */\n\n\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n/**\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\n * underlying renderer.\n *\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\n * VisualElement and we can quickly offer all the same features.\n */\n\n\nvar VisualElement =\n/** @class */\nfunction () {\n  function VisualElement(parent, ref) {\n    var _this = this; // The latest resolved MotionValues\n\n\n    this.latest = {}; // A map of MotionValues used to animate this element\n\n    this.values = new Map(); // Unsubscription callbacks for each MotionValue\n\n    this.valueSubscriptions = new Map(); // A configuration for this VisualElement, each derived class can extend this.\n\n    this.config = {}; // A pre-bound call to the user-provided `onUpdate` callback. This won't\n    // be called more than once per frame.\n\n    this.update = function () {\n      return _this.config.onUpdate(_this.latest);\n    }; // Pre-bound version of render\n\n\n    this.triggerRender = function () {\n      return _this.render();\n    }; // This function gets passed to the rendered component's `ref` prop\n    // and is used to mount/unmount the VisualElement\n\n\n    this.ref = function (element) {\n      element ? _this.mount(element) : _this.unmount();\n      if (!_this.externalRef) return;\n\n      if (typeof _this.externalRef === \"function\") {\n        _this.externalRef(element);\n      } else if (isRefObject(_this.externalRef)) {\n        _this.externalRef.current = element;\n      }\n    }; // Create a relationship with the provided parent. When we come to replace\n    // the auto-animation stuff with VisualElement we might need to make this\n    // relationship two-way\n\n\n    this.parent = parent; // Calculate the depth of this node in the VisualElement graph\n\n    this.depth = parent ? parent.depth + 1 : 0; // A reference to any externally-defined React ref. This might live better\n    // outside the VisualElement and be handled in a hook.\n\n    this.externalRef = ref;\n  } // Check whether this element has a MotionValue of the provided key\n\n\n  VisualElement.prototype.hasValue = function (key) {\n    return this.values.has(key);\n  }; // Add a MotionValue\n\n\n  VisualElement.prototype.addValue = function (key, value) {\n    if (this.hasValue(key)) this.removeValue(key);\n    this.values.set(key, value);\n    this.latest[key] = value.get();\n    if (this.element) this.subscribeToValue(key, value);\n  }; // Remove a MotionValue\n\n\n  VisualElement.prototype.removeValue = function (key) {\n    var unsubscribe = this.valueSubscriptions.get(key);\n    unsubscribe && unsubscribe();\n    this.values.delete(key);\n    delete this.latest[key];\n    this.valueSubscriptions.delete(key);\n  };\n\n  VisualElement.prototype.getValue = function (key, defaultValue) {\n    var value = this.values.get(key);\n\n    if (value === undefined && defaultValue !== undefined) {\n      value = new MotionValue(defaultValue);\n      this.addValue(key, value);\n    }\n\n    return value;\n  }; // Iterate over all MotionValues\n\n\n  VisualElement.prototype.forEachValue = function (callback) {\n    this.values.forEach(callback);\n  }; // Get the underlying rendered instance of this VisualElement. For instance in\n  // HTMLVisualElement this will be a HTMLElement.\n\n\n  VisualElement.prototype.getInstance = function () {\n    return this.element;\n  };\n\n  VisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign({}, config);\n  }; // Set a single `latest` value\n\n\n  VisualElement.prototype.setSingleStaticValue = function (key, value) {\n    this.latest[key] = value;\n  }; // Statically set values to `latest` without needing a MotionValue\n\n\n  VisualElement.prototype.setStaticValues = function (values, value) {\n    if (typeof values === \"string\") {\n      this.setSingleStaticValue(values, value);\n    } else {\n      for (var key in values) {\n        this.setSingleStaticValue(key, values[key]);\n      }\n    }\n  }; // Subscribe to changes in a MotionValue\n\n\n  VisualElement.prototype.subscribeToValue = function (key, value) {\n    var _this = this;\n\n    var onChange = function (latest) {\n      _this.setSingleStaticValue(key, latest);\n\n      _this.latest[key] = latest;\n      _this.config.onUpdate && sync.update(_this.update, false, true);\n    };\n\n    var onRender = function () {\n      return sync.render(_this.triggerRender, false, true);\n    };\n\n    var unsubscribeOnChange = value.onChange(onChange);\n    var unsubscribeOnRender = value.onRenderRequest(onRender);\n    this.valueSubscriptions.set(key, function () {\n      unsubscribeOnChange();\n      unsubscribeOnRender();\n    });\n  }; // Mount the VisualElement with the actual DOM element\n\n\n  VisualElement.prototype.mount = function (element) {\n    var _this = this;\n\n    invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\n    this.element = this.current = element; // Subscribe to any pre-existing MotionValues\n\n    this.forEachValue(function (value, key) {\n      return _this.subscribeToValue(key, value);\n    });\n  }; // Unmount the VisualElement and cancel any scheduled updates\n\n\n  VisualElement.prototype.unmount = function () {\n    var _this = this;\n\n    this.forEachValue(function (_, key) {\n      return _this.removeValue(key);\n    });\n    cancelSync.update(this.update);\n    cancelSync.render(this.render);\n  };\n\n  return VisualElement;\n}();\n\nfunction noop(any) {\n  return any;\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\n\n\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n      left = _a.left,\n      right = _a.right,\n      bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n      y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\n\n\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\n * Calculate the center point of the provided axis\n */\n\n\nfunction calcAxisCenter(_a) {\n  var min = _a.min,\n      max = _a.max;\n  return (max - min) / 2 + min;\n}\n/**\n * ValueType for \"auto\"\n */\n\n\nvar auto = {\n  test: function (v) {\n    return v === \"auto\";\n  },\n  parse: function (v) {\n    return v;\n  }\n};\n/**\n * ValueType for ints\n */\n\nvar int = __assign(__assign({}, number), {\n  transform: Math.round\n});\n/**\n * A map of default value types for common values\n */\n\n\nvar defaultValueTypes = {\n  // Color props\n  color: color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale: scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n/**\n * A list of value types commonly used for dimensions\n */\n\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a provided value against a ValueType\n */\n\nvar testValueType = function (v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\n\n\nvar findDimensionValueType = function (v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\n\n\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\n\n\nvar findValueType = function (v) {\n  return valueTypes.find(testValueType(v));\n};\n/**\n * Gets the default ValueType for the provided value key\n */\n\n\nvar getDefaultValueType = function (key) {\n  return defaultValueTypes[key];\n};\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\n\n\nvar getValueAsType = function (value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\n\n\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\n\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\n/**\n * Generate a list of every possible transform key.\n */\n\nvar transformProps = [\"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  axes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\n\n\nvar transformPropSet = new Set(transformProps);\n\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\n\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n  if (enableHardwareAcceleration === void 0) {\n    enableHardwareAcceleration = true;\n  }\n\n  if (allowTransformNone === void 0) {\n    allowTransformNone = true;\n  } // The transform string we're going to build into\n\n\n  var transformString = \"\"; // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\n * Returns true if the provided key is a CSS variable\n */\n\n\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n/**\n * Build style and CSS variables\n *\n * This function converts a Motion style prop:\n *\n * { x: 100, width: 100, originX: 0.5 }\n *\n * Into an object with default value types applied and default\n * transform order set:\n *\n * {\n *   transform: 'translateX(100px) translateZ(0)`,\n *   width: '100px',\n *   transformOrigin: '50% 50%'\n * }\n *\n * Styles are saved to `style` and CSS vars to `vars`.\n *\n * This function works with mutative data structures.\n */\n\n\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a) {\n  var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n      transformTemplate = _a.transformTemplate,\n      allowTransformNone = _a.allowTransformNone; // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n\n  transformKeys.length = 0; // Track whether we encounter any transform or transformOrigin values.\n\n  var hasTransform = false;\n  var hasTransformOrigin = false; // Does the calculated transform essentially equal \"none\"?\n\n  var transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable. Transforms and transform origins are kept seperately\n   * for further processing\n   */\n\n  for (var key in latest) {\n    var value = latest[key]; // Convert the value to its default value type, ie 0 -> \"0px\"\n\n    var valueType = getDefaultValueType(key);\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      // If this is a transform, flag and enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key);\n      if (!transformIsNone) continue; // If all the transform keys we've so far encountered are their default value\n      // then check to see if this one isn't\n\n      var defaultValue = valueType.default !== undefined ? valueType.default : 0;\n      if (value !== defaultValue) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      transformOrigin[key] = valueAsType;\n      hasTransformOrigin = true;\n    } else if (key !== \"transform\" || typeof value !== \"function\") {\n      var bucket = isCSSVariable(key) ? vars : style;\n      bucket[key] = valueAsType;\n    }\n  } // Only process transform if values aren't defaults\n\n\n  if (hasTransform || transformTemplate) {\n    style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\n  } // Only process transform origin if values aren't default\n\n\n  if (hasTransformOrigin) {\n    var originX = transformOrigin.originX || \"50%\";\n    var originY = transformOrigin.originY || \"50%\";\n    var originZ = transformOrigin.originZ || \"0\";\n    style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\n  }\n}\n/**\n * A VisualElement for HTMLElements\n */\n\n\nvar HTMLVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(HTMLVisualElement, _super);\n\n  function HTMLVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable record of styles we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n\n    _this.style = {};\n    /**\n     * A record of styles we only want to apply via React. This gets set in useMotionValues\n     * and applied in the render function. I'd prefer this to live somewhere else to decouple\n     * VisualElement from React but works for now.\n     */\n\n    _this.reactStyle = {};\n    /**\n     * A mutable record of CSS variables we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.vars = {};\n    /**\n     * A mutable record of transforms we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transform = {};\n    /**\n     * A mutable record of transform origins we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformOrigin = {};\n    /**\n     * A mutable record of transform keys we want to apply to the rendered Element. We order\n     * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformKeys = [];\n    _this.defaultConfig = {\n      enableHardwareAcceleration: true,\n      allowTransformNone: true\n    };\n    _this.config = _this.defaultConfig;\n    return _this;\n  }\n  /**\n   * The measured bounding box as it exists on the page with no transforms applied.\n   */\n  //private measuredBox = axisBox()\n\n  /**\n   * The `measuredBox` layout as corrected for all the transforms being applied up the\n   * tree. We use this as the final bounding box from which we calculate a transform\n   * delta to our desired visual position on any given frame.\n   *\n   * This is considered mutable to avoid object creation on each frame.\n   */\n  //private correctedBox = axisBox()\n\n  /**\n   * The visual target we want to project our component into on a given frame.\n   *\n   * This is considered mutable to avoid object creation on each frame.\n   */\n  //private targetBox = axisBox()\n\n  /**\n   * The overall scale of the local coordinate system as transformed by all parents of this component. We use this\n   * for scale correction on our calculated layouts and scale-affected values like `boxShadow`.\n   *\n   * This is considered mutable to avoid object creation on each frame.\n   */\n  //private treeScale = { x: 1, y: 1 }\n\n  /**\n   * When a value is removed, we want to make sure it's removed from all rendered data structures.\n   */\n\n\n  HTMLVisualElement.prototype.removeValue = function (key) {\n    _super.prototype.removeValue.call(this, key);\n\n    delete this.vars[key];\n    delete this.style[key];\n  };\n  /**\n   * Empty the mutable data structures by re-creating them. We can do this every React render\n   * as the comparative workload to the rest of the render is very low and this is also when\n   * we want to reflect values that might have been removed by the render.\n   */\n\n\n  HTMLVisualElement.prototype.clean = function () {\n    this.style = {};\n    this.vars = {};\n    this.transform = {};\n  };\n\n  HTMLVisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign(__assign({}, this.defaultConfig), config);\n  };\n  /**\n   * Measure and return the Element's bounding box. We convert it to a AxisBox2D\n   * structure to make it easier to work on each individual axis generically.\n   */\n\n\n  HTMLVisualElement.prototype.getBoundingBox = function () {\n    var transformPagePoint = this.config.transformPagePoint;\n    var box = this.element.getBoundingClientRect();\n    box = transformBoundingBox(box, transformPagePoint);\n    return convertBoundingBoxToAxisBox(box);\n  };\n  /**\n   * Build a style prop using the latest resolved MotionValues\n   */\n\n\n  HTMLVisualElement.prototype.build = function () {\n    // TODO: Add shadow bounding box resolution\n    buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config);\n  };\n  /**\n   * Read a value directly from the HTMLElement style.\n   */\n\n\n  HTMLVisualElement.prototype.read = function (key) {\n    return this.getComputedStyle()[key] || 0;\n  };\n  /**\n   * Read a value directly from the HTMLElement in case it's not defined by a Motion\n   * prop. If it's a transform, we just return a pre-defined default value as reading these\n   * out of a matrix is either error-prone or can incur a big payload for little benefit.\n   */\n\n\n  HTMLVisualElement.prototype.readNativeValue = function (key) {\n    if (isTransformProp(key)) {\n      var defaultValueType = getDefaultValueType(key);\n      return defaultValueType ? defaultValueType.default || 0 : 0;\n    } else {\n      return this.read(key);\n    }\n  };\n  /**\n   * Return the computed style after a render.\n   */\n\n\n  HTMLVisualElement.prototype.getComputedStyle = function () {\n    return window.getComputedStyle(this.getInstance());\n  };\n  /**\n   * Render the Element by rebuilding and applying the latest styles and vars.\n   */\n\n\n  HTMLVisualElement.prototype.render = function () {\n    // Rebuild the latest animated values into style and vars caches.\n    this.build(); // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n\n    Object.assign(this.element.style, this.style); // Loop over any CSS variables and assign those.\n\n    for (var key in this.vars) {\n      this.element.style.setProperty(key, this.vars[key]);\n    }\n  };\n\n  return HTMLVisualElement;\n}(VisualElement); // const axisBox = (): AxisBox2D => ({\n//     x: { min: 0, max: 0 },\n//     y: { min: 0, max: 0 },\n// })\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\n\n\nfunction useConstant(init) {\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n} // Convert a progress 0-1 to a pixels value based on the provided length\n\n\nvar progressToPixels = function (progress, length) {\n  return px.transform(progress * length);\n};\n\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\n\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  } // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n\n  var keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = progressToPixels(-offset, totalLength); // Build the dash array\n\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\nvar unmeasured = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\n\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      // This is object creation, which we try to avoid per-frame.\n  latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n  /**\n   * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\n   */\n\n\n  buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n\n  if (attrs.transform) {\n    style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (originX !== undefined || originY !== undefined || style.transform) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Treat x/y not as shortcuts but as actual attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY; // Build SVG path if one has been measured\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n\n  return attrs;\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */\n\n\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\"]);\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\n\nvar camelToDash = function (str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n/**\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\n * share data structures.\n */\n\n\nvar SVGVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(SVGVisualElement, _super);\n\n  function SVGVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable record of attributes we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n\n    _this.attrs = {};\n    /**\n     * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\n     */\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: false\n    };\n    /**\n     * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\n     * being assigned to config\n     */\n\n    _this.config = _this.defaultConfig;\n    return _this;\n  }\n  /**\n   * Measure the SVG element on mount. This can affect page rendering so there might be a\n   * better time to perform this - for instance dynamically only if there's a transform-origin dependent\n   * transform being set (like rotate)\n   */\n\n\n  SVGVisualElement.prototype.mount = function (element) {\n    _super.prototype.mount.call(this, element);\n\n    this.measure();\n  };\n  /**\n   * Update the SVG dimensions and path length\n   */\n\n\n  SVGVisualElement.prototype.measure = function () {\n    try {\n      this.dimensions = typeof this.element.getBBox === \"function\" ? this.element.getBBox() : this.element.getBoundingClientRect();\n    } catch (e) {\n      // Most likely trying to measure an unrendered element under Firefox\n      this.dimensions = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    if (isPath(this.element)) {\n      this.totalPathLength = this.element.getTotalLength();\n    }\n  };\n  /**\n   * Empty the mutable data structures in case attrs have been removed between renders.\n   */\n\n\n  SVGVisualElement.prototype.clean = function () {\n    _super.prototype.clean.call(this);\n\n    this.attrs = {};\n  };\n  /**\n   * Read an attribute directly from the SVGElement\n   */\n\n\n  SVGVisualElement.prototype.read = function (key) {\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return this.element.getAttribute(key);\n  };\n\n  SVGVisualElement.prototype.build = function () {\n    buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\n  };\n\n  SVGVisualElement.prototype.render = function () {\n    // Update HTML styles and CSS variables\n    _super.prototype.render.call(this); // Loop through attributes and apply them to the SVGElement\n\n\n    for (var key in this.attrs) {\n      this.element.setAttribute(camelToDash(key), this.attrs[key]);\n    }\n  };\n\n  return SVGVisualElement;\n}(HTMLVisualElement);\n\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n\nvar svgElements = [\"animate\", \"circle\", \"clipPath\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"textPath\", \"tspan\", \"use\", \"view\"];\nvar svgTagNames = new Set(svgElements);\n/**\n * Determine whether this is a HTML or SVG component based on if the provided\n * Component is a string and a recognised SVG tag. A potentially better way to\n * do this would be to offer a `motion.customSVG` function and determine this\n * when we generate the `motion.circle` etc components.\n */\n\nfunction isSVGComponent(Component) {\n  return typeof Component === \"string\" && svgTagNames.has(Component);\n}\n/**\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\n * or SVGVisualElement for the component.\n */\n\n\nvar useDomVisualElement = function (Component, props, parent, isStatic, ref) {\n  var visualElement = useConstant(function () {\n    var DOMVisualElement = isSVGComponent(Component) ? SVGVisualElement : HTMLVisualElement;\n    return new DOMVisualElement(parent, ref);\n  });\n  visualElement.updateConfig(__assign({\n    enableHardwareAcceleration: !isStatic\n  }, props));\n  return visualElement;\n};\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\n\n\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"static\", \"layoutId\", \"layoutOrder\", \"_shouldAnimate\", \"isPresent\", \"magicDependency\", \"allowTransformNone\", \"onMagicComplete\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"_dragValueX\", \"_dragValueY\", \"_dragTransitionControls\", \"dragOriginX\", \"dragOriginY\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileHover\", \"whileTap\", \"onHoverEnd\", \"onHoverStart\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\n\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\nvar isPropValid = function (key) {\n  return !isValidMotionProp(key);\n};\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\n\n\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n\n  isPropValid = function (key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\n\nfunction filterProps(props) {\n  var domProps = {};\n\n  for (var key in props) {\n    if (isPropValid(key)) domProps[key] = props[key];\n  }\n\n  return domProps;\n}\n\nfunction buildHTMLProps(visualElement, _a) {\n  var drag = _a.drag; // The `any` isn't ideal but it is the type of createElement props argument\n\n  var htmlProps = {\n    style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars)\n  };\n\n  if (!!drag) {\n    // Disable text selection\n    htmlProps.style.userSelect = \"none\"; // Disable the ghost element when a user drags\n\n    htmlProps.draggable = false;\n  }\n\n  return htmlProps;\n}\n/**\n * Build React props for SVG elements\n */\n\n\nfunction buildSVGProps(visualElement) {\n  return __assign(__assign({}, visualElement.attrs), {\n    style: __assign({}, visualElement.reactStyle)\n  });\n}\n\nfunction render(Component, props, visualElement) {\n  // Only filter props from components we control, ie `motion.div`. If this\n  // is a custom component pass along everything provided to it.\n  var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\n  /**\n   * Every render, empty and rebuild the animated values to be applied to our Element.\n   * During animation these data structures are used in a mutable fashion to reduce\n   * garbage collection, but between renders we can flush them to remove values\n   * that might have been taken out of the provided props.\n   */\n\n  visualElement.clean();\n  visualElement.build(); // Generate props to visually render this component\n\n  var visualProps = isSVGComponent(Component) ? buildSVGProps(visualElement) : buildHTMLProps(visualElement, props);\n  return createElement(Component, __assign(__assign(__assign({}, forwardedProps), {\n    ref: visualElement.ref\n  }), visualProps));\n}\n\nfunction isCSSVariable$1(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  var token = match[1],\n      fallback = match[2];\n  return [token, fallback];\n}\n\nvar maxDepth = 4;\n\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n\n  var _a = parseCSSVariable(current),\n      token = _a[0],\n      fallback = _a[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved;\n  } else if (isCSSVariable$1(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __rest(_a, []);\n\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = __assign({}, transitionEnd);\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable$1(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable$1(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd && transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nvar isKeyframesTarget = function (v) {\n  return Array.isArray(v);\n};\n\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function (v) {\n  return v === number || v === px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function (_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function (_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.getBoundingBox();\n  var elementComputedStyle = visualElement.getComputedStyle();\n  var display = elementComputedStyle.display,\n      top = elementComputedStyle.top,\n      left = elementComputedStyle.left,\n      bottom = elementComputedStyle.bottom,\n      right = elementComputedStyle.right,\n      transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  }; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValues(\"display\", target.display || \"block\");\n  } // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n\n  visualElement.render();\n  var targetBbox = visualElement.getBoundingBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var key = _a[0],\n            value = _a[1];\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.render();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\n\n\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n/**\n * Use callback either only on the initial render or on all renders. In concurrent mode\n * the \"initial\" render might run multiple times\n *\n * @param callback - Callback to run\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\n *\n * @public\n */\n\n\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\n  if (isInitialOnly === void 0) {\n    isInitialOnly = false;\n  }\n\n  var isInitialRender = useRef(true);\n\n  if (!isInitialOnly || isInitialOnly && isInitialRender.current) {\n    callback();\n  }\n\n  isInitialRender.current = false;\n}\n/**\n * Control animations on one or more components.\n *\n * @public\n */\n\n\nvar AnimationControls =\n/** @class */\nfunction () {\n  function AnimationControls() {\n    /**\n     * Track whether the host component has mounted.\n     *\n     * @internal\n     */\n    this.hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     *\n     * @internal\n     */\n\n    this.pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     *\n     * @internal\n     */\n\n    this.componentControls = new Set();\n  }\n  /**\n   * Set variants on this and all child components.\n   *\n   * @param variants - The variants to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setVariants = function (variants) {\n    this.variants = variants;\n    this.componentControls.forEach(function (controls) {\n      return controls.setVariants(variants);\n    });\n  };\n  /**\n   * Set a default transition on this and all child components\n   *\n   * @param transition - The default transition to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setDefaultTransition = function (transition) {\n    this.defaultTransition = transition;\n    this.componentControls.forEach(function (controls) {\n      return controls.setDefaultTransition(transition);\n    });\n  };\n  /**\n   * Subscribes a component's animation controls to this.\n   *\n   * @param controls - The controls to subscribe\n   * @returns An unsubscribe function.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    if (this.variants) controls.setVariants(this.variants);\n    if (this.defaultTransition) controls.setDefaultTransition(this.defaultTransition);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Starts an animation on all linked components.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * controls.start(\"variantLabel\")\n   * controls.start({\n   *   x: 0,\n   *   transition: { duration: 1 }\n   * })\n   * ```\n   *\n   * @param definition - Properties or variant label to animate to\n   * @param transition - Optional `transtion` to apply to a variant\n   * @returns - A `Promise` that resolves when all animations have completed.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.start = function (definition, transitionOverride) {\n    var _this = this;\n\n    if (this.hasMounted) {\n      var animations_1 = [];\n      this.componentControls.forEach(function (controls) {\n        var animation = controls.start(definition, {\n          transitionOverride: transitionOverride\n        });\n        animations_1.push(animation);\n      });\n      return Promise.all(animations_1);\n    } else {\n      return new Promise(function (resolve) {\n        _this.pendingAnimations.push({\n          animation: [definition, transitionOverride],\n          resolve: resolve\n        });\n      });\n    }\n  };\n  /**\n   * Instantly set to a set of properties or a variant.\n   *\n   * ```jsx\n   * // With properties\n   * controls.set({ opacity: 0 })\n   *\n   * // With variants\n   * controls.set(\"hidden\")\n   * ```\n   *\n   * @internalremarks\n   * We could perform a similar trick to `.start` where this can be called before mount\n   * and we maintain a list of of pending actions that get applied on mount. But the\n   * expectation of `set` is that it happens synchronously and this would be difficult\n   * to do before any children have even attached themselves. It's also poor practise\n   * and we should discourage render-synchronous `.start` calls rather than lean into this.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.set = function (definition) {\n    invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n    return this.componentControls.forEach(function (controls) {\n      return controls.apply(definition);\n    });\n  };\n  /**\n   * Stops animations on all linked components.\n   *\n   * ```jsx\n   * controls.stop()\n   * ```\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.stop = function () {\n    this.componentControls.forEach(function (controls) {\n      return controls.stop();\n    });\n  };\n  /**\n   * Initialises the animation controls.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.mount = function () {\n    var _this = this;\n\n    this.hasMounted = true;\n    this.pendingAnimations.forEach(function (_a) {\n      var animation = _a.animation,\n          resolve = _a.resolve;\n      return _this.start.apply(_this, animation).then(resolve);\n    });\n  };\n  /**\n   * Stops all child animations when the host component unmounts.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.unmount = function () {\n    this.hasMounted = false;\n    this.stop();\n  };\n\n  return AnimationControls;\n}();\n/**\n * @internal\n */\n\n\nvar animationControls = function () {\n  return new AnimationControls();\n};\n/**\n * @public\n */\n\n\nvar PresenceContext = createContext(null);\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\n\nfunction useMotionValue(initial) {\n  return useConstant(function () {\n    return motionValue(initial);\n  });\n}\n\nvar isCustomValue = function (v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nvar resolveFinalValueInKeyframes = function (v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\n\n\nfunction resolveMotionValue(value) {\n  var unwrappedValue = value instanceof MotionValue ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n} // Call a handler once for each axis\n\n\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n/**\n * If a bounding box is measured as 0 on either axis we encounter\n * divide by zero errors. We can prevent the actual errors by dividing by\n * an arbitrarily low amount, but then it's possible to see bugs where\n * child elements appear smeared across the screen. By setting each axis\n * to a non-zero measurement, the element itself will disappear (as you\n * can't invert scale: 0) but it will correctly animate back out, and it\n * fixes distortion on any children.\n */\n\n\nfunction safeBoundingBox(box) {\n  var safePixels = 0.5;\n  eachAxis(function (axis) {\n    var boxAxis = box[axis];\n\n    if (boxAxis.min === boxAxis.max) {\n      boxAxis.min -= safePixels;\n      boxAxis.max += safePixels;\n    }\n  });\n  return box;\n}\n\nvar clampProgress = clamp(0, 1);\n\nfunction snapshotLayout(element) {\n  var boundingBox = element.getBoundingBox();\n  return safeBoundingBox(boundingBox);\n}\n\nfunction snapshotStyle(element, valueHandlers) {\n  var computedStyle = element.getComputedStyle();\n  var style = {\n    position: computedStyle.position\n  };\n\n  for (var key in valueHandlers) {\n    var handler = valueHandlers[key];\n\n    if (handler.read === false) {\n      continue;\n    } else if (handler.read) {\n      style[key] = handler.read(computedStyle[key]);\n    } else {\n      style[key] = computedStyle[key];\n    }\n  }\n\n  warning(computedStyle.display !== \"inline\", \"Magic components can't be display: inline, as inline elements don't accept a transform. Try inline-block instead.\");\n  return style;\n}\n\nfunction snapshot(element, valueHandlers) {\n  return {\n    layout: snapshotLayout(element),\n    style: snapshotStyle(element, valueHandlers)\n  };\n}\n/**\n * Calculate an appropriate transform origin for this delta.\n *\n * If components don't change size, it isn't really relavent what origin we provide.\n * When a component is scaling, we want to generate a visually appeasing transform origin and allow\n * the component to scale out (or in) from there. This means 0 for components whose left edge\n * is the same or beyond the `before`, 1 for the inverse, and 0-1 for in between.\n */\n\n\nfunction calcOrigin$1(before, after) {\n  var origin = 0.5;\n  var beforeSize = before.max - before.min;\n  var afterSize = after.max - after.min;\n\n  if (beforeSize > afterSize) {\n    origin = progress(before.min, before.max - afterSize, after.min);\n  } else if (afterSize > beforeSize) {\n    origin = progress(after.min, after.max - beforeSize, before.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\n * Calculate a translation value that, if applied to `after` with the given\n * `origin`, would return `before`\n */\n\n\nfunction calcTranslate(before, after, origin) {\n  var beforePoint = mix(before.min, before.max, origin);\n  var afterPoint = mix(after.min, after.max, origin);\n  return beforePoint - afterPoint;\n}\n/**\n * Applies a `scale` to a `point` from the given `originPoint`.\n */\n\n\nfunction scaledPoint(_a, point) {\n  var scale = _a.scale,\n      originPoint = _a.originPoint;\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Calculate a transform delta that, if applied to `after`, will\n * create `before`.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\n\n\nfunction calcDelta(delta, before, after, origin) {\n  var beforeSize = before.max - before.min;\n  var afterSize = after.max - after.min;\n  delta.scale = beforeSize / afterSize;\n  delta.origin = origin !== undefined ? origin : calcOrigin$1(before, after);\n  delta.originPoint = after.min + delta.origin * afterSize;\n  delta.translate = calcTranslate(before, after, delta.origin); // Clamp\n\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Calculate a transform delta between before and after.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\n\n\nfunction calcBoxDelta(delta, before, after, origin) {\n  calcDelta(delta.x, before.x, after.x, origin);\n  calcDelta(delta.y, before.y, after.y, origin);\n}\n/**\n * Apple the translation and scale delta to a single point.\n */\n\n\nfunction applyDelta(point, delta) {\n  return scaledPoint(delta, point) + delta.translate;\n}\n/**\n * Scale and translate both points on an axis.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\n\n\nfunction applyAxisDelta(axis, delta) {\n  axis.min = applyDelta(axis.min, delta);\n  axis.max = applyDelta(axis.max, delta);\n}\n/**\n * Scale and translate both axis of a box.\n */\n\n\nfunction applyBoxDelta(box, delta) {\n  applyAxisDelta(box.x, delta.x);\n  applyAxisDelta(box.y, delta.y);\n}\n/**\n * Apply a whole tree of deltas to a box. Along the way, keep track of the\n * resultant scale of the tree.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\n\n\nfunction applyTreeDeltas(box, treeScale, deltas) {\n  var numDeltas = deltas.length;\n  treeScale.x = treeScale.y = 1;\n\n  for (var i = 0; i < numDeltas; i++) {\n    var delta = deltas[i];\n    applyBoxDelta(box, delta);\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale;\n  }\n}\n\nfunction resolve(defaultValue, value) {\n  return value === undefined ? defaultValue : resolveMotionValue(value);\n}\n/**\n * Reset `element.style` to ensure we're not reading styles that have previously been animated.\n * If anything is set in the incoming style prop, use that, otherwise unset to ensure the\n * underlying CSS is read.\n *\n * @param styleProp\n */\n\n\nfunction resetStyles(style, valueHandlers) {\n  var reset = {\n    x: 0,\n    y: 0,\n    scale: 1,\n    scaleX: 1,\n    scaleY: 1,\n    rotate: 0\n  }; // TODO: We need to resolve MotionValues\n\n  for (var key in valueHandlers) {\n    var handler = valueHandlers[key];\n\n    if (style[key] !== undefined) {\n      reset[key] = style[key];\n    } else if (handler.reset) {\n      reset[key] = handler.reset(style);\n    } else {\n      reset[key] = \"\";\n    }\n  } // if (offsetSnapshot) {\n  //     Object.assign(reset, offsetSnapshot, { position: \"absolute\" })\n  // }\n\n\n  return reset;\n}\n/**\n * Apply the saved current styles to the provided style object.\n */\n\n\nfunction applyCurrent(style, current) {\n  for (var key in current) {\n    style[key] = current[key];\n  }\n}\n/**\n * An object representing a zero or neutral delta. Applying this as a\n * transform would leave a bounding box unchanged.\n */\n\n\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\n/**\n * Tween a single axis between two bounding boxes.\n *\n * This is a mutative operation.\n */\n\nfunction tweenAxis(axis, target, prev, next, p) {\n  target[axis].min = mix(prev[axis].min, next[axis].min, p);\n  target[axis].max = mix(prev[axis].max, next[axis].max, p);\n}\n/**\n * Tween between two bounding boxes.\n *\n * This is a mutative operation.\n */\n\n\nfunction tweenAxisBox(target, prev, next, p) {\n  tweenAxis(\"x\", target, prev, next, p);\n  tweenAxis(\"y\", target, prev, next, p);\n}\n\nvar defaultHandler = {\n  snapshotTarget: function (child) {\n    return child.snapshotTarget();\n  },\n  startAnimation: function (child) {\n    return child.startAnimation();\n  }\n}; // const isPresent = (child: Auto) => child.isPresent()\n// const isExiting = (child: Auto) => !isPresent(child)\n// const isExitingRoot = (child: Auto) => !isPresent(child)\n\nvar batchTransitions = function () {\n  var queue = new Set();\n\n  var add = function (child) {\n    return queue.add(child);\n  };\n\n  var flush = function (_a) {\n    var _b = _a === void 0 ? defaultHandler : _a,\n        snapshotTarget = _b.snapshotTarget,\n        startAnimation = _b.startAnimation;\n\n    if (!queue.size) return;\n    var order = Array.from(queue).sort(sortByDepth);\n    order.forEach(function (child) {\n      return child.resetStyles();\n    });\n    order.forEach(snapshotTarget); // const present = order.filter(isPresent)\n    // const exiting = order.filter(isExiting)\n    // const exitingRoots = exiting.filter(isExitingRoot)\n    // // Snapshot the position of all the exiting components, as we will use\n    // // these bounding boxes to project into\n    // exiting.forEach(child => child.snapshotTarget())\n    // // Reset all styles to figure out where everything would be laid out\n    // order.forEach(child => child.resetStyles())\n    // // For each exiting root, we use the snapshot information to pop from the document flow.\n    // // TODO: We actually probably want to loop through all children and checking if we're popped and still exiting\n    // exitingRoots.forEach(child => child.popFromFlow())\n    // // TODO: Reset snapshot origin?\n    // // Snapshot all present components in their new layout positions\n    // present.forEach(snapshotTarget)\n    // Start the layout animations\n\n    order.forEach(startAnimation);\n    queue.clear();\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n};\n\nvar sortByDepth = function (a, b) {\n  return a.depth - b.depth;\n};\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n/**\n * Check if the provided context is the SharedLayoutContext default\n * or if we're the child of an AnimateSharedLayout component.\n */\n\n\nfunction isSharedLayoutTree(context) {\n  return !!context.register;\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\n * Look up the tree to check whether we're in a visible portion\n * of the tree. If we're not, we can optimise away this animation.\n */\n\n\nfunction isTreeVisible(deltas) {\n  var isVisible = true;\n  var numDeltas = deltas.length;\n\n  for (var i = 0; i < numDeltas; i++) {\n    if (!deltas[i].isVisible) {\n      isVisible = false;\n      continue;\n    }\n  }\n\n  return isVisible;\n}\n/**\n * Detect which automatically animatable values don't need scale correction and can be animated normally.\n */\n\n\nfunction getAnimatableValues(supportedAutoValues) {\n  return Object.keys(supportedAutoValues).filter(function (key) {\n    return !supportedAutoValues[key].createUpdater;\n  });\n}\n\nfunction fixTransparentRGB(a, b) {\n  var isBlack = !a.red && !a.green && !a.blue;\n  var isTransparent = !a.alpha;\n  var fixed = isBlack && isTransparent ? __assign(__assign({}, b), {\n    alpha: 0\n  }) : a;\n  return rgba.transform(fixed);\n}\n\nfunction fixTransparentRGBPair(origin, target) {\n  var parsedOrigin = rgba.parse(origin);\n  var parsedTarget = rgba.parse(target);\n  return [fixTransparentRGB(parsedOrigin, parsedTarget), fixTransparentRGB(parsedTarget, parsedOrigin)];\n}\n/**\n * @internal\n */\n\n\nvar MotionContext = createContext({\n  static: false,\n  layoutDepth: -1\n});\n\nvar isVariantLabel = function (v) {\n  return typeof v === \"string\" || Array.isArray(v);\n};\n\nvar isAnimationControls = function (v) {\n  return v instanceof AnimationControls;\n};\n/**\n * Set up the context for children motion components.\n *\n * We also use this opportunity to apply `initial` values\n */\n\n\nvar useMotionContext = function (parentContext, controls, visualElement, isStatic, _a) {\n  if (isStatic === void 0) {\n    isStatic = false;\n  }\n\n  var initial = _a.initial,\n      animate = _a.animate,\n      variants = _a.variants,\n      whileTap = _a.whileTap,\n      whileHover = _a.whileHover,\n      layoutId = _a.layoutId;\n\n  var _b, _c;\n\n  var presenceContext = useContext(PresenceContext);\n  var presenceId = (_b = presenceContext) === null || _b === void 0 ? void 0 : _b.id;\n  var isPresenceRoot = parentContext.presenceId !== presenceId; // Override initial with that from a parent context, if defined\n\n  if (((_c = presenceContext) === null || _c === void 0 ? void 0 : _c.initial) !== undefined) {\n    initial = presenceContext.initial;\n  }\n\n  var initialState;\n\n  if (initial === false && !isAnimationControls(animate)) {\n    initialState = animate;\n  } else if (typeof initial !== \"boolean\") {\n    initialState = initial;\n  } // Track mounted status so children can detect whether they were present during their\n  // parent's first render\n\n\n  var hasMounted = useRef(false); // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\n  // if we're being used to control variants, or if we're being passed animation controls.\n  // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\n  // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\n  // that this restriction is removed.\n\n  var shouldPropagateControls = variants || isVariantLabel(animate) || isVariantLabel(whileTap) || isVariantLabel(whileHover) || isAnimationControls(animate); // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\n\n  var targetInitial = isVariantLabel(initialState) ? initialState : parentContext.initial; // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\n  // the tree initially animates.\n\n  var targetAnimate = isVariantLabel(animate) ? animate : parentContext.animate; // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\n  // or in another non-animation/interaction environment.\n\n  var initialDependency = isStatic ? targetInitial : null; // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\n  // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\n  // We want to do this as we rely on React's component rendering order each render cycle to determine\n  // the new order of any child components for the `staggerChildren` functionality.\n\n  var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate) ? targetAnimate : null; // TODO: We need every motion component in the stack to communicate down - for performance we can look into\n  // ditching zero deltas if this isn't a motion component\n\n  var layoutDelta = useConstant(createZeroDelta);\n  var layoutDeltas = useRef(__spreadArrays(parentContext.layoutDeltas || [], [layoutDelta]));\n  var layoutProgress = useMotionValue(0); // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\n  // unlikely to change, by making the context an object it'll be considered a new value every render.\n  // So all child motion components will re-render as a result.\n\n  var context = useMemo(function () {\n    return {\n      controls: shouldPropagateControls ? controls : parentContext.controls,\n      initial: targetInitial,\n      animate: targetAnimate,\n      visualElement: visualElement,\n      hasMounted: hasMounted,\n      isReducedMotion: parentContext.isReducedMotion,\n      presenceId: presenceId,\n      layoutDepth: // TODO: Make nice isMagic\n      animate || layoutId !== undefined ? parentContext.layoutDepth + 1 : parentContext.layoutDepth,\n      layoutDelta: layoutDelta,\n      layoutDeltas: layoutDeltas.current,\n      layoutProgress: layoutProgress,\n      isPresenceRoot: isPresenceRoot\n    };\n  }, [initialDependency, animateDependency, parentContext.isReducedMotion, animate, layoutId, presenceId]); // Update the `static` property every render. This is unlikely to change but also essentially free.\n\n  context.static = isStatic; // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\n  // in `initial`.\n\n  useInitialOrEveryRender(function () {\n    var initialToApply = initialState || parentContext.initial;\n    initialToApply && controls.apply(initialToApply);\n  }, !isStatic);\n  useEffect(function () {\n    hasMounted.current = true;\n  }, []);\n  return context;\n};\n\nfunction createZeroDelta() {\n  return {\n    x: __assign({}, zeroDelta),\n    y: __assign({}, zeroDelta),\n    isVisible: true\n  };\n}\n\nvar checkShouldInheritVariant = function (_a) {\n  var animate = _a.animate,\n      variants = _a.variants,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b;\n  return inherit && !!variants && (!animate || animate instanceof AnimationControls);\n};\n\nvar isMotionValue = function (value) {\n  return value instanceof MotionValue;\n};\n/**\n * Scrape props for MotionValues and add/remove them to this component's\n * VisualElement\n */\n\n\nfunction useMotionValues(visualElement, props) {\n  var prev = useConstant(empty);\n  /**\n   * Remove MotionValues that are no longer present\n   */\n\n  for (var key in prev) {\n    var isTransform = isTransformProp(key) || isTransformOriginProp(key);\n    var existsAsProp = props[key];\n    var existsAsStyle = props.style && props.style[key];\n    var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\n    var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\n    var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\n    var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\n\n    if (transformRemoved || motionValueRemoved) {\n      visualElement.removeValue(key);\n      delete prev[key];\n    }\n  }\n  /**\n   * Add incoming MotionValues\n   */\n\n\n  addMotionValues(visualElement, prev, props);\n  if (props.style) addMotionValues(visualElement, prev, props.style, true);\n  /**\n   * Transform custom values if provided a handler, ie size -> width/height\n   * Ideally we'd ditch this by removing support for size and other custom values from Framer.\n   */\n\n  if (props.transformValues) {\n    visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\n  }\n}\n/**\n * Add incoming MotionValues\n *\n * TODO: Type the VisualElements properly\n */\n\n\nfunction addMotionValues(visualElement, prev, source, isStyle) {\n  if (isStyle === void 0) {\n    isStyle = false;\n  }\n\n  if (isStyle) visualElement.reactStyle = {};\n\n  for (var key in source) {\n    var value = source[key];\n    var foundMotionValue = false;\n\n    if (isMotionValue(value)) {\n      // If this is a MotionValue, add it if it isn't a reserved key\n      if (!reservedNames.has(key)) {\n        visualElement.addValue(key, value);\n        foundMotionValue = true;\n      }\n    } else if (isTransformProp(key) || isTransformOriginProp(key)) {\n      // If this is a transform prop, always create a MotionValue\n      // to ensure we can reconcile them all together.\n      if (!visualElement.hasValue(key)) {\n        visualElement.addValue(key, motionValue(value));\n      } else if (value !== prev[key]) {\n        // If the MotionValue already exists, update it with the\n        // latest incoming value\n        var motion = visualElement.getValue(key);\n        motion.set(value);\n      }\n\n      foundMotionValue = true;\n    } else if (isStyle) {\n      visualElement.reactStyle[key] = value;\n    }\n\n    if (foundMotionValue) prev[key] = value;\n  }\n}\n/**\n * These are props we accept as MotionValues but don't want to add\n * to the VisualElement\n */\n\n\nvar reservedNames = new Set([\"dragOriginX\", \"dragOriginY\", \"_dragValueX\", \"_dragValueY\"]);\n\nvar empty = function () {\n  return {};\n};\n\nvar underDampedSpring = function () {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\n\nvar overDampedSpring = function (to) {\n  return {\n    type: \"spring\",\n    stiffness: 700,\n    damping: to === 0 ? 100 : 35\n  };\n};\n\nvar linearTween = function () {\n  return {\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\n\nvar keyframes = function (values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\n\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: overDampedSpring,\n  scaleY: overDampedSpring,\n  scale: overDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: overDampedSpring\n};\n\nvar getDefaultTransition = function (valueKey, to) {\n  var transitionFactory;\n\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n\n  return __assign({\n    to: to\n  }, transitionFactory(to));\n};\n/**\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\n * updates with `to` and then completes. By using this we can compose instant transitions\n * in with the same logic that applies `delay` or returns a `Promise` etc.\n *\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\n * the animation until after the duration finishes. This is for situations when you're **only**\n * animating non-animatable values and then setting something on `transitionEnd`. Really\n * you want this to fire after the \"animation\" finishes, rather than instantly.\n *\n * ```\n * animate={{\n *   display: 'block',\n *   transitionEnd: { display: 'none' }\n * }}\n * ```\n */\n\n\nvar just = function (_a) {\n  var to = _a.to,\n      duration = _a.duration;\n  return action(function (_a) {\n    var update = _a.update,\n        complete = _a.complete;\n    update(to);\n    duration ? delay(duration).start({\n      complete: complete\n    }) : complete();\n  });\n};\n\nvar easingDefinitionToFunction = function (definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    var x1 = definition[0],\n        y1 = definition[1],\n        x2 = definition[2],\n        y2 = definition[3];\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n\nvar isEasingArray = function (ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nvar isDurationAnimation = function (v) {\n  return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\n\n\nvar isAnimatable = function (key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  complex.test(value) && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n      return true;\n    }\n\n  return false;\n};\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n\n\nvar secondsToMilliseconds = function (seconds) {\n  return seconds * 1000;\n};\n\nvar transitions = {\n  tween: tween,\n  spring: spring,\n  keyframes: keyframes$1,\n  inertia: inertia,\n  just: just\n};\nvar transitionOptionParser = {\n  tween: function (opts) {\n    if (opts.ease) {\n      var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\n      opts.ease = easingDefinitionToFunction(ease);\n    }\n\n    return opts;\n  },\n  keyframes: function (_a) {\n    var from = _a.from,\n        to = _a.to,\n        velocity = _a.velocity,\n        opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\n\n    if (opts.values && opts.values[0] === null) {\n      var values = __spreadArrays(opts.values);\n\n      values[0] = from;\n      opts.values = values;\n    }\n\n    if (opts.ease) {\n      opts.easings = isEasingArray(opts.ease) ? opts.ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(opts.ease);\n    }\n\n    opts.ease = linear;\n    return opts;\n  }\n};\n\nvar isTransitionDefined = function (_a) {\n  var when = _a.when,\n      delay = _a.delay,\n      delayChildren = _a.delayChildren,\n      staggerChildren = _a.staggerChildren,\n      staggerDirection = _a.staggerDirection,\n      transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\n\n  return Object.keys(transition).length;\n};\n\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\n  var delay = transitionDefinition ? transitionDefinition.delay : 0; // If no object, return default transition\n  // A better way to handle this would be to deconstruct out all the shared Orchestration props\n  // and see if there's any props remaining\n\n  if (transitionDefinition === undefined || !isTransitionDefined(transitionDefinition)) {\n    return __assign({\n      delay: delay\n    }, getDefaultTransition(key, to));\n  }\n\n  var valueTransitionDefinition = transitionDefinition[key] || transitionDefinition.default || transitionDefinition;\n\n  if (valueTransitionDefinition.type === false) {\n    return {\n      delay: valueTransitionDefinition.hasOwnProperty(\"delay\") ? valueTransitionDefinition.delay : delay,\n      to: isKeyframesTarget(to) ? to[to.length - 1] : to,\n      type: \"just\"\n    };\n  } else if (isKeyframesTarget(to)) {\n    return __assign(__assign({\n      values: to,\n      duration: 0.8,\n      delay: delay,\n      ease: \"linear\"\n    }, valueTransitionDefinition), {\n      // This animation must be keyframes if we're animating through an array\n      type: \"keyframes\"\n    });\n  } else {\n    return __assign({\n      type: \"tween\",\n      to: to,\n      delay: delay\n    }, valueTransitionDefinition);\n  }\n};\n\nvar preprocessOptions = function (type, opts) {\n  return transitionOptionParser[type] ? transitionOptionParser[type](opts) : opts;\n};\n\nvar getAnimation = function (key, value, target, transition) {\n  var origin = value.get();\n  var isOriginAnimatable = isAnimatable(key, origin);\n  var isTargetAnimatable = isAnimatable(key, target); // TODO we could probably improve this check to ensure both values are of the same type -\n  // for instance 100 to #fff. This might live better in Popmotion.\n\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\"); // Parse the `transition` prop and return options for the Popmotion animation\n\n  var _a = getTransitionDefinition(key, target, transition),\n      _b = _a.type,\n      type = _b === void 0 ? \"tween\" : _b,\n      transitionDefinition = __rest(_a, [\"type\"]); // If this is an animatable pair of values, return an animation, otherwise use `just`\n\n\n  var actionFactory = isOriginAnimatable && isTargetAnimatable ? transitions[type] : just;\n  var opts = preprocessOptions(type, __assign({\n    from: origin,\n    velocity: value.getVelocity()\n  }, transitionDefinition)); // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\n\n  if (isDurationAnimation(opts)) {\n    if (opts.duration) {\n      opts.duration = secondsToMilliseconds(opts.duration);\n    }\n\n    if (opts.repeatDelay) {\n      opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\n    }\n  }\n\n  return [actionFactory, opts];\n};\n/**\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\n *\n * @internal\n */\n\n\nfunction startAnimation(key, value, target, _a) {\n  if (_a === void 0) {\n    _a = {};\n  }\n\n  var _b = _a.delay,\n      delay$1 = _b === void 0 ? 0 : _b,\n      transition = __rest(_a, [\"delay\"]);\n\n  return value.start(function (complete) {\n    var activeAnimation;\n\n    var _a = getAnimation(key, value, target, transition),\n        animationFactory = _a[0],\n        _b = _a[1],\n        valueDelay = _b.delay,\n        options = __rest(_b, [\"delay\"]);\n\n    if (valueDelay !== undefined) {\n      delay$1 = valueDelay;\n    }\n\n    var animate = function () {\n      var animation = animationFactory(options); // Bind animation opts to animation\n\n      activeAnimation = animation.start({\n        update: function (v) {\n          return value.set(v);\n        },\n        complete: complete\n      });\n    }; // If we're delaying this animation, only resolve it **after** the delay to\n    // ensure the value's resolve velocity is up-to-date.\n\n\n    if (delay$1) {\n      activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\n        complete: animate\n      });\n    } else {\n      animate();\n    }\n\n    return function () {\n      if (activeAnimation) activeAnimation.stop();\n    };\n  });\n}\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\n\n\nvar isNumericalString = function (v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n/**\n * Get the current value of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getCurrent = function (visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n};\n/**\n * Get the current velocity of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getVelocity = function (visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n};\n/**\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\n * check, just helps with typing.\n */\n\n\nvar isTargetResolver = function (p) {\n  return typeof p === \"function\";\n};\n/**\n * Check if value is a list of variant labels\n */\n\n\nvar isVariantLabels = function (v) {\n  return Array.isArray(v);\n};\n/**\n * Control animations for a single component\n *\n * @internal\n */\n\n\nvar VisualElementAnimationControls =\n/** @class */\nfunction () {\n  function VisualElementAnimationControls(visualElement, _a) {\n    var _this = this;\n\n    var makeTargetAnimatable = _a.makeTargetAnimatable;\n    /**\n     * A reference to the component's latest props. We could probably ditch this in\n     * favour to a reference to the `custom` prop now we don't send all props through\n     * to target resolvers.\n     */\n\n    this.props = {};\n    /**\n     * The component's variants, as provided by `variants`\n     */\n\n    this.variants = {};\n    /**\n     * A set of values that we animate back to when a value is cleared of all overrides.\n     */\n\n    this.baseTarget = {};\n    /**\n     * A series of target overrides that we can animate to/from when overrides are set/cleared.\n     */\n\n    this.overrides = [];\n    /**\n     * A series of target overrides as they were originally resolved.\n     */\n\n    this.resolvedOverrides = [];\n    /**\n     * A Set of currently active override indexes\n     */\n\n    this.activeOverrides = new Set();\n    /**\n     * A Set of value keys that are currently animating.\n     */\n\n    this.isAnimating = new Set();\n    /**\n     * Check if the associated `VisualElement` has a key with the provided string.\n     * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\n     */\n\n    this.hasValue = function (key) {\n      return !_this.visualElement.hasValue(key);\n    };\n\n    this.visualElement = visualElement;\n    this.makeTargetAnimatable = makeTargetAnimatable;\n    this.visualElement.forEachValue(function (value, key) {\n      return _this.baseTarget[key] = value.get();\n    });\n  }\n  /**\n   * Set the reference to the component's props.\n   * @param props -\n   */\n\n\n  VisualElementAnimationControls.prototype.setProps = function (props) {\n    this.props = props;\n  };\n  /**\n   * Set the reference to the component's variants\n   * @param variants -\n   */\n\n\n  VisualElementAnimationControls.prototype.setVariants = function (variants) {\n    if (variants) this.variants = variants;\n  };\n  /**\n   * Set the component's default transition\n   * @param transition -\n   */\n\n\n  VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\n    if (transition) this.defaultTransition = transition;\n  };\n  /**\n   * Set motion values without animation.\n   *\n   * @param definition -\n   * @param isActive -\n   */\n\n\n  VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.isActive,\n        isActive = _c === void 0 ? new Set() : _c,\n        priority = _b.priority;\n\n    var _d = this.resolveVariant(definition),\n        target = _d.target,\n        transitionEnd = _d.transitionEnd;\n\n    target = this.transformValues(__assign(__assign({}, target), transitionEnd));\n\n    for (var key in target) {\n      if (isActive.has(key)) return;\n      isActive.add(key);\n\n      if (target) {\n        var targetValue = resolveFinalValueInKeyframes(target[key]);\n\n        if (this.visualElement.hasValue(key)) {\n          var value = this.visualElement.getValue(key);\n          value && value.set(targetValue);\n        } else {\n          this.visualElement.addValue(key, motionValue(targetValue));\n        }\n\n        if (!priority) this.baseTarget[key] = targetValue;\n      }\n    }\n  };\n  /**\n   * Allows `transformValues` to be set by a component that allows us to\n   * transform the values in a given `Target`. This allows Framer Library\n   * to extend Framer Motion to animate `Color` variables etc. Currently we have\n   * to manually support these extended types here in Framer Motion.\n   *\n   * @param values -\n   */\n\n\n  VisualElementAnimationControls.prototype.transformValues = function (values) {\n    var transformValues = this.props.transformValues;\n    return transformValues ? transformValues(values) : values;\n  };\n  /**\n   * Check a `Target` for new values we haven't animated yet, and add them\n   * to the `MotionValueMap`.\n   *\n   * Currently there's functionality here that is DOM-specific, we should allow\n   * this functionality to be injected by the factory that creates DOM-specific\n   * components.\n   *\n   * @param target -\n   */\n\n\n  VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\n    var newValueKeys = Object.keys(target).filter(this.hasValue);\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues) return;\n\n    for (var i = 0; i < numNewValues; i++) {\n      var key = newValueKeys[i];\n      var targetValue = target[key];\n      var value = null; // If this is a keyframes value, we can attempt to use the first value in the\n      // array as that's going to be the first value of the animation anyway\n\n      if (Array.isArray(targetValue)) {\n        value = targetValue[0];\n      } // If it isn't a keyframes or the first keyframes value was set as `null`, read the\n      // value from the DOM. It might be worth investigating whether to check props (for SVG)\n      // or props.style (for HTML) if the value exists there before attempting to read.\n\n\n      if (value === null) {\n        value = this.visualElement.readNativeValue(key);\n        invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\n      }\n\n      if (typeof value === \"string\" && isNumericalString(value)) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(targetValue)) {\n        // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n        value = complex.getAnimatableNone(targetValue);\n      }\n\n      this.visualElement.addValue(key, motionValue(value));\n      this.baseTarget[key] = value;\n    }\n  };\n  /**\n   * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\n   * @param variant -\n   */\n\n\n  VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\n    if (!variant) {\n      return {\n        target: undefined,\n        transition: undefined,\n        transitionEnd: undefined\n      };\n    }\n\n    if (isTargetResolver(variant)) {\n      // resolve current and velocity\n      variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\n    }\n\n    var _a = variant.transition,\n        transition = _a === void 0 ? this.defaultTransition : _a,\n        transitionEnd = variant.transitionEnd,\n        target = __rest(variant, [\"transition\", \"transitionEnd\"]);\n\n    return {\n      transition: transition,\n      transitionEnd: transitionEnd,\n      target: target\n    };\n  };\n  /**\n   * Get the highest active override priority index\n   */\n\n\n  VisualElementAnimationControls.prototype.getHighestPriority = function () {\n    if (!this.activeOverrides.size) return 0;\n    return Math.max.apply(Math, Array.from(this.activeOverrides));\n  };\n  /**\n   * Set an override. We add this layer of indirection so if, for instance, a tap gesture\n   * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\n   * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\n   * than the one that was resolved when the hover gesture animation started.\n   *\n   * @param definition -\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\n    this.overrides[overrideIndex] = definition;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.setOverride(definition, overrideIndex);\n      });\n    }\n  };\n  /**\n   * Start an override animation.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\n    var override = this.overrides[overrideIndex];\n\n    if (override) {\n      return this.start(override, {\n        priority: overrideIndex\n      });\n    }\n  };\n  /**\n   * Clear an override. We check every value we animated to in this override to see if\n   * its present on any lower-priority overrides. If not, we animate it back to its base target.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\n    var _this = this;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.clearOverride(overrideIndex);\n      });\n    }\n\n    var override = this.overrides[overrideIndex];\n    if (!override) return;\n    this.activeOverrides.delete(overrideIndex);\n    var highest = this.getHighestPriority();\n    this.resetIsAnimating();\n\n    if (highest) {\n      var highestOverride = this.overrides[highest];\n      highestOverride && this.startOverride(highest);\n    } // Figure out which remaining values were affected by the override and animate those\n\n\n    var overrideTarget = this.resolvedOverrides[overrideIndex];\n    if (!overrideTarget) return;\n    var remainingValues = {};\n\n    for (var key in this.baseTarget) {\n      if (overrideTarget[key] !== undefined) {\n        remainingValues[key] = this.baseTarget[key];\n      }\n    }\n\n    this.onStart();\n    this.animate(remainingValues).then(function () {\n      return _this.onComplete();\n    });\n  };\n  /**\n   * Apply a target/variant without any animation\n   */\n\n\n  VisualElementAnimationControls.prototype.apply = function (definition) {\n    if (Array.isArray(definition)) {\n      return this.applyVariantLabels(definition);\n    } else if (typeof definition === \"string\") {\n      return this.applyVariantLabels([definition]);\n    } else {\n      this.setValues(definition);\n    }\n  };\n  /**\n   * Apply variant labels without animation\n   */\n\n\n  VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\n    var _this = this;\n\n    var isActive = new Set();\n\n    var reversedList = __spreadArrays(variantLabelList).reverse();\n\n    reversedList.forEach(function (key) {\n      var _a = _this.resolveVariant(_this.variants[key]),\n          target = _a.target,\n          transitionEnd = _a.transitionEnd;\n\n      if (transitionEnd) {\n        _this.setValues(transitionEnd, {\n          isActive: isActive\n        });\n      }\n\n      if (target) {\n        _this.setValues(target, {\n          isActive: isActive\n        });\n      }\n\n      if (_this.children && _this.children.size) {\n        _this.children.forEach(function (child) {\n          return child.applyVariantLabels(variantLabelList);\n        });\n      }\n    });\n  };\n\n  VisualElementAnimationControls.prototype.start = function (definition, opts) {\n    var _this = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.priority) {\n      this.activeOverrides.add(opts.priority);\n    }\n\n    this.resetIsAnimating(opts.priority);\n    var animation;\n\n    if (isVariantLabels(definition)) {\n      animation = this.animateVariantLabels(definition, opts);\n    } else if (typeof definition === \"string\") {\n      animation = this.animateVariant(definition, opts);\n    } else {\n      animation = this.animate(definition, opts);\n    }\n\n    this.onStart();\n    return animation.then(function () {\n      return _this.onComplete();\n    });\n  };\n\n  VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.delay,\n        delay = _c === void 0 ? 0 : _c,\n        _d = _b.priority,\n        priority = _d === void 0 ? 0 : _d,\n        transitionOverride = _b.transitionOverride;\n\n    var _e = this.resolveVariant(animationDefinition),\n        target = _e.target,\n        transition = _e.transition,\n        transitionEnd = _e.transitionEnd;\n\n    if (transitionOverride) {\n      transition = transitionOverride;\n    }\n\n    if (!target) return Promise.resolve();\n    target = this.transformValues(target);\n\n    if (transitionEnd) {\n      transitionEnd = this.transformValues(transitionEnd);\n    }\n\n    this.checkForNewValues(target);\n    var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\n\n    if (this.makeTargetAnimatable) {\n      var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\n      target = animatable.target;\n      transitionEnd = animatable.transitionEnd;\n    }\n\n    if (priority) {\n      this.resolvedOverrides[priority] = target;\n    }\n\n    this.checkForNewValues(target);\n    var animations = [];\n\n    for (var key in target) {\n      var value = this.visualElement.getValue(key);\n      if (!value || !target || target[key] === undefined) continue;\n      var valueTarget = target[key];\n\n      if (!priority) {\n        this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\n      }\n\n      if (this.isAnimating.has(key)) continue;\n      this.isAnimating.add(key);\n      animations.push(startAnimation(key, value, valueTarget, __assign({\n        delay: delay\n      }, transition)));\n    }\n\n    var allAnimations = Promise.all(animations);\n    return transitionEnd ? allAnimations.then(function () {\n      _this.setValues(transitionEnd, {\n        priority: priority\n      });\n    }) : allAnimations;\n  };\n\n  VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\n    var _this = this;\n\n    var animations = __spreadArrays(variantLabels).reverse().map(function (label) {\n      return _this.animateVariant(label, opts);\n    });\n\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\n    var _this = this;\n\n    var when = false;\n    var delayChildren = 0;\n    var staggerChildren = 0;\n    var staggerDirection = 1;\n    var priority = opts && opts.priority || 0;\n    var variant = this.variants[variantLabel];\n    var getAnimations = variant ? function () {\n      return _this.animate(variant, opts);\n    } : function () {\n      return Promise.resolve();\n    };\n    var getChildrenAnimations = this.children ? function () {\n      return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\n    } : function () {\n      return Promise.resolve();\n    };\n\n    if (variant && this.children) {\n      var transition = this.resolveVariant(variant).transition;\n\n      if (transition) {\n        when = transition.when || when;\n        delayChildren = transition.delayChildren || delayChildren;\n        staggerChildren = transition.staggerChildren || staggerChildren;\n        staggerDirection = transition.staggerDirection || staggerDirection;\n      }\n    }\n\n    if (when) {\n      var _a = when === \"beforeChildren\" ? [getAnimations, getChildrenAnimations] : [getChildrenAnimations, getAnimations],\n          first = _a[0],\n          last = _a[1];\n\n      return first().then(last);\n    } else {\n      return Promise.all([getAnimations(), getChildrenAnimations()]);\n    }\n  };\n\n  VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\n    if (delayChildren === void 0) {\n      delayChildren = 0;\n    }\n\n    if (staggerChildren === void 0) {\n      staggerChildren = 0;\n    }\n\n    if (staggerDirection === void 0) {\n      staggerDirection = 1;\n    }\n\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (!this.children) {\n      return Promise.resolve();\n    }\n\n    var animations = [];\n    var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n      return i * staggerChildren;\n    } : function (i) {\n      return maxStaggerDuration - i * staggerChildren;\n    };\n    Array.from(this.children).forEach(function (childControls, i) {\n      var animation = childControls.animateVariant(variantLabel, {\n        priority: priority,\n        delay: delayChildren + generateStaggerDuration(i)\n      });\n      animations.push(animation);\n    });\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.onStart = function () {\n    var onAnimationStart = this.props.onAnimationStart;\n    onAnimationStart && onAnimationStart();\n  };\n\n  VisualElementAnimationControls.prototype.onComplete = function () {\n    var onAnimationComplete = this.props.onAnimationComplete;\n    onAnimationComplete && onAnimationComplete();\n  };\n\n  VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\n    var numOverrides = this.overrides.length;\n\n    for (var i = priority + 1; i < numOverrides; i++) {\n      var resolvedOverride = this.resolvedOverrides[i];\n\n      if (resolvedOverride) {\n        for (var key in resolvedOverride) {\n          this.isAnimating.add(key);\n        }\n      }\n    }\n  };\n\n  VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.isAnimating.clear(); // If this isn't the highest priority gesture, block the animation\n    // of anything that's currently being animated\n\n    if (priority < this.getHighestPriority()) {\n      this.checkOverrideIsAnimating(priority);\n    }\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.resetIsAnimating(priority);\n      });\n    }\n  };\n\n  VisualElementAnimationControls.prototype.stop = function () {\n    this.visualElement.forEachValue(function (value) {\n      return value.stop();\n    });\n  };\n  /**\n   * Add the controls of a child component.\n   * @param controls -\n   */\n\n\n  VisualElementAnimationControls.prototype.addChild = function (controls) {\n    if (!this.children) {\n      this.children = new Set();\n    }\n\n    this.children.add(controls); // We set child overrides when `setOverride` is called, but also have to do it here\n    // as the first time `setOverride` is called all the children might not have been added yet.\n\n    this.overrides.forEach(function (override, i) {\n      override && controls.setOverride(override, i);\n    });\n  };\n\n  VisualElementAnimationControls.prototype.removeChild = function (controls) {\n    if (!this.children) {\n      return;\n    }\n\n    this.children.delete(controls);\n  };\n\n  VisualElementAnimationControls.prototype.resetChildren = function () {\n    if (this.children) this.children.clear();\n  };\n\n  return VisualElementAnimationControls;\n}();\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition), _a !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get());\n  }\n\n  return origin;\n}\n/**\n * Creates an imperative set of controls to trigger animations.\n *\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\n *\n * @internal\n */\n\n\nfunction useVisualElementAnimation(visualElement, props, config) {\n  var subscribeToParentControls = checkShouldInheritVariant(props);\n  var variants = props.variants,\n      transition = props.transition;\n  var parentControls = useContext(MotionContext).controls;\n  var presenceContext = useContext(PresenceContext);\n  var controls = useConstant(function () {\n    return new VisualElementAnimationControls(visualElement, config);\n  }); // Reset and resubscribe children every render to ensure stagger order is correct\n\n  if (!presenceContext || presenceContext.isPresent) {\n    controls.resetChildren();\n    controls.setProps(props);\n    controls.setVariants(variants);\n    controls.setDefaultTransition(transition);\n  } // We have to subscribe to the parent controls within a useEffect rather than during render,\n  // as\n\n\n  useEffect(function () {\n    if (subscribeToParentControls && parentControls) {\n      parentControls.addChild(controls);\n    }\n  });\n  useEffect(function () {\n    return function () {\n      // Remove reference to onAnimationComplete from controls. All the MotionValues\n      // are unsubscribed from this component separately. We let animations run out\n      // as they might be animating other components.\n      var onAnimationComplete = props.onAnimationComplete,\n          unmountProps = __rest(props, [\"onAnimationComplete\"]);\n\n      controls.setProps(unmountProps);\n      parentControls && parentControls.removeChild(controls);\n    };\n  }, []);\n  return controls;\n}\n/**\n * @internal\n */\n\n\nvar MotionPluginContext = createContext({\n  transformPagePoint: function (p) {\n    return p;\n  },\n  autoValues: {},\n  features: []\n});\n/**\n * @remarks For now I think this should remain a private API for our own use\n * until we can figure out a nicer way of allowing people to add these\n *\n * @internal\n */\n\nfunction MotionPlugins(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  var pluginContext = useContext(MotionPluginContext);\n  var value = useRef(__assign({}, pluginContext)).current; // Mutative to prevent triggering rerenders in all listening\n  // components every time this component renders\n\n  for (var key in props) {\n    value[key] = props[key];\n  }\n\n  return createElement(MotionPluginContext.Provider, {\n    value: value\n  }, children);\n}\n/**\n * @internal\n */\n\n\nvar SharedLayoutContext = createContext(batchTransitions());\nvar Presence;\n\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n\nvar VisibilityAction;\n\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n\nvar StackPosition;\n\n(function (StackPosition) {\n  StackPosition[StackPosition[\"Lead\"] = 0] = \"Lead\";\n  StackPosition[StackPosition[\"Previous\"] = 1] = \"Previous\";\n})(StackPosition || (StackPosition = {}));\n\nvar session = null;\nvar syncRenderSession = {\n  isOpen: function () {\n    return session !== null;\n  },\n  open: function () {\n    invariant(!session, \"Sync render session already open\");\n    session = [];\n  },\n  flush: function () {\n    invariant(session !== null, \"No sync render session found\");\n    session && session.forEach(function (view) {\n      return view.render();\n    });\n    session = null;\n  },\n  push: function (view) {\n    invariant(session !== null, \"No sync render session found\");\n    session && session.push(view);\n  }\n};\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\n\nfunction usePresence() {\n  var context = useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n      onExitComplete = context.onExitComplete,\n      register = context.register; // Context will never change without full re-renders so it's safe to call this hook conditionally\n\n  useEffect(register, []);\n  return !isPresent && onExitComplete ? [false, onExitComplete] : [true];\n}\n/**\n * @public\n */\n\n\nfunction useIsPresent() {\n  var context = useContext(PresenceContext);\n  return context === null ? true : context.isPresent;\n}\n\nfunction convertSingleRadius(value, axis) {\n  var parsed = parseFloat(value);\n\n  if (px.test(value)) {\n    return parsed;\n  } else {\n    var factor = parsed / 100;\n    return factor * (axis.max - axis.min);\n  }\n}\n\nfunction radiusAsPixels(value, box) {\n  var _a = value.split(\" \"),\n      x = _a[0],\n      y = _a[1];\n\n  return {\n    x: convertSingleRadius(x, box.x),\n    y: convertSingleRadius(y || x, box.y)\n  };\n}\n\nvar singleBorderRadius = function (key) {\n  return {\n    reset: function (style) {\n      return style.borderRadius !== undefined ? style.borderRadius : \"\";\n    },\n    createUpdater: function (visualElement, origin, target, current, delta, treeScale, originBox, targetBox) {\n      if (!origin && !target) return;\n      var motionValue = visualElement.getValue(key, \"\");\n      var originAsPixels = radiusAsPixels(origin, originBox);\n      var targetAsPixels = radiusAsPixels(target, targetBox);\n      return function (p) {\n        var vx = mix(originAsPixels.x, targetAsPixels.x, p);\n        var vy = mix(originAsPixels.y, targetAsPixels.y, p);\n        current[key] = vx + \"px \" + vy + \"px\";\n        var targetX = vx / delta.x.scale / treeScale.x;\n        var targetY = vy / delta.y.scale / treeScale.y; // Perform the animation in pixels but if we don't need correction just set\n        // to the target so percentages have an affect going forward\n\n        var latest = p === 1 && delta.x.scale / treeScale.x / delta.y.scale / treeScale.y === 1 ? target : targetX + \"px \" + targetY + \"px\";\n        motionValue.set(latest);\n      };\n    }\n  };\n};\n\nvar defaultMagicValues = {\n  backgroundColor: {\n    reset: function (style) {\n      return style.background !== undefined ? style.background : \"\";\n    }\n  },\n  borderRadius: {\n    read: false\n  },\n  borderTopLeftRadius: singleBorderRadius(\"borderTopLeftRadius\"),\n  borderTopRightRadius: singleBorderRadius(\"borderTopRightRadius\"),\n  borderBottomLeftRadius: singleBorderRadius(\"borderBottomLeftRadius\"),\n  borderBottomRightRadius: singleBorderRadius(\"borderBottomRightRadius\"),\n  boxShadow: {\n    createUpdater: function (visualElement, origin, target, current, delta, treeScale) {\n      if (isEmptyBoxShadow(origin) && isEmptyBoxShadow(target)) {\n        return;\n      }\n\n      var originShadow = getAnimatableShadow(origin, target);\n      var targetShadow = getAnimatableShadow(target, origin);\n\n      var currentShadow = __spreadArrays(originShadow);\n\n      var mixShadowColor = mixColor(originShadow[0], currentShadow[0]);\n      var shadowTemplate = complex.createTransformer(target !== \"none\" ? target : origin);\n      var dx = delta.x;\n      var dy = delta.y;\n      var boxShadow = visualElement.getValue(\"boxShadow\", \"\");\n      return function (p) {\n        // Update box shadow\n        currentShadow[0] = mixShadowColor(p); // color\n\n        currentShadow[1] = mix(originShadow[1], targetShadow[1], p); // x\n\n        currentShadow[2] = mix(originShadow[2], targetShadow[2], p); // y\n\n        currentShadow[3] = mix(originShadow[3], targetShadow[3], p); // blur\n\n        currentShadow[4] = mix(originShadow[4], targetShadow[4], p); // spread\n        // Update prev box shadow before FLIPPing\n\n        current.boxShadow = shadowTemplate(currentShadow); // Apply FLIP inversion to physical dimensions. We need to take an average scale for XY to apply\n        // to blur and spread, which affect both axis equally.\n\n        currentShadow[1] = currentShadow[1] / dx.scale / treeScale.x;\n        currentShadow[2] = currentShadow[2] / dy.scale / treeScale.y;\n        var averageXYScale = mix(dx.scale, dy.scale, 0.5);\n        var averageTreeXTScale = mix(treeScale.x, treeScale.y, 0.5);\n        currentShadow[3] = currentShadow[3] / averageXYScale / averageTreeXTScale; // blur\n\n        currentShadow[4] = currentShadow[4] / averageXYScale / averageTreeXTScale; // spread\n\n        boxShadow.set(shadowTemplate(currentShadow));\n      };\n    }\n  },\n  color: {},\n  opacity: {\n    read: function (opacity) {\n      return opacity !== null ? parseFloat(opacity) : 0;\n    }\n  }\n};\n\nfunction getAnimatableShadow(shadow, fallback) {\n  if (shadow === \"none\") {\n    shadow = complex.getAnimatableNone(fallback);\n  }\n\n  return complex.parse(shadow);\n}\n\nfunction isEmptyBoxShadow(shadow) {\n  return !shadow || shadow === \"none\";\n}\n\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function () {\n      lock = null;\n    };\n\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n\n    return false;\n  };\n}\n\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\n\nfunction getGlobalLock(drag) {\n  var lock = false;\n\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function () {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n\n  return lock;\n}\n\nvar isViewportScrollBlocked = false;\nvar isBrowser = typeof window !== \"undefined\";\n\nif (isBrowser) {\n  document.addEventListener(\"touchmove\", function (event) {\n    if (isViewportScrollBlocked) {\n      event.preventDefault();\n    }\n  }, {\n    passive: false\n  });\n}\n\nvar blockViewportScroll = function () {\n  return isViewportScrollBlocked = true;\n};\n\nvar unblockViewportScroll = function () {\n  return isViewportScrollBlocked = false;\n};\n\nfunction addDomEvent(target, eventName, handler, options) {\n  if (!handler) return;\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\n\n\nfunction useDomEvent(ref, eventName, handler, options) {\n  useEffect(function () {\n    var element = ref.current;\n\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n\n  return event instanceof MouseEvent;\n}\n\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\n\n\nfunction filterPrimaryPointer(eventHandler) {\n  if (!eventHandler) return undefined;\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\n\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\n\nfunction pointFromTouch(e) {\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n\n  var _a = primaryTouch || defaultPagePoint,\n      pageX = _a.pageX,\n      pageY = _a.pageY;\n\n  return {\n    x: pageX,\n    y: pageY\n  };\n}\n\nfunction pointFromMouse(_a) {\n  var _b = _a.pageX,\n      pageX = _b === void 0 ? 0 : _b,\n      _c = _a.pageY,\n      pageY = _c === void 0 ? 0 : _c;\n  return {\n    x: pageX,\n    y: pageY\n  };\n}\n\nfunction extractEventInfo(event) {\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event) : pointFromMouse(event)\n  };\n}\n\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n\n  if (!handler) return;\n\n  var listener = function (event) {\n    return handler(event, extractEventInfo(event));\n  };\n\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\nvar isBrowser$1 = typeof window !== \"undefined\"; // We check for event support via functions in case they've been mocked by a testing suite.\n\nvar supportsPointerEvents = function () {\n  return isBrowser$1 && window.onpointerdown === null;\n};\n\nvar supportsTouchEvents = function () {\n  return isBrowser$1 && window.ontouchstart === null;\n};\n\nvar supportsMouseEvents = function () {\n  return isBrowser$1 && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\n\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n\n  return name;\n}\n\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n/** @public */\n\n\nvar Point;\n\n(function (Point) {\n  /** @beta */\n  Point.subtract = function (a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  };\n  /** @beta */\n\n\n  Point.relativeTo = function (idOrElem) {\n    var elem;\n\n    var getElem = function () {\n      // Caching element here could be leaky because of React lifecycle\n      if (elem !== undefined) return elem;\n\n      if (typeof idOrElem === \"string\") {\n        elem = document.getElementById(idOrElem);\n      } else {\n        elem = idOrElem;\n      }\n\n      return elem;\n    };\n\n    return function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var localElem = getElem();\n      if (!localElem) return undefined;\n      var rect = localElem.getBoundingClientRect();\n      return {\n        x: x - rect.left - window.scrollX,\n        y: y - rect.top - window.scrollY\n      };\n    };\n  };\n})(Point || (Point = {}));\n/**\n * @internal\n */\n\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n    /**\n     * @internal\n     */\n\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = getFrameData().timestamp;\n\n      _this.history.push(__assign(__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) {\n      return _this.handlePointerMove(event, info);\n    });\n    var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return _this.handlePointerUp(event, info);\n    });\n\n    this.removeListeners = function () {\n      removeOnPointerMove && removeOnPointerMove();\n      removeOnPointerUp && removeOnPointerUp();\n    };\n  }\n\n  PanSession.prototype.handlePointerMove = function (event, info) {\n    this.lastMoveEvent = event;\n    this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.handlePointerUp(event, info);\n      return;\n    } // Throttle mouse move event to once per frame\n\n\n    sync.update(this.updatePoint, true);\n  };\n\n  PanSession.prototype.handlePointerUp = function (event, info) {\n    this.end();\n    var onEnd = this.handlers.onEnd;\n    if (!onEnd) return;\n    var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n    onEnd && onEnd(event, panInfo);\n  };\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n    unblockViewportScroll();\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: Point.subtract(point, lastDevicePoint(history)),\n    offset: Point.subtract(point, startDevicePoint(history)),\n    velocity: getVelocity$1(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity$1(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nvar elementDragControls = new WeakMap();\n\nvar VisualElementDragControls =\n/** @class */\nfunction () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement,\n        controls = _a.controls;\n    /**\n     * Track whether we're currently dragging.\n     *\n     * @internal\n     */\n\n    this.isDragging = false;\n    /**\n     * The current direction of drag, or `null` if both.\n     *\n     * @internal\n     */\n\n    this.currentDirection = null;\n    /**\n     * The permitted boundaries of travel, in pixels.\n     *\n     * @internal\n     */\n\n    this.constraints = false;\n    /**\n     * A reference to the host component's latest props.\n     *\n     * @internal\n     */\n\n    this.props = {};\n    /**\n     * References to the MotionValues used for tracking the current dragged point.\n     *\n     * @internal\n     */\n\n    this.point = {};\n    /**\n     * The origin point for the current drag gesture.\n     *\n     * @internal\n     */\n\n    this.origin = {\n      x: motionValue(0),\n      y: motionValue(0)\n    }; // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n\n    this.openGlobalLock = null;\n    /**\n     * @internal\n     */\n\n    this.panSession = null;\n    this.prev = {\n      x: 0,\n      y: 0\n    };\n    this.visualElement = visualElement;\n    this.controls = controls;\n    elementDragControls.set(visualElement, this);\n  }\n  /**\n   * Start dragging the host component.\n   *\n   * @param event - The originating pointer event.\n   * @param options -\n   *\n   * @public\n   */\n\n\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n\n    var _b = (_a === void 0 ? {} : _a).snapToCursor,\n        snapToCursor = _b === void 0 ? false : _b;\n    snapToCursor && this.snapToCursor(originEvent);\n\n    var onSessionStart = function () {\n      // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\n      // which has come out of the difficulty in us being able to do this once a scroll gesture\n      // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\n      // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\n      // trigger this once we've got a scroll direction determined. This approach sort-of worked\n      // but if the component was dragged too far in a single frame page scrolling would initiate.\n      blockViewportScroll(); // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n\n      _this.stopMotion();\n    };\n\n    var onStart = function (event, info) {\n      // If constraints are an element, resolve them again in case they've updated.\n      _this.resolveDragConstraints(); // Set point origin and stop any existing animations.\n\n\n      bothAxis(function (axis) {\n        var axisPoint = _this.point[axis];\n        if (!axisPoint) return;\n\n        _this.origin[axis].set(axisPoint.get());\n      }); // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n\n      var _a = _this.props,\n          drag = _a.drag,\n          dragPropagation = _a.dragPropagation;\n\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag);\n        if (!_this.openGlobalLock) return;\n      }\n\n      _this.isDragging = true;\n      _this.currentDirection = null;\n      var onDragStart = _this.props.onDragStart;\n      onDragStart && onDragStart(event, convertPanToDrag(info, _this.point));\n    };\n\n    var onMove = function (event, info) {\n      var _a = _this.props,\n          dragPropagation = _a.dragPropagation,\n          dragDirectionLock = _a.dragDirectionLock; // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (_this.currentDirection !== null) {\n          var onDirectionLock = _this.props.onDirectionLock;\n          onDirectionLock && onDirectionLock(_this.currentDirection);\n        }\n\n        return;\n      }\n\n      _this.updatePoint(\"x\", offset);\n\n      _this.updatePoint(\"y\", offset);\n\n      var onDrag = _this.props.onDrag;\n      onDrag && onDrag(event, convertPanToDrag(info, _this.point));\n    };\n\n    var onEnd = function (event, info) {\n      _this.stop(event, info);\n    };\n\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onEnd: onEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    if (!this.constraintsNeedResolution) return;\n    var _a = this.props,\n        dragConstraints = _a.dragConstraints,\n        onMeasureDragConstraints = _a.onMeasureDragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = dragConstraints.current;\n    this.constraints = calculateConstraintsFromDom(constraintsElement, this.visualElement.getInstance(), this.point, transformPagePoint);\n\n    if (onMeasureDragConstraints) {\n      var constraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(this.constraints));\n      if (constraints) this.constraints = convertBoundingBoxToAxisBox(constraints);\n    }\n\n    this.applyConstraintsToPoint();\n  };\n\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    unblockViewportScroll();\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n  };\n\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a;\n\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var _b = this.props,\n        dragMomentum = _b.dragMomentum,\n        dragElastic = _b.dragElastic,\n        onDragEnd = _b.onDragEnd;\n\n    if (dragMomentum || dragElastic) {\n      var velocity = info.velocity;\n      this.animateDragEnd(velocity);\n    } else {\n      this.recordBoxInfo(this.constraints);\n    }\n\n    onDragEnd && onDragEnd(event, convertPanToDrag(info, this.point));\n  };\n\n  VisualElementDragControls.prototype.recordBoxInfo = function (constraints) {\n    if (constraints) this.prevConstraints = constraints;\n    if (this.point.x) this.prev.x = this.point.x.get();\n    if (this.point.y) this.prev.y = this.point.y.get();\n  };\n\n  VisualElementDragControls.prototype.snapToCursor = function (event) {\n    var _this = this;\n\n    var transformPagePoint = this.props.transformPagePoint;\n    var point = extractEventInfo(event).point;\n    var boundingBox = getBoundingBox(this.visualElement.getInstance(), transformPagePoint);\n    var center = {\n      x: calcAxisCenter(boundingBox.x) + window.scrollX,\n      y: calcAxisCenter(boundingBox.y) + window.scrollY\n    };\n    var offset = {\n      x: point.x - center.x,\n      y: point.y - center.y\n    };\n    bothAxis(function (axis) {\n      var axisPoint = _this.point[axis];\n      if (!axisPoint) return;\n\n      _this.origin[axis].set(axisPoint.get());\n    });\n    this.updatePoint(\"x\", offset);\n    this.updatePoint(\"y\", offset);\n  };\n\n  VisualElementDragControls.prototype.setPoint = function (axis, value) {\n    this.point[axis] = value;\n  };\n\n  VisualElementDragControls.prototype.updatePoint = function (axis, offset) {\n    var _a = this.props,\n        drag = _a.drag,\n        dragElastic = _a.dragElastic;\n    var axisPoint = this.point[axis]; // If we're not dragging this axis, do an early return.\n\n    if (!shouldDrag(axis, drag, this.currentDirection) || !axisPoint) return;\n    var current = applyConstraints(axis, this.origin[axis].get() + offset[axis], this.constraints, dragElastic);\n    axisPoint.set(current);\n  };\n\n  VisualElementDragControls.prototype.updateProps = function (_a) {\n    var _this = this;\n\n    var _b = _a.drag,\n        drag = _b === void 0 ? false : _b,\n        _c = _a.dragDirectionLock,\n        dragDirectionLock = _c === void 0 ? false : _c,\n        _d = _a.dragPropagation,\n        dragPropagation = _d === void 0 ? false : _d,\n        _e = _a.dragConstraints,\n        dragConstraints = _e === void 0 ? false : _e,\n        _f = _a.dragElastic,\n        dragElastic = _f === void 0 ? true : _f,\n        _g = _a.dragMomentum,\n        dragMomentum = _g === void 0 ? true : _g,\n        remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n\n    this.props = __assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n    var _dragValueX = remainingProps._dragValueX,\n        _dragValueY = remainingProps._dragValueY,\n        dragOriginX = remainingProps.dragOriginX,\n        dragOriginY = remainingProps.dragOriginY;\n    if (dragOriginX) this.origin.x = dragOriginX;\n    if (dragOriginY) this.origin.y = dragOriginY; // Get the `MotionValue` for both draggable axes, or create them if they don't already\n    // exist on this component.\n\n    bothAxis(function (axis) {\n      if (!shouldDrag(axis, drag, _this.currentDirection)) return;\n      var defaultValue = axis === \"x\" ? _dragValueX : _dragValueY;\n\n      _this.setPoint(axis, defaultValue || _this.visualElement.getValue(axis, 0));\n    }); // If `dragConstraints` is a React `ref`, we should resolve the constraints once the\n    // component has rendered.\n\n    this.constraintsNeedResolution = isRefObject(dragConstraints);\n\n    if (this.constraintsNeedResolution) {\n      this.constraints = this.constraints || false;\n    } else {\n      this.constraints = dragConstraints && dragConstraints !== false ? convertBoundingBoxToAxisBox(dragConstraints) : false;\n    }\n  };\n\n  VisualElementDragControls.prototype.applyConstraintsToPoint = function () {\n    var _this = this;\n\n    return bothAxis(function (axis) {\n      var axisPoint = _this.point[axis];\n      axisPoint && !axisPoint.isAnimating() && applyConstraints(axis, axisPoint, _this.constraints, 0);\n    });\n  };\n\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragMomentum = _a.dragMomentum,\n        dragElastic = _a.dragElastic,\n        dragTransition = _a.dragTransition,\n        _dragValueX = _a._dragValueX,\n        _dragValueY = _a._dragValueY,\n        _dragTransitionControls = _a._dragTransitionControls;\n    var momentumAnimations = bothAxis(function (axis) {\n      var _a;\n\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n\n      var transition = _this.constraints ? _this.constraints[axis] : {};\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n      var animationControls = _dragTransitionControls || _this.controls;\n\n      var inertia = __assign(__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1\n      }, dragTransition), transition);\n\n      var externalAxisMotionValue = axis === \"x\" ? _dragValueX : _dragValueY; // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n      return externalAxisMotionValue ? startAnimation(axis, externalAxisMotionValue, 0, inertia) : animationControls.start((_a = {}, _a[axis] = 0, _a.transition = inertia, _a));\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(function () {\n      _this.recordBoxInfo(_this.constraints);\n\n      _this.scalePoint();\n\n      var onDragTransitionEnd = _this.props.onDragTransitionEnd;\n      onDragTransitionEnd && onDragTransitionEnd();\n    });\n  };\n\n  VisualElementDragControls.prototype.stopMotion = function () {\n    var _this = this;\n\n    bothAxis(function (axis) {\n      var axisPoint = _this.point[axis];\n      axisPoint && axisPoint.stop();\n    });\n  };\n\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n\n    var _a = this.props,\n        dragConstraints = _a.dragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    if (!isRefObject(dragConstraints)) return;\n    var constraintsBox = getBoundingBox(dragConstraints.current, transformPagePoint);\n    var draggableBox = getBoundingBox(this.visualElement.getInstance(), transformPagePoint); // Scale a point relative to the transformation of a constraints-providing element.\n\n    var scaleAxisPoint = function (axis) {\n      var pointToScale = _this.point[axis];\n      if (!pointToScale) return; // Stop any current animations as they bug out if you resize during one\n\n      if (pointToScale.isAnimating()) {\n        pointToScale.stop();\n\n        _this.recordBoxInfo();\n\n        return;\n      } // If the previous dimension was `0` (default), set `scale` to `1` to prevent\n      // divide by zero errors.\n\n\n      var _a = _this.prevConstraints[axis],\n          min = _a.min,\n          max = _a.max;\n      var width = max - min;\n      var constraintsWidth = constraintsBox[axis].max - constraintsBox[axis].min;\n      var draggableWidth = draggableBox[axis].max - draggableBox[axis].min;\n      var scale = width ? (constraintsWidth - draggableWidth) / width : 1;\n      pointToScale.set(_this.prev[axis] * Math.abs(scale));\n    };\n\n    scaleAxisPoint(\"x\");\n    scaleAxisPoint(\"y\");\n  };\n\n  VisualElementDragControls.prototype.mount = function (element) {\n    var _this = this;\n\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n          drag = _a.drag,\n          _b = _a.dragListener,\n          dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      return _this.scalePoint();\n    });\n\n    if (this.constraintsNeedResolution) {\n      this.resolveDragConstraints();\n      this.recordBoxInfo(this.constraints);\n    } else if (!this.isDragging && this.constraints) {\n      this.applyConstraintsToPoint();\n    }\n\n    return function () {\n      stopPointerListener && stopPointerListener();\n      stopResizeListener && stopResizeListener();\n\n      _this.cancelDrag();\n    };\n  };\n\n  return VisualElementDragControls;\n}(); // Call a handler once for each axis\n\n\nfunction bothAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\nfunction convertPanToDrag(info, point) {\n  return __assign(__assign({}, info), {\n    point: {\n      x: point.x ? point.x.get() : 0,\n      y: point.y ? point.y.get() : 0\n    }\n  });\n}\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\n\n\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n\n  var direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n/**\n * Takes a parent Element and a draggable Element and returns pixel-based drag constraints.\n *\n * @param constraintsRef\n * @param draggableRef\n */\n\n\nfunction calculateConstraintsFromDom(constraintsElement, draggableElement, _point, // TODO: Remove this argument if we keep transform reset\ntransformPagePoint) {\n  invariant(constraintsElement !== null && draggableElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n  var parentBoundingBox = getBoundingBox(constraintsElement, transformPagePoint);\n  var draggableTransform = draggableElement.style.transform;\n  draggableElement.style.transform = \"none\";\n  var draggableBoundingBox = getBoundingBox(draggableElement, transformPagePoint);\n  draggableElement.style.transform = draggableTransform;\n  return calculateConstraints(parentBoundingBox, draggableBoundingBox);\n}\n\nfunction calculateAxisConstraints(parentAxis, draggableAxis) {\n  var _a;\n\n  var min = parentAxis.min - draggableAxis.min;\n  var max = parentAxis.max - draggableAxis.max; // If the parent axis is actually smaller than the draggable axis then we can\n  // flip the constraints\n\n  if (parentAxis.max - parentAxis.min < draggableAxis.max - draggableAxis.min) {\n    _a = [max, min], min = _a[0], max = _a[1];\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction calculateConstraints(parentBox, draggableBox) {\n  return {\n    x: calculateAxisConstraints(parentBox.x, draggableBox.x),\n    y: calculateAxisConstraints(parentBox.y, draggableBox.y)\n  };\n}\n\nfunction getBoundingBox(element, transformPagePoint) {\n  var rect = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(rect, transformPagePoint));\n} // function getCurrentOffset(point?: MotionValue<number>) {\n//     return point ? point.get() : 0\n// }\n\n\nfunction applyConstraints(axis, value, constraints, dragElastic) {\n  var constrainedValue = value instanceof MotionValue ? value.get() : value;\n\n  if (!constraints) {\n    return constrainedValue;\n  }\n\n  var _a = constraints[axis],\n      min = _a.min,\n      max = _a.max;\n\n  if (min !== undefined && constrainedValue < min) {\n    constrainedValue = dragElastic ? applyOverdrag(min, constrainedValue, dragElastic) : Math.max(min, constrainedValue);\n  } else if (max !== undefined && constrainedValue > max) {\n    constrainedValue = dragElastic ? applyOverdrag(max, constrainedValue, dragElastic) : Math.min(max, constrainedValue);\n  }\n\n  if (value instanceof MotionValue) {\n    value.set(constrainedValue);\n  }\n\n  return constrainedValue;\n}\n\nfunction applyOverdrag(origin, current, dragElastic) {\n  var dragFactor = typeof dragElastic === \"number\" ? dragElastic : 0.35;\n  return mix(origin, current, dragFactor);\n}\n/**\n * Magic Motion relies on multiple components and class components only support, hence this\n * wrapper component that provides those contexts as props.\n */\n\n\nvar SharedLayoutContextProvider = function (props) {\n  var _a = usePresence(),\n      isPresent = _a[0],\n      safeToRemove = _a[1];\n\n  var sharedLayoutContext = useContext(SharedLayoutContext);\n  var autoValues = useContext(MotionPluginContext).autoValues;\n  return createElement(Auto // We allow isPresent to be overwritten by manually setting it to true/false\n  // This is only intended for optimisations in Framer\n  , __assign({\n    // We allow isPresent to be overwritten by manually setting it to true/false\n    // This is only intended for optimisations in Framer\n    isPresent: isPresent\n  }, props, {\n    safeToRemove: safeToRemove,\n    sharedLayoutContext: sharedLayoutContext,\n    autoValues: autoValues\n  }));\n};\n\nvar Auto =\n/** @class */\nfunction (_super) {\n  __extends(Auto, _super);\n\n  function Auto(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * If this component is a child of both AnimateSharedLayout and AnimatePresence we need to know if\n     * it's safe to remove. This logic usually runs when AnimateSharedLayout triggers this component's\n     * startAnimation method. But if this component renders apart from AnimateSharedLayout, it needs to know\n     * that it didn't run this method and in the event that it's leaving the tree, can safely call `safeToRemove`.\n     */\n\n\n    _this.willAnimate = false;\n    /**\n     * We use this value to track whether, on a given render, this component should animate. This is\n     * decided in shouldComponentUpdate, but the logic governing both is different.\n     */\n\n    _this.shouldAnimate = true;\n    /**\n     * The `measuredOrigin` layout as corrected for all the transforms being applied up the\n     * auto-animate tree. We use this as the final bounding box from which we calculate a transform\n     * delta to our desired visual position on any given frame.\n     *\n     * This is mutable to avoid object creation on each frame.\n     */\n\n    _this.correctedLayout = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    /**\n     * The visual target we want to project our component into on a given frame.\n     *\n     * This is mutable to avoid object creation on each frame.\n     */\n\n    _this.frameTarget = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    /**\n     * A flag to check whether this component has ever animated rotate. We use this to force\n     * originX/Y to 0.5\n     */\n\n    _this.hasAnimatedRotate = false;\n    /**\n     * The overall scale of the local coordinate system as transformed by all parents of this component. We use this\n     * for scale correction on our calculated layouts and scale-affected values like `boxShadow`.\n     *\n     * This is mutable to avoid object creation on each frame.\n     */\n\n    _this.treeScale = {\n      x: 1,\n      y: 1\n    };\n    /**\n     * The current, pre-correction values of every scale-corrected value. We keep a record of these throughout\n     * an animation so if the animation is interrupted we can resume from this value instead of a scale-corrected\n     * value that may have no relevance in the next treeScale context.\n     */\n\n    _this.current = {\n      rotate: 0\n    }; // TODO: Can we move these back here somehow\n\n    _this.delta = props.localContext.layoutDelta;\n    _this.depth = props.localContext.layoutDepth;\n    _this.progress = props.localContext.layoutProgress;\n    _this.shouldAnimate = props._shouldAnimate !== undefined ? props._shouldAnimate : _this.shouldAnimate;\n    var autoValues = props.autoValues;\n    _this.supportedAutoValues = __assign(__assign({}, defaultMagicValues), autoValues);\n    _this.animatableStyles = getAnimatableValues(_this.supportedAutoValues);\n    return _this;\n  }\n\n  Auto.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var sharedLayoutContext = this.props.sharedLayoutContext;\n\n    if (isSharedLayoutTree(sharedLayoutContext)) {\n      this.unregisterSharedLayoutContext = sharedLayoutContext.register(this); // Check if this render was handled by AnimateSharedLayout. If it was,\n      // the usual logic in startAnimation to tell AnimatePresence that this component is safe to remove\n      // will have run. If it wasn't, we have to do that here.\n\n      this.componentDidUpdate = function (prevProps) {\n        var _a = _this.props,\n            layoutId = _a.layoutId,\n            layoutOrder = _a.layoutOrder;\n\n        if (layoutId !== prevProps.layoutId) {\n          _this.unregisterSharedLayoutContext && _this.unregisterSharedLayoutContext();\n          _this.unregisterSharedLayoutContext = sharedLayoutContext.register(_this);\n        } else if (layoutOrder !== undefined && layoutOrder !== prevProps.layoutOrder) {\n          sharedLayoutContext.move(_this);\n\n          _this.resetStyles();\n        }\n\n        if (!_this.willAnimate) _this.safeToRemove();\n        _this.willAnimate = false;\n      };\n    } else {\n      /**\n       * If we're not a child of AnimateSharedLayout we can use some default batching that will\n       * ensure all auto-animation read/write cycles are batched across components. This\n       * reduces layout thrashing and ensures all measurements are correct. Currently, because componentDidUpdate\n       * fires before new component componentDidMount, newly entering components are missed out and need\n       * AnimateSharedLayout to work correctly.\n       */\n      this.getSnapshotBeforeUpdate = function () {\n        _this.snapshotOrigin();\n\n        sharedLayoutContext.add(_this);\n        return null;\n      };\n\n      this.componentDidUpdate = function () {\n        return sharedLayoutContext.flush();\n      };\n    }\n  };\n\n  Auto.prototype.componentWillUnmount = function () {\n    this.unregisterSharedLayoutContext && this.unregisterSharedLayoutContext();\n    this.stopLayoutAnimation && this.stopLayoutAnimation();\n  };\n\n  Auto.prototype.shouldComponentUpdate = function (nextProps) {\n    if (this.props._shouldAnimate !== undefined) {\n      this.shouldAnimate = this.props._shouldAnimate;\n      return true;\n    }\n\n    var hasDependency = this.props.magicDependency !== undefined || nextProps.magicDependency !== undefined;\n    var dependencyHasChanged = this.props.magicDependency !== nextProps.magicDependency;\n    var presenceHasChanged = this.props.isPresent !== nextProps.isPresent;\n    this.shouldAnimate = !hasDependency || hasDependency && dependencyHasChanged || presenceHasChanged;\n    return true;\n  };\n  /**\n   * Reset the component's rotation so we can accurately measure its bounding box. If it's rotated\n   * when we snapshot, the bounding box will be reported as larger than the component's actual size.\n   *\n   * This is currently only available inside of Framer by setting supportRotate on AnimateSharedLayout.\n   * It incurs an extra read/write cycle triggered on shouldComponentUpdate which, in concurrent mode,\n   * might trigger more than once per render. So it isn't recommended for production.\n   */\n\n\n  Auto.prototype.resetRotation = function () {\n    var visualElement = this.props.visualElement;\n    var rotate = visualElement.getValue(\"rotate\");\n    this.current.rotate = rotate ? rotate.get() : 0;\n    if (!this.current.rotate) return;\n    visualElement.setStaticValues(\"rotate\", 0);\n    visualElement.render();\n  };\n  /**\n   * Reset styles that we might be currently animating so we can read their target values from the DOM.\n   */\n\n\n  Auto.prototype.resetStyles = function () {\n    var _a = this.props,\n        animate = _a.animate,\n        visualElement = _a.visualElement,\n        _b = _a.style,\n        style = _b === void 0 ? {} : _b;\n    var reset = resetStyles(style, this.supportedAutoValues); // If we're animating opacity separately, we don't want to reset\n    // as it causes a visual flicker when adding the component\n    // TODO: We should do this universally for all animating props\n    // and account for variants too.\n\n    if (typeof animate === \"object\" && animate.hasOwnProperty(\"opacity\")) {\n      delete reset.opacity;\n    }\n\n    visualElement.setStaticValues(reset);\n    visualElement.render();\n  };\n  /**\n   * Take a snapshot of the component as it currently exists before a render.\n   */\n\n\n  Auto.prototype.snapshotOrigin = function () {\n    this.willAnimate = true;\n    var visualElement = this.props.visualElement;\n    var origin = snapshot(visualElement, this.supportedAutoValues);\n    applyCurrent(origin.style, this.current);\n    return this.measuredOrigin = origin;\n  };\n  /**\n   * Take a snapshot of a component as it will exist after a render.\n   */\n\n\n  Auto.prototype.snapshotTarget = function () {\n    var _a = this.props,\n        visualElement = _a.visualElement,\n        style = _a.style;\n    var target = snapshot(visualElement, this.supportedAutoValues);\n    target.style.rotate = resolve(0, style && style.rotate);\n    this.measuredTarget = target;\n  };\n\n  Auto.prototype.popFromFlow = function () {\n    var visualElement = this.props.visualElement;\n    var position = this.measuredTarget.style.position;\n    if (position === \"absolute\" || position === \"fixed\") return;\n    var _a = this.measuredTarget.layout,\n        x = _a.x,\n        y = _a.y;\n    visualElement.setStaticValues({\n      position: \"absolute\",\n      width: x.max - x.min,\n      height: y.max - y.min\n    });\n    visualElement.render();\n  };\n  /**\n   * Hide this component using opacity. We can't set it to display: none as we might\n   * still need to measure it or its children.\n   *\n   * This is triggered if the component is a child of AnimateSharedLayout and a new component\n   * enters the tree that shares this component's layoutId.\n   */\n\n\n  Auto.prototype.hide = function () {\n    this.delta.isVisible = false;\n    this.stopLayoutAnimation && this.stopLayoutAnimation();\n    var visualElement = this.props.visualElement;\n    var opacity = visualElement.getValue(\"opacity\", 0);\n    opacity.set(0);\n    visualElement.render();\n    if (!this.isPresent()) this.safeToRemove();\n  };\n\n  Auto.prototype.show = function () {\n    this.delta.isVisible = true;\n    var _a = this.props,\n        visualElement = _a.visualElement,\n        style = _a.style;\n    var opacity = visualElement.getValue(\"opacity\", 1);\n    var newOpacity = style ? resolve(1, style.opacity) : 1;\n    opacity.set(newOpacity);\n  };\n\n  Auto.prototype.setVisibility = function (visibilityAction) {\n    if (visibilityAction === VisibilityAction.Show) {\n      this.show();\n    } else {\n      this.hide();\n    }\n\n    return this.safeToRemove();\n  };\n  /**\n   * Start an auto or shared layout animation.\n   */\n\n\n  Auto.prototype.startAnimation = function (_a) {\n    var _this = this;\n\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var _b, _c;\n\n    var origin = _a.origin,\n        target = _a.target,\n        visibilityAction = _a.visibilityAction,\n        opts = __rest(_a, [\"origin\", \"target\", \"visibilityAction\"]);\n\n    if (visibilityAction !== undefined) {\n      return this.setVisibility(visibilityAction);\n    }\n\n    var animationPromise;\n    var animations = []; // Restore rotation before any writes. If we don't do this, and for whatever\n    // reason the animation doesn't execute, rotation will be left at 0\n\n    var visualElement = this.props.visualElement;\n    var rotate = visualElement.getValue(\"rotate\");\n    rotate && visualElement.setStaticValues(\"rotate\", rotate.get());\n    this.visualTarget = target || this.measuredTarget; // If we don't have a provided or measured origin, for instance if this is a newly-added component,\n    // we can just take the target and use that to at least maintain its position on screen as parent\n    // components animate\n\n    this.visualOrigin = origin || this.measuredOrigin || this.visualTarget;\n    this.delta.isVisible = ((_b = this.visualOrigin) === null || _b === void 0 ? void 0 : _b.style.opacity) !== 0 || ((_c = this.visualTarget) === null || _c === void 0 ? void 0 : _c.style.opacity) !== 0;\n    var parentContext = this.props.parentContext;\n    var parentDeltas = parentContext.layoutDeltas || [];\n    this.shouldAnimate = opts.shouldAnimate !== undefined ? opts.shouldAnimate : this.shouldAnimate;\n\n    if (this.shouldAnimate && this.visualOrigin && this.visualTarget && this.measuredTarget && this.delta.isVisible && isTreeVisible(parentDeltas)) {\n      syncRenderSession.open();\n      animations = [this.startLayoutAnimation(opts), this.startStyleAnimation(opts)].filter(Boolean);\n      animationPromise = Promise.all(animations).then(function () {\n        var onMagicComplete = _this.props.onMagicComplete;\n        onMagicComplete && onMagicComplete();\n      });\n      syncRenderSession.flush();\n    } // If we don't animate, make sure we call safeToRemove so if this is an\n    // exiting component it'll get removed\n\n\n    !animations.length && this.safeToRemove(); // Force render to ensure there's no flashes of unstyled content from the reset\n\n    visualElement.render();\n    return animationPromise;\n  };\n  /**\n   * This uses the FLIP animation technique to animate physical dimensions\n   * and correct distortion on related styles (ie borderRadius etc)\n   */\n\n\n  Auto.prototype.startLayoutAnimation = function (opts) {\n    var _this = this;\n\n    var animation;\n    this.stopLayoutAnimation && this.stopLayoutAnimation();\n    var originStyle = this.visualOrigin.style;\n    var targetStyle = this.visualTarget.style;\n    var isAnimatingRotate = Boolean(originStyle.rotate || targetStyle.rotate); // We really want to know if its ever animated rotate and the above isn't good enough\n\n    if (isAnimatingRotate) this.hasAnimatedRotate = isAnimatingRotate;\n    var visualElement = this.props.visualElement;\n    var updaters = {};\n\n    for (var key in this.supportedAutoValues) {\n      var handler = this.supportedAutoValues[key];\n      if (!handler.createUpdater) continue;\n      updaters[key] = handler.createUpdater(visualElement, originStyle[key], targetStyle[key], this.current, this.delta, this.treeScale, this.visualOrigin.layout, this.visualTarget.layout);\n    }\n\n    this.frameTarget = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    var x = visualElement.getValue(\"x\", 0);\n    var y = visualElement.getValue(\"y\", 0);\n    var scaleX = visualElement.getValue(\"scaleX\", 1);\n    var scaleY = visualElement.getValue(\"scaleY\", 1);\n    var rotate = visualElement.getValue(\"rotate\", 0); // TODO: Make API for this, stop all values. Currently just doing this to stop drag inertia animations\n\n    x.stop();\n    y.stop();\n    var opacity = visualElement.getValue(\"opacity\", originStyle.opacity);\n\n    var frame = function () {\n      // TODO: Break up each of these so we can animate separately\n      var p = _this.progress.get() / 1000;\n\n      _this.updateBoundingBox(p, _this.hasAnimatedRotate ? 0.5 : undefined);\n\n      _this.updateTransform(x, y, scaleX, scaleY);\n\n      _this.hasAnimatedRotate && _this.updateRotate(p, rotate);\n\n      for (var key in updaters) {\n        var updater = updaters[key];\n        updater && updater(p);\n      }\n\n      if (opts.crossfade) {\n        opacity.set(opts.crossfade(originStyle.opacity, targetStyle.opacity, p));\n      }\n    };\n\n    var progressOrigin = 0;\n    var progressTarget = 1000;\n    this.progress.set(progressOrigin);\n    this.progress.set(progressOrigin); // Set twice to hard-reset velocity\n\n    var _a = this.props,\n        transition = _a.transition,\n        animate = _a.animate;\n\n    if (animate !== false) {\n      var dragControls = elementDragControls.get(visualElement);\n\n      if (!dragControls || !dragControls.isDragging) {\n        animation = startAnimation(\"progress\", this.progress, progressTarget, __assign(__assign({}, opts.transition || transition), {\n          restDelta: 1,\n          restSpeed: 10\n        })).then(function () {\n          return _this.safeToRemove();\n        });\n      } else {\n        this.updateBoundingBox(progressOrigin); // Reset drag origin so the element doesn't look like it's moved in the DOM\n        // TODO: This is currently lossy with big mouse movements\n\n        var _b = dragControls.origin,\n            dragOriginX = _b.x,\n            dragOriginY = _b.y;\n        dragOriginX.set(dragOriginX.get() + this.delta.x.translate - x.get());\n        dragOriginY.set(dragOriginY.get() + this.delta.y.translate - y.get());\n        this.safeToRemove();\n      }\n    } else {\n      this.safeToRemove();\n    }\n\n    var parentContext = this.props.parentContext;\n    var layoutProgress = parentContext.layoutProgress;\n\n    var scheduleUpdate = function () {\n      return sync.update(frame, false, true);\n    };\n\n    var unsubscribeProgress = this.progress.onChange(scheduleUpdate);\n    var unsubscribeParentProgress;\n\n    if (layoutProgress) {\n      unsubscribeParentProgress = layoutProgress.onChange(scheduleUpdate);\n    }\n\n    this.stopLayoutAnimation = function () {\n      cancelSync.update(frame);\n\n      _this.progress.stop();\n\n      unsubscribeProgress();\n      unsubscribeParentProgress && unsubscribeParentProgress();\n    }; // TODO: I would prefer this to be a scheduleUpdate call, for some reason this is breaking\n    // visualOrigin in the sharedLayoutFramerSetup demonstration\n\n\n    frame();\n    return animation;\n  };\n  /**\n   * This is a straight animation between prev/next styles. This animates\n   * styles that don't need scale inversion correction.\n   */\n\n\n  Auto.prototype.startStyleAnimation = function (opts) {\n    var _a;\n\n    var shouldAnimateStyle = false;\n    var target = {};\n    var visualElement = this.props.visualElement;\n    var numAnimatableStyles = this.animatableStyles.length;\n\n    for (var i = 0; i < numAnimatableStyles; i++) {\n      var key = this.animatableStyles[i];\n      if (key === \"opacity\" && opts.crossfade) continue;\n      var originStyle = this.visualOrigin.style[key];\n      var targetStyle = this.visualTarget.style[key];\n      /**\n       * If backgroundColor has been read as `rgba(0 0 0 0)` it's mostly likely got a fully\n       * transparent background. If we animate to/from this color, we'll animate to/from transparent\n       * black rather than the transparent origin/target colour.\n       */\n\n      if (key === \"backgroundColor\") {\n        _a = fixTransparentRGBPair(originStyle, targetStyle), originStyle = _a[0], targetStyle = _a[1];\n      }\n\n      if (originStyle !== targetStyle) {\n        shouldAnimateStyle = true;\n        var value = visualElement.getValue(key, originStyle);\n        value.set(originStyle);\n        target[key] = targetStyle;\n      }\n    }\n\n    var _b = this.props,\n        transition = _b.transition,\n        controls = _b.controls;\n    target.transition = opts.transition || transition || {};\n\n    if (shouldAnimateStyle) {\n      return controls.start(target);\n    }\n  };\n\n  Auto.prototype.updateBoundingBox = function (p, origin) {\n    var parentContext = this.props.parentContext;\n    var parentDeltas = parentContext.layoutDeltas || [];\n    resetBox(this.correctedLayout, this.measuredTarget.layout);\n    applyTreeDeltas(this.correctedLayout, this.treeScale, parentDeltas);\n    tweenAxisBox(this.frameTarget, this.visualOrigin.layout, this.visualTarget.layout, p);\n    calcBoxDelta(this.delta, this.frameTarget, this.correctedLayout, origin);\n  };\n\n  Auto.prototype.updateTransform = function (x, y, scaleX, scaleY) {\n    var visualElement = this.props.visualElement;\n    var dx = this.delta.x;\n    var dy = this.delta.y;\n    visualElement.setStaticValues(\"originX\", dx.origin);\n    visualElement.setStaticValues(\"originY\", dy.origin);\n    x.set(dx.translate / this.treeScale.x);\n    y.set(dy.translate / this.treeScale.y);\n    scaleX.set(dx.scale);\n    scaleY.set(dy.scale);\n  };\n\n  Auto.prototype.updateRotate = function (p, rotate) {\n    var target = mix(this.visualOrigin.style.rotate, this.visualTarget.style.rotate, p);\n    rotate.set(target);\n  };\n\n  Auto.prototype.isPresent = function () {\n    return this.props.isPresent;\n  };\n\n  Auto.prototype.safeToRemove = function () {\n    var safeToRemove = this.props.safeToRemove;\n    safeToRemove && safeToRemove();\n  };\n\n  Auto.prototype.render = function () {\n    return null;\n  };\n\n  return Auto;\n}(Component);\n\nvar Auto$1 = {\n  key: \"auto\",\n  shouldRender: function (_a) {\n    var animate = _a.animate,\n        layoutId = _a.layoutId;\n    var hasAutoAnimateProps = typeof animate === \"boolean\" || layoutId !== undefined;\n    return hasAutoAnimateProps && typeof window !== \"undefined\";\n  },\n  Component: SharedLayoutContextProvider\n};\n/**\n * A hook that allows an element to be dragged.\n *\n * @param param\n * @param ref\n * @param values\n * @param controls\n *\n * @internal\n */\n\nfunction useDrag(props, visualElement, controls) {\n  var groupDragControls = props.dragControls;\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement,\n      controls: controls\n    });\n  });\n  dragControls.updateProps(__assign(__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  }));\n  useDisableDragOnExit(dragControls);\n  useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]);\n  useEffect(function () {\n    return dragControls.mount(visualElement.getInstance());\n  }, []);\n}\n\nfunction useDisableDragOnExit(dragControls) {\n  var isPresent = useIsPresent();\n  useEffect(function () {\n    if (!isPresent) dragControls.stopMotion();\n  }, [isPresent]);\n}\n\nvar makeRenderlessComponent = function (hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\n\nvar Drag = {\n  key: \"drag\",\n  shouldRender: function (props) {\n    return !!props.drag || !!props.dragConstraints;\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        controls = _a.controls,\n        props = __rest(_a, [\"visualElement\", \"controls\"]);\n\n    return useDrag(props, visualElement, controls);\n  })\n};\n\nfunction useUnmountEffect(callback) {\n  return useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\n\n\nfunction usePanGesture(_a, ref) {\n  var onPan = _a.onPan,\n      onPanStart = _a.onPanStart,\n      onPanEnd = _a.onPanEnd,\n      onPanSessionStart = _a.onPanSessionStart;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = useRef(null);\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function (event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\n\n\nvar isNodeOrChild = function (parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\n\nvar getGesturePriority = function (gesture) {\n  return order$1.indexOf(gesture) + 1;\n};\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\n/**\n * @param handlers -\n * @internal\n */\n\nfunction useTapGesture(_a, ref) {\n  var onTap = _a.onTap,\n      onTapStart = _a.onTapStart,\n      onTapCancel = _a.onTapCancel,\n      whileTap = _a.whileTap,\n      controls = _a.controls;\n  var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isTapping = useRef(false);\n  var cancelPointerEventListener = useRef(null);\n\n  function removePointerUp() {\n    cancelPointerEventListener.current && cancelPointerEventListener.current();\n    cancelPointerEventListener.current = null;\n  }\n\n  if (whileTap && controls) {\n    controls.setOverride(whileTap, tapGesturePriority);\n  } // We load this event handler into a ref so we can later refer to\n  // onPointerUp.current which will always have reference to the latest props\n\n\n  var onPointerUp = useRef(null);\n\n  onPointerUp.current = function (event, info) {\n    var element = ref.current;\n    removePointerUp();\n    if (!isTapping.current || !element) return;\n    isTapping.current = false;\n\n    if (controls && whileTap) {\n      controls.clearOverride(tapGesturePriority);\n    } // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n\n\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock) return;\n    openGestureLock();\n\n    if (!isNodeOrChild(element, event.target)) {\n      onTapCancel && onTapCancel(event, info);\n    } else {\n      onTap && onTap(event, info);\n    }\n  };\n\n  function onPointerDown(event, info) {\n    removePointerUp();\n    cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return onPointerUp.current(event, info);\n    });\n    var element = ref.current;\n    if (!element || isTapping.current) return;\n    isTapping.current = true;\n    onTapStart && onTapStart(event, info);\n\n    if (controls && whileTap) {\n      controls.startOverride(tapGesturePriority);\n    }\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerUp);\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\n\nvar filterTouch = function (listener) {\n  return function (event, info) {\n    if (isMouseEvent(event)) listener(event, info);\n  };\n};\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\n\n\nfunction useHoverGesture(_a, ref) {\n  var whileHover = _a.whileHover,\n      onHoverStart = _a.onHoverStart,\n      onHoverEnd = _a.onHoverEnd,\n      controls = _a.controls;\n\n  if (whileHover && controls) {\n    controls.setOverride(whileHover, hoverPriority);\n  }\n\n  usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\n    if (onHoverStart) onHoverStart(event, info);\n\n    if (whileHover && controls) {\n      controls.startOverride(hoverPriority);\n    }\n  }));\n  usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\n    if (onHoverEnd) onHoverEnd(event, info);\n\n    if (whileHover && controls) {\n      controls.clearOverride(hoverPriority);\n    }\n  }));\n}\n/**\n * Add pan and tap gesture recognition to an element.\n *\n * @param props - Gesture event handlers\n * @param ref - React `ref` containing a DOM `Element`\n * @public\n */\n\n\nfunction useGestures(props, ref) {\n  usePanGesture(props, ref);\n  useTapGesture(props, ref);\n  useHoverGesture(props, ref);\n}\n\nvar gestureProps = [\"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileTap\", \"whileHover\", \"onHoverStart\", \"onHoverEnd\"];\nvar Gestures = {\n  key: \"gestures\",\n  shouldRender: function (props) {\n    return gestureProps.some(function (key) {\n      return props.hasOwnProperty(key);\n    });\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    useGestures(props, visualElement);\n  })\n};\nvar Exit = {\n  key: \"exit\",\n  shouldRender: function (props) {\n    return !!props.exit && !checkShouldInheritVariant(props);\n  },\n  Component: makeRenderlessComponent(function (props) {\n    var _a;\n\n    var animate = props.animate,\n        controls = props.controls,\n        exit = props.exit;\n\n    var _b = usePresence(),\n        isPresent = _b[0],\n        onExitComplete = _b[1];\n\n    var presenceContext = useContext(PresenceContext);\n    var isPlayingExitAnimation = useRef(false);\n    var custom = ((_a = presenceContext) === null || _a === void 0 ? void 0 : _a.custom) !== undefined ? presenceContext.custom : props.custom;\n    useEffect(function () {\n      if (!isPresent) {\n        if (!isPlayingExitAnimation.current && exit) {\n          controls.setProps(__assign(__assign({}, props), {\n            custom: custom\n          }));\n          controls.start(exit).then(onExitComplete);\n        }\n\n        isPlayingExitAnimation.current = true;\n      } else if (isPlayingExitAnimation.current && animate && typeof animate !== \"boolean\" && !(animate instanceof AnimationControls)) {\n        controls.start(animate);\n      }\n\n      if (isPresent) {\n        isPlayingExitAnimation.current = false;\n      }\n    }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\n  })\n};\nvar AnimatePropType;\n\n(function (AnimatePropType) {\n  AnimatePropType[\"Target\"] = \"Target\";\n  AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\n  AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\n  if (prev === null) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n\n  return true;\n}\n\nvar hasUpdated = function (prev, next) {\n  return next !== undefined && (Array.isArray(prev) && Array.isArray(next) ? !shallowCompare(next, prev) : prev !== next);\n};\n\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\n  if (mergeTransitionEnd === void 0) {\n    mergeTransitionEnd = false;\n  }\n\n  var transition = _a.transition,\n      transitionEnd = _a.transitionEnd,\n      target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n\n  return mergeTransitionEnd ? __assign(__assign({}, target), transitionEnd) : target;\n}\n/**\n * Handle the `animate` prop when its an object of values, ie:\n *\n * ```jsx\n * <motion.div animate={{ opacity: 1 }} />\n * ```\n *\n * @internalremarks\n * It might be worth consolidating this with `use-variants`\n *\n * ```jsx\n * <motion.div animate=\"visible\" />\n * ```\n *\n * @param target\n * @param controls\n * @param values\n * @param transition\n *\n * @internal\n */\n\n\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\n  var isInitialRender = useRef(true);\n  var prevValues = useRef(null);\n\n  if (!prevValues.current) {\n    prevValues.current = targetWithoutTransition(targetAndTransition, true);\n  }\n\n  useEffect(function () {\n    var targetToAnimate = {}; // These are the values we're actually animating\n\n    var animatingTarget = targetWithoutTransition(targetAndTransition); // This is the target as it'll be once transitionEnd values are applied\n\n    var finalTarget = targetWithoutTransition(targetAndTransition, true); // Detect which values have changed between renders\n\n    for (var key in animatingTarget) {\n      // This value should animate on mount if this value doesn't already exist (wasn't\n      // defined in `style` or `initial`) or if it does exist and it's already changed.\n      var shouldAnimateOnMount = isInitialRender.current && (!visualElement.hasValue(key) || visualElement.getValue(key).get() !== finalTarget[key]); // If this value has updated between renders or it's we're animating this value on mount,\n      // add it to the animate target.\n\n      var isValidValue = finalTarget[key] !== null;\n      var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\n\n      if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\n        targetToAnimate[key] = animatingTarget[key];\n      }\n    }\n\n    isInitialRender.current = false;\n    prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\n\n    if (Object.keys(targetToAnimate).length) {\n      controls.start(__assign(__assign({}, targetToAnimate), {\n        transition: targetAndTransition.transition || defaultTransition,\n        transitionEnd: targetAndTransition.transitionEnd\n      }));\n    }\n  }, [targetAndTransition]);\n}\n\nvar labelsToArray = function (label) {\n  if (!label) {\n    return [];\n  }\n\n  if (Array.isArray(label)) {\n    return label;\n  }\n\n  return [label];\n};\n\nvar resolveVariantLabels = function (variant) {\n  var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\n  return Array.from(new Set(labelsToArray(unresolvedVariant)));\n};\n/**\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\n * When values in this array change, React re-runs the dependency. However if the array\n * contains a variable number of items, React throws an error.\n */\n\n\nvar asDependencyList = function (list) {\n  return [list.join(\",\")];\n};\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\n  return oldVariant.join(\",\") !== newVariant.join(\",\");\n};\n/**\n * Handle variants and the `animate` prop when its set as variant labels.\n *\n * @param initial - Initial variant(s)\n * @param animate - Variant(s) to animate to\n * @param inherit - `true` is inheriting animations from parent\n * @param controls - Animation controls\n *\n * @internal\n */\n\n\nfunction useVariants(initial, animate, inherit, controls) {\n  var targetVariants = resolveVariantLabels(animate);\n  var context = useContext(MotionContext);\n  var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\n  var hasMounted = useRef(false);\n  useEffect(function () {\n    var shouldAnimate = false;\n\n    if (inherit) {\n      // If we're inheriting variant changes and the parent has already\n      // mounted when this component loads, we need to manually trigger\n      // this animation.\n      shouldAnimate = !!parentAlreadyMounted;\n      targetVariants = resolveVariantLabels(context.animate);\n    } else {\n      shouldAnimate = hasMounted.current || hasVariantChanged(resolveVariantLabels(initial), targetVariants);\n    }\n\n    shouldAnimate && controls.start(targetVariants);\n    hasMounted.current = true;\n  }, asDependencyList(targetVariants));\n}\n/**\n * `useAnimationGroupSubscription` allows a component to subscribe to an\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\n *\n * @param animation\n * @param controls\n *\n * @internal\n */\n\n\nfunction useAnimationGroupSubscription(animation, controls) {\n  var unsubscribe = useMemo(function () {\n    return animation.subscribe(controls);\n  }, [animation]);\n  useEffect(function () {\n    return function () {\n      unsubscribe && unsubscribe();\n    };\n  }, [unsubscribe]);\n}\n\nvar _a, _b;\n\nvar AnimatePropComponents = (_a = {}, _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls,\n      visualElement = _a.visualElement,\n      transition = _a.transition;\n  return useAnimateProp(animate, controls, visualElement, transition);\n}), _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b,\n      controls = _a.controls,\n      initial = _a.initial;\n  return useVariants(initial, animate, inherit, controls);\n}), _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls;\n  return useAnimationGroupSubscription(animate, controls);\n}), _a);\n\nvar isVariantLabel$1 = function (prop) {\n  return Array.isArray(prop) || typeof prop === \"string\";\n};\n\nvar isAnimationSubscription = function (_a) {\n  var animate = _a.animate;\n  return animate instanceof AnimationControls;\n};\n\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\nvar animatePropTypeTests = (_b = {}, _b[AnimatePropType.Target] = function (props) {\n  return props.animate !== undefined && !isVariantLabel$1(props.animate) && !isAnimationSubscription(props);\n}, _b[AnimatePropType.VariantLabel] = function (props) {\n  return props.variants !== undefined || animationProps.some(function (key) {\n    return typeof props[key] === \"string\";\n  });\n}, _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription, _b);\n\nvar getAnimationComponent = function (props) {\n  var animatePropType = undefined;\n\n  for (var key in AnimatePropType) {\n    if (animatePropTypeTests[key](props)) {\n      animatePropType = key;\n    }\n  }\n\n  return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\n};\n/**\n * Currently we load all features synchronously, but it would be better to offer multiple entry points\n * that allow these to be loaded in asynchronously.\n */\n\n\nvar defaultFeatures = [Auto$1, Drag, Gestures, Exit];\n/**\n * Load features via renderless components based on the provided MotionProps\n */\n\nfunction useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\n  var plugins = useContext(MotionPluginContext); // If this is a static component, or we're rendering on the server, we don't load\n  // any feature components\n\n  if (isStatic || typeof window === \"undefined\") return null;\n\n  var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\n\n  var numFeatures = allFeatures.length;\n  var features = []; // TODO: Consolidate Animation feature loading strategy with other functionality components\n\n  var Animation = getAnimationComponent(props);\n\n  if (Animation) {\n    features.push(createElement(Animation, {\n      key: \"animation\",\n      initial: props.initial,\n      animate: props.animate,\n      variants: props.variants,\n      transition: props.transition,\n      controls: controls,\n      inherit: shouldInheritVariant,\n      visualElement: visualElement\n    }));\n  } // Decide which features we should render and add them to the returned array\n\n\n  for (var i = 0; i < numFeatures; i++) {\n    var _a = allFeatures[i],\n        shouldRender = _a.shouldRender,\n        key = _a.key,\n        Component = _a.Component;\n\n    if (shouldRender(props, parentContext)) {\n      features.push(createElement(Component, __assign({\n        key: key\n      }, props, {\n        localContext: context,\n        parentContext: parentContext,\n        visualElement: visualElement,\n        controls: controls\n      })));\n    }\n  }\n\n  return features;\n}\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\n\nfunction createMotionComponent(Component, _a) {\n  var useVisualElement = _a.useVisualElement,\n      render = _a.render,\n      animationControlsConfig = _a.animationControlsConfig;\n\n  function MotionComponent(props, externalRef) {\n    var parentContext = useContext(MotionContext);\n    var shouldInheritVariant = checkShouldInheritVariant(props);\n    /**\n     * If a component isStatic, we only visually update it as a\n     * result of a React re-render, rather than any interactions or animations.\n     * If this component or any ancestor isStatic, we disable hardware acceleration\n     * and don't load any additional functionality.\n     */\n\n    var isStatic = parentContext.static || props.static || false;\n    /**\n     * Create a VisualElement for this component. A VisualElement provides a common\n     * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n     * providing a way of rendering to these APIs outside of the React render loop\n     * for more performant animations and interactions\n     */\n\n    var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\n    /**\n     * Scrape MotionValues from props and add/remove them to/from\n     * the VisualElement as necessary.\n     */\n\n    useMotionValues(visualElement, props);\n    /**\n     * Create animation controls for the VisualElement. It might be\n     * interesting to try and combine this with VisualElement itself in a further refactor.\n     */\n\n    var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\n    /**\n     * Build the MotionContext to pass on to the next `motion` component.\n     */\n\n    var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\n    /**\n     * Load features as renderless components unless the component isStatic\n     */\n\n    var features = useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\n    var component = render(Component, props, visualElement); // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\n    // all plugins and features has to execute.\n\n    return createElement(Fragment, null, createElement(MotionContext.Provider, {\n      value: context\n    }, component), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n/**\n * DOM-specific config for `motion` components\n */\n\n\nvar config = {\n  useVisualElement: useDomVisualElement,\n  render: render,\n  animationControlsConfig: {\n    makeTargetAnimatable: parseDomVariant\n  }\n};\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion.custom(Component)\n * ```\n *\n * @public\n */\n\nfunction custom(Component) {\n  return createMotionComponent(Component, config);\n}\n\nvar componentCache = new Map();\n\nfunction get(target, key) {\n  if (key === \"custom\") return target.custom;\n\n  if (!componentCache.has(key)) {\n    componentCache.set(key, createMotionComponent(key, config));\n  }\n\n  return componentCache.get(key);\n}\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\n\n\nvar motion = new Proxy({\n  custom: custom\n}, {\n  get: get\n});\n\nfunction useForceUpdate() {\n  var _a = useState(0),\n      forcedRenderCount = _a[0],\n      setForcedRenderCount = _a[1];\n\n  return useCallback(function () {\n    return setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\n\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\n\nvar PresenceChild = function (_a) {\n  var children = _a.children,\n      initial = _a.initial,\n      isPresent = _a.isPresent,\n      onExitComplete = _a.onExitComplete,\n      custom = _a.custom;\n  var id = useConstant(getPresenceId);\n  var numPresenceChildren = useRef(0);\n  var numExitComplete = useRef(0);\n  var context = {\n    initial: initial,\n    isPresent: isPresent,\n    custom: custom,\n    onExitComplete: function () {\n      numExitComplete.current++;\n      var allComplete = numExitComplete.current >= numPresenceChildren.current;\n      onExitComplete && allComplete && onExitComplete();\n    }\n  };\n  var register = useMemo(function () {\n    numExitComplete.current = 0;\n    return function () {\n      numPresenceChildren.current++;\n      return function () {\n        return numPresenceChildren.current--;\n      };\n    };\n  }, [isPresent]);\n  return createElement(PresenceContext.Provider, {\n    value: __assign(__assign({\n      id: id\n    }, context), {\n      register: register\n    })\n  }, children);\n};\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = useContext(SharedLayoutContext);\n\n  if (isControlledSharedLayoutContext(layoutContext)) {\n    forceRender = layoutContext.forceRender;\n  }\n\n  var isInitialRender = useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return createElement(Fragment, null, filteredChildren.map(function (child) {\n      return createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = __spreadArrays(filteredChildren); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function () {\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return createElement(Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nfunction isControlledSharedLayoutContext(context) {\n  return !!context.forceRender;\n}\n\nfunction createSwitchAnimation(child, _isRoot, stack) {\n  var _a, _b;\n\n  if (stack && child !== stack.lead) {\n    return {\n      visibilityAction: VisibilityAction.Hide\n    };\n  } else if (stack && child.presence !== Presence.Entering && child === stack.lead && stack.lead !== stack.prevLead) {\n    return {\n      visibilityAction: VisibilityAction.Show\n    };\n  }\n\n  var origin;\n  var target;\n\n  if (child.presence === Presence.Entering) {\n    origin = (_a = stack) === null || _a === void 0 ? void 0 : _a.getFollowOrigin();\n  } else if (child.presence === Presence.Exiting) {\n    target = (_b = stack) === null || _b === void 0 ? void 0 : _b.getFollowTarget();\n  }\n\n  return {\n    origin: origin,\n    target: target\n  };\n}\n\nfunction createCrossfadeAnimation(child, isRoot, stack) {\n  var _a;\n\n  var config = {};\n  var stackLead = stack && stack.lead;\n  var stackLeadPresence = (_a = stackLead) === null || _a === void 0 ? void 0 : _a.presence;\n\n  if (stack && child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.origin = stack.getFollowOrigin();\n    } else if (child.presence === Presence.Exiting) {\n      config.target = stack.getFollowTarget();\n    }\n  } else if (stack && child === stack.follow) {\n    if (stackLeadPresence === Presence.Entering) {\n      config.target = stack.getLeadTarget();\n    } else if (stackLeadPresence === Presence.Exiting) {\n      config.origin = stack.getLeadOrigin();\n    }\n  } // // Handle crossfade opacity\n\n\n  if (!isRoot) return config;\n\n  if (!stack || child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.crossfade = crossfadeIn;\n    } else if (child.presence === Presence.Exiting) {\n      config.crossfade = crossfadeOut;\n    }\n  } else if (stack && child === stack.follow) {\n    if (!stackLead || stackLeadPresence === Presence.Entering) {\n      config.crossfade = crossfadeOut;\n    } else if (stackLeadPresence === Presence.Exiting) {\n      config.crossfade = crossfadeIn;\n    }\n  } else {\n    config.visibilityAction = VisibilityAction.Hide;\n  }\n\n  return config;\n}\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\n\nvar crossfadeIn = function (_origin, target, p) {\n  return mix(0, target, easeCrossfadeIn(p));\n};\n\nvar crossfadeOut = function (origin, _target, p) {\n  return mix(origin, 0, easeCrossfadeOut(p));\n};\n/**\n * For each layout animation, we want to identify two components\n * within a stack that will serve as the \"lead\" and \"follow\" components.\n *\n * In the switch animation, the lead component performs the entire animation.\n * It uses the follow bounding box to animate out from and back to. The follow\n * component is hidden.\n *\n * In the crossfade animation, both the lead and follow components perform\n * the entire animation, animating from the follow origin bounding box to the lead\n * target bounding box.\n *\n * Generalising a stack as First In Last Out, *searching from the end* we can\n * generally consider the lead component to be:\n *  - If the last child is present, the last child\n *  - If the last child is exiting, the last *encountered* exiting component\n */\n\n\nfunction findLeadAndFollow(stack, _a) {\n  var prevLead = _a[0],\n      prevFollow = _a[1];\n  var lead = undefined;\n  var leadIndex = 0;\n  var follow = undefined; // Find the lead child first\n\n  var numInStack = stack.length;\n  var lastIsPresent = false;\n\n  for (var i = numInStack - 1; i >= 0; i--) {\n    var child = stack[i];\n    var isLastInStack = i === numInStack - 1;\n\n    if (isLastInStack) {\n      lastIsPresent = child.isPresent();\n    }\n\n    if (lastIsPresent) {\n      lead = child;\n    } else {\n      // If the child before this will be present, make this the\n      // lead.\n      var prev = stack[i - 1];\n      if (prev && prev.isPresent()) lead = child;\n    }\n\n    if (lead) {\n      leadIndex = i;\n      break;\n    }\n  }\n\n  if (!lead) lead = stack[0]; // Find the follow child\n\n  follow = stack[leadIndex - 1]; // If the lead component is exiting, find the closest follow\n  // present component\n\n  if (lead) {\n    for (var i = leadIndex - 1; i >= 0; i--) {\n      var child = stack[i];\n\n      if (child.isPresent()) {\n        follow = child;\n        break;\n      }\n    }\n  } // If the lead has changed and the previous lead still exists in the\n  // stack, set it to the previous lead. This allows us to differentiate between\n  // a, b, c(exit) -> a, b(exit), c(exit)\n  // and\n  // a, b(exit), c -> a, b(exit), c(exit)\n\n\n  if (lead !== prevLead && !lastIsPresent && follow === prevFollow && stack.find(function (stackChild) {\n    return stackChild === prevLead;\n  })) {\n    lead = prevLead;\n  }\n\n  return [lead, follow];\n}\n\nvar LayoutStack =\n/** @class */\nfunction () {\n  function LayoutStack() {\n    this.order = []; // Track whether we've ever had a child\n\n    this.hasChildren = false;\n  }\n\n  LayoutStack.prototype.add = function (child) {\n    var layoutOrder = child.props.layoutOrder;\n\n    if (layoutOrder === undefined) {\n      this.order.push(child);\n    } else {\n      var index = this.order.findIndex(function (stackChild) {\n        return layoutOrder <= (stackChild.props.layoutOrder || 0);\n      });\n\n      if (index === -1) {\n        child.presence = this.hasChildren ? Presence.Entering : Presence.Present;\n        index = this.order.length;\n      }\n\n      this.order.splice(index, 0, child);\n    }\n\n    this.hasChildren = true;\n  };\n\n  LayoutStack.prototype.remove = function (child) {\n    var index = this.order.findIndex(function (stackChild) {\n      return child === stackChild;\n    });\n    if (index !== -1) this.order.splice(index, 1);\n  };\n\n  LayoutStack.prototype.updateLeadAndFollow = function () {\n    this.prevLead = this.lead;\n    this.prevFollow = this.follow;\n\n    var _a = findLeadAndFollow(this.order, [this.lead, this.follow]),\n        lead = _a[0],\n        follow = _a[1];\n\n    this.lead = lead;\n    this.follow = follow;\n  };\n\n  LayoutStack.prototype.updateSnapshot = function () {\n    if (this.lead) this.snapshot = this.lead.measuredOrigin;\n  };\n\n  LayoutStack.prototype.isLeadPresent = function () {\n    var _a;\n\n    return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\n  };\n\n  LayoutStack.prototype.shouldStackAnimate = function () {\n    var _a, _b, _c, _d;\n\n    return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.isPresent()) ? (_c = (_b = this.lead) === null || _b === void 0 ? void 0 : _b.props) === null || _c === void 0 ? void 0 : _c._shouldAnimate : this.follow && ((_d = this.follow) === null || _d === void 0 ? void 0 : _d.props._shouldAnimate);\n  };\n\n  LayoutStack.prototype.getFollowOrigin = function () {\n    return this.follow ? this.follow.measuredOrigin : this.snapshot;\n  };\n\n  LayoutStack.prototype.getFollowTarget = function () {\n    var _a;\n\n    return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.measuredTarget;\n  };\n\n  LayoutStack.prototype.getLeadOrigin = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.measuredOrigin;\n  };\n\n  LayoutStack.prototype.getLeadTarget = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.measuredTarget;\n  };\n\n  return LayoutStack;\n}();\n\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n/**\n * @public\n */\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Keep track of all animate children.\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Create an instance of the update batcher so we can run snapshots across\n     * components and fire animate transitions in the correct order.\n     */\n\n    _this.batch = batchTransitions();\n    /**\n     * We're tracking mount status as only subsequently-entering components need\n     * tagging with `shouldResumeFromPrevious`.\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Keep track of whether we're currently animating layout and block forced re-renders\n     * until we're not.\n     */\n\n    _this.isAnimating = false;\n    /**\n     * If a forced re-render is triggered while there's a shared layout animation we block\n     * it and check this boolean after all animations are complete.\n     */\n\n    _this.shouldRerender = false;\n    _this.state = {\n      /**\n       * Allow children, like AnimatePresence, to force-render this component\n       * to ensure animate children correctly identify parallel state changes that\n       * might affect their layout.\n       */\n      forceRender: function () {\n        if (!_this.isAnimating) {\n          _this.shouldRerender = false;\n\n          _this.setState(__assign({}, _this.state));\n        } else {\n          _this.shouldRerender = true;\n        }\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      move: function (child) {\n        _this.removeChildFromStack(child);\n\n        _this.addChildToStack(child);\n      }\n    };\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n  /**\n   * We always want the component to re-render but for performance reasons we might\n   * want to control whether we take snapshots and perform animate transitions.\n   */\n\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    this.shouldTransition = false;\n\n    if (this.state !== nextState) {\n      // This should always be true if we've got a new state as a result of a forced render\n      this.shouldTransition = true;\n    } else {\n      // If we don't have a defined dependency, or we do and it's changed,\n      // we want to transition\n      var dependency = this.props.dependency;\n      var hasDependency = !!(dependency !== null && dependency !== void 0 ? dependency : nextProps.dependency);\n      var hasChanged = dependency !== nextProps.dependency;\n      this.shouldTransition = !hasDependency || hasDependency && hasChanged;\n    }\n    /**\n     * Reset rotation on all children so we can properly measure the correct bounding box.\n     * The supportRotate prop isn't public API so this should only run in Framer.\n     *\n     * Ideally this would run in getSnapshotBeforeUpdate as shouldComponentUpdate may run\n     * multiple times in concurrent mode, but currently this is introducing bugs.\n     */\n\n\n    if (this.shouldTransition) {\n      var supportRotate = this.props.supportRotate;\n      supportRotate && this.children.forEach(function (child) {\n        return child.resetRotation();\n      });\n    }\n\n    return true;\n  };\n  /**\n   * Loop through all children and update their latest origin snapshots.\n   */\n\n\n  AnimateSharedLayout.prototype.getSnapshotBeforeUpdate = function () {\n    if (!this.shouldTransition) return null;\n    /**\n     * Snapshot the visual origin of every child.\n     */\n\n    this.children.forEach(function (child) {\n      return child.snapshotOrigin();\n    });\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    return null;\n  };\n  /**\n   * Once all children have updated, snapshot their target snapshots and run\n   * animate transitions.\n   */\n\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    // TODO: This would currently prevent animate children from working\n    if (this.shouldTransition) {\n      this.startAnimation();\n    } else {\n      this.children.forEach(function (child) {\n        child.stopLayoutAnimation && child.stopLayoutAnimation(); // Warning - this will stop all other animations even non-magic ones\n\n        child.props.controls.stop();\n      });\n    }\n  };\n  /**\n   * Register a new `Auto` child\n   */\n\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    var _this = this;\n\n    this.setRootDepth(child);\n    this.children.add(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    this.addChildToStack(child);\n    return function () {\n      return _this.removeChild(child);\n    };\n  };\n\n  AnimateSharedLayout.prototype.addChildToStack = function (child) {\n    var layoutId = child.props.layoutId;\n    if (layoutId === undefined) return;\n    var stack = this.getStack(layoutId);\n    stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.children.delete(child);\n    this.removeChildFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.removeChildFromStack = function (child) {\n    var layoutId = child.props.layoutId;\n    if (layoutId === undefined) return;\n    var stack = this.getStack(layoutId);\n    stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (id) {\n    !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\n    return this.stacks.get(id);\n  };\n  /**\n   * The root depth is the shallowest `depth` of all our children.\n   * Children with the shallowest depth get used to crossfade between trees.\n   */\n\n\n  AnimateSharedLayout.prototype.setRootDepth = function (child) {\n    if (this.rootDepth === undefined) {\n      this.rootDepth = child.depth;\n    } else {\n      this.rootDepth = Math.min(child.depth, this.rootDepth);\n    }\n  };\n\n  AnimateSharedLayout.prototype.startAnimation = function () {\n    var _this = this;\n\n    var _a = this.props,\n        type = _a.type,\n        _b = _a.transition,\n        transition = _b === void 0 ? defaultLayoutTransition : _b;\n    var options = {\n      type: type,\n      transition: transition\n    };\n    var createAnimation = type === \"crossfade\" ? createCrossfadeAnimation : createSwitchAnimation; // Update presence metadata based on latest AnimatePresence status\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent()) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n    var handler = {\n      snapshotTarget: function (child) {\n        return child.snapshotTarget();\n      },\n      startAnimation: function (child) {\n        var _a;\n\n        var numAnimations = 0;\n        var numCompletedAnimations = 0;\n        var layoutId = child.props.layoutId;\n        var stack = layoutId !== undefined ? _this.getStack(layoutId) : undefined;\n        var config = createAnimation(child, child.depth === _this.rootDepth, stack);\n        var shouldAnimate = type === \"crossfade\" && child.depth === _this.rootDepth ? true : (_a = stack) === null || _a === void 0 ? void 0 : _a.shouldStackAnimate();\n        var animation = child.startAnimation(__assign(__assign(__assign({}, options), config), {\n          shouldAnimate: shouldAnimate\n        }));\n        if (!animation) return;\n        _this.isAnimating = true;\n        numAnimations++;\n        animation.then(function () {\n          if (child.isPresent()) child.presence = Presence.Present;\n          numCompletedAnimations++;\n\n          if (numCompletedAnimations >= numAnimations) {\n            _this.isAnimating = false;\n          }\n\n          if (_this.shouldRerender && !_this.isAnimating) {\n            _this.state.forceRender();\n          }\n        });\n      }\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.batch.add(child);\n    });\n    this.batch.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.snapshot = undefined;\n    });\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return createElement(SharedLayoutContext.Provider, {\n      value: this.state\n    }, this.props.children);\n  };\n\n  return AnimateSharedLayout;\n}(Component);\n\nvar isCustomValueType = function (v) {\n  return typeof v === \"object\" && v.mix;\n};\n\nvar getMixer = function (v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\n\nfunction transform() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = interpolate(inputRange, outputRange, __assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nvar isTransformer = function (v) {\n  return typeof v === \"function\";\n};\n\nfunction useTransform(parent, customTransform, to, options) {\n  var _a;\n\n  var comparitor = isTransformer(customTransform) ? [parent] : [parent, customTransform.join(\",\"), (_a = to) === null || _a === void 0 ? void 0 : _a.join(\",\")];\n  var transformer = useMemo(function () {\n    return isTransformer(customTransform) ? customTransform : transform(customTransform, to, options);\n  }, comparitor);\n  var initialValue = transformer(parent.get());\n  var value = useMotionValue(initialValue); // Handle subscription to parent\n\n  var unsubscribe = useRef();\n  useMemo(function () {\n    unsubscribe.current && unsubscribe.current();\n    unsubscribe.current = parent.onChange(function (v) {\n      return value.set(transformer(v));\n    }); // Manually set with the latest parent value in case we've re-parented\n\n    value.set(initialValue);\n  }, [parent, value, transformer]);\n  useUnmountEffect(function () {\n    return unsubscribe.current && unsubscribe.current();\n  });\n  return value;\n} // Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\n\n\nvar maxScale = 100000;\n\nvar invertScale = function (scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useContext(MotionContext).visualElement;\n  invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nfunction useOnChange(value, callback) {\n  useEffect(function () {\n    return isMotionValue(value) ? value.onChange(callback) : undefined;\n  }, [value]);\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\n\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var activeSpringAnimation = useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  useMemo(function () {\n    return value.attach(function (v, set) {\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = spring(__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config)).start(set);\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\n\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\n\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function () {\n    var _a = getOffsets(),\n        xOffset = _a.xOffset,\n        yOffset = _a.yOffset,\n        xMaxOffset = _a.xMaxOffset,\n        yMaxOffset = _a.yMaxOffset; // Set absolute positions\n\n\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset); // Set 0-1 progress\n\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n\n  update();\n  return update;\n}\n\nvar isBrowser$2 = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\n\nvar getElementScrollOffsets = function (element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\nvar viewportScrollValues = createScrollMotionValues();\n\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\n\nvar hasListeners = false;\n\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useViewportScroll() {\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\n\n\nfunction useAnimation() {\n  var animationControls = useConstant(function () {\n    return new AnimationControls();\n  });\n  useEffect(function () {\n    animationControls.mount();\n    return function () {\n      return animationControls.unmount();\n    };\n  }, []);\n  return animationControls;\n}\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\n\n\nfunction useCycle() {\n  var items = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  } // TODO: After Framer X beta, remove this warning\n\n\n  warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\n  var index = useRef(0);\n\n  var _a = useState(items[index.current]),\n      item = _a[0],\n      setItem = _a[1];\n\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n} // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nvar prefersReducedMotion = motionValue(null);\n\nif (typeof window !== \"undefined\") {\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    var setReducedMotionPreferences = function () {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\n  return typeof isReducedMotion === \"boolean\" ? isReducedMotion : Boolean(prefersReduced);\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\n\n\nfunction useReducedMotion() {\n  var isReducedMotion = useContext(MotionContext).isReducedMotion;\n\n  var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)),\n      shouldReduceMotion = _a[0],\n      setShouldReduceMotion = _a[1];\n\n  useEffect(function () {\n    return prefersReducedMotion.onChange(function (v) {\n      setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\n    });\n  }, [setShouldReduceMotion, isReducedMotion]);\n  return shouldReduceMotion;\n}\n/**\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\n * or disable device detection.\n *\n * @internal\n */\n\n\nfunction ReducedMotion(_a) {\n  var children = _a.children,\n      enabled = _a.enabled;\n  var context = useContext(MotionContext);\n  context = useMemo(function () {\n    return __assign(__assign({}, context), {\n      isReducedMotion: enabled\n    });\n  }, [enabled]);\n  return createElement(MotionContext.Provider, {\n    value: context\n  }, children);\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nvar DragControls =\n/** @class */\nfunction () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n\n\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - A mouse/touch/pointer event.\n   * @param options - Options\n   *\n   * @public\n   */\n\n\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n\n  return DragControls;\n}();\n\nvar createDragControls = function () {\n  return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n/**\n * Uses the ref that is passed in, or creates a new one\n * @param external - External ref\n * @internal\n */\n\n\nfunction useExternalRef(externalRef) {\n  // We're conditionally calling `useRef` here which is sort of naughty as hooks\n  // shouldn't be called conditionally. However, Framer Motion will break if this\n  // condition changes anyway. It might be possible to use an invariant here to\n  // make it explicit, but I expect changing `ref` is not normal behaviour.\n  var ref = !externalRef || typeof externalRef === \"function\" ? useRef(null) : externalRef; // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\n  // but `ref` types changing between renders would break Motion anyway. If we receive\n  // bug reports about this, we should track the provided ref and throw an invariant\n  // rather than move the conditional to inside the useEffect as this will be fired\n  // for every Frame component within Framer.\n\n  if (externalRef && typeof externalRef === \"function\") {\n    useEffect(function () {\n      externalRef(ref.current);\n      return function () {\n        return externalRef(null);\n      };\n    }, []);\n  }\n\n  return ref;\n}\n\nvar StateVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(StateVisualElement, _super);\n\n  function StateVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.latestState = {};\n    return _this;\n  }\n\n  StateVisualElement.prototype.build = function () {};\n\n  StateVisualElement.prototype.clean = function () {};\n\n  StateVisualElement.prototype.getBoundingBox = function () {\n    return {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n  };\n\n  StateVisualElement.prototype.readNativeValue = function (key) {\n    return this.latestState[key] || 0;\n  };\n\n  StateVisualElement.prototype.render = function () {};\n\n  return StateVisualElement;\n}(VisualElement);\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\n\n\nfunction useAnimatedState(initialState) {\n  var _a = useState(initialState),\n      animationState = _a[0],\n      setAnimationState = _a[1];\n\n  var visualElement = useConstant(function () {\n    return new StateVisualElement();\n  });\n  visualElement.updateConfig({\n    onUpdate: function (v) {\n      return setAnimationState(__assign({}, v));\n    }\n  });\n  visualElement.latestState = animationState;\n  var controls = useVisualElementAnimation(visualElement, {}, {});\n  useEffect(function () {\n    visualElement.mount({});\n    return function () {\n      return visualElement.unmount();\n    };\n  }, []);\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return controls.start(animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n}\n\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, SharedLayoutContext, VisualElementAnimationControls, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };","map":{"version":3,"sources":["/Users/scott/Documents/GitHub/worksbyscott/node_modules/framer-motion/dist/framer-motion.es.js"],"names":["__assign","__spreadArrays","__extends","__rest","sync","getFrameData","cancelSync","velocityPerSecond","clamp","distance","mix","progress","mixColor","interpolate","wrap","invariant","warning","number","color","complex","px","percent","degrees","vw","vh","scale","alpha","progressPercentage","rgba","useRef","createElement","createContext","useContext","useMemo","useEffect","Component","forwardRef","Fragment","useCallback","useState","cloneElement","Children","isValidElement","useLayoutEffect","action","delay","tween","spring","keyframes","keyframes$1","inertia","easingLookup","cubicBezier","linear","circOut","isRefObject","ref","hasOwnProperty","isFloat","value","isNaN","parseFloat","MotionValue","init","_this","timeDelta","lastUpdated","canTrackVelocity","updateAndNotify","v","render","prev","current","updateSubscribers","forEach","notifySubscriber","renderSubscribers","_a","delta","timestamp","postRender","scheduleVelocityCheck","subscriber","velocityCheck","set","prototype","subscribeTo","subscriptions","subscription","updateSubscriber","add","delete","onChange","Set","onRenderRequest","attach","passiveEffect","get","getPrevious","getVelocity","start","animation","stop","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","clear","motionValue","VisualElement","parent","latest","values","Map","valueSubscriptions","config","update","onUpdate","triggerRender","element","mount","unmount","externalRef","depth","hasValue","key","has","addValue","removeValue","subscribeToValue","unsubscribe","getValue","defaultValue","undefined","forEachValue","callback","getInstance","updateConfig","setSingleStaticValue","setStaticValues","onRender","unsubscribeOnChange","unsubscribeOnRender","_","noop","any","convertBoundingBoxToAxisBox","top","left","right","bottom","x","min","max","y","convertAxisBoxToBoundingBox","transformBoundingBox","transformPoint","topLeft","bottomRight","calcAxisCenter","auto","test","parse","int","transform","Math","round","defaultValueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","translateX","translateY","translateZ","z","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","dimensionValueTypes","testValueType","type","findDimensionValueType","find","valueTypes","findValueType","getDefaultValueType","getValueAsType","axes","order","transformProps","operationKey","axesKey","push","sortTransformProps","a","b","indexOf","transformPropSet","isTransformProp","transformOriginProps","isTransformOriginProp","translateAlias","buildTransform","transformKeys","transformTemplate","transformIsDefault","enableHardwareAcceleration","allowTransformNone","transformString","transformHasZ","sort","numTransformKeys","length","i","trim","isCSSVariable","startsWith","buildHTMLStyles","style","vars","transformOrigin","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","default","bucket","HTMLVisualElement","_super","apply","arguments","reactStyle","defaultConfig","call","clean","getBoundingBox","transformPagePoint","box","getBoundingClientRect","build","read","getComputedStyle","readNativeValue","defaultValueType","window","Object","assign","setProperty","useConstant","calcOrigin","origin","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","progressToPixels","dashKeys","array","camelKeys","buildSVGPath","attrs","totalLength","spacing","useDashCase","keys","pathLength","pathSpacing","unmeasured","buildSVGAttrs","totalPathLength","attrX","attrY","_b","_c","pathOffset","camelCaseAttributes","CAMEL_CASE_PATTERN","REPLACE_TEMPLATE","camelToDash","str","replace","toLowerCase","SVGVisualElement","measure","getBBox","e","isPath","getTotalLength","getAttribute","setAttribute","tagName","svgElements","svgTagNames","isSVGComponent","useDomVisualElement","props","isStatic","visualElement","DOMVisualElement","validMotionProps","isValidMotionProp","isPropValid","emotionIsPropValid_1","require","filterProps","domProps","buildHTMLProps","drag","htmlProps","userSelect","draggable","buildSVGProps","forwardedProps","visualProps","isCSSVariable$1","cssVariableRegex","parseCSSVariable","match","exec","token","fallback","maxDepth","getVariableValue","resolved","getPropertyValue","resolveCSSVariables","transitionEnd","target","HTMLElement","isKeyframesTarget","Array","isArray","positionalKeys","isPositionalKey","hasPositionalKey","some","setAndResetVelocity","to","isNumOrPxType","BoundingBoxDimension","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","from","fromType","toType","numKeyframes","map","convertedTarget","unitConversion","parseDomVariant","useInitialOrEveryRender","isInitialOnly","isInitialRender","AnimationControls","hasMounted","pendingAnimations","componentControls","setVariants","variants","controls","setDefaultTransition","transition","defaultTransition","subscribe","definition","transitionOverride","animations_1","all","animationControls","PresenceContext","useMotionValue","initial","isCustomValue","Boolean","toValue","resolveFinalValueInKeyframes","resolveMotionValue","unwrappedValue","eachAxis","handler","safeBoundingBox","safePixels","axis","boxAxis","clampProgress","snapshotLayout","boundingBox","snapshotStyle","valueHandlers","computedStyle","position","snapshot","layout","calcOrigin$1","before","after","beforeSize","afterSize","calcTranslate","beforePoint","afterPoint","scaledPoint","point","originPoint","distanceFromOrigin","scaled","calcDelta","translate","isNear","calcBoxDelta","applyDelta","applyAxisDelta","applyBoxDelta","applyTreeDeltas","treeScale","deltas","numDeltas","resetStyles","reset","applyCurrent","zeroDelta","tweenAxis","next","p","tweenAxisBox","defaultHandler","snapshotTarget","child","startAnimation","batchTransitions","queue","flush","sortByDepth","maxDistance","isSharedLayoutTree","context","register","resetAxis","originAxis","resetBox","originBox","isTreeVisible","isVisible","getAnimatableValues","supportedAutoValues","createUpdater","fixTransparentRGB","isBlack","red","green","blue","isTransparent","fixed","fixTransparentRGBPair","parsedOrigin","parsedTarget","MotionContext","static","layoutDepth","isVariantLabel","isAnimationControls","useMotionContext","parentContext","animate","whileTap","whileHover","layoutId","presenceContext","presenceId","id","isPresenceRoot","initialState","shouldPropagateControls","targetInitial","targetAnimate","initialDependency","animateDependency","layoutDelta","createZeroDelta","layoutDeltas","layoutProgress","isReducedMotion","initialToApply","checkShouldInheritVariant","inherit","isMotionValue","useMotionValues","empty","isTransform","existsAsProp","existsAsStyle","propIsMotionValue","styleIsMotionValue","transformRemoved","motionValueRemoved","addMotionValues","transformValues","source","isStyle","foundMotionValue","reservedNames","motion","underDampedSpring","stiffness","damping","restDelta","restSpeed","overDampedSpring","linearTween","ease","duration","defaultTransitions","getDefaultTransition","valueKey","transitionFactory","just","complete","easingDefinitionToFunction","x1","y1","x2","y2","isEasingArray","isDurationAnimation","isAnimatable","secondsToMilliseconds","seconds","transitions","transitionOptionParser","opts","velocity","easings","isTransitionDefined","when","delayChildren","staggerChildren","staggerDirection","getTransitionDefinition","transitionDefinition","valueTransitionDefinition","preprocessOptions","getAnimation","isOriginAnimatable","isTargetAnimatable","actionFactory","repeatDelay","delay$1","activeAnimation","animationFactory","valueDelay","options","isNumericalString","getCurrent","isTargetResolver","isVariantLabels","VisualElementAnimationControls","makeTargetAnimatable","baseTarget","overrides","resolvedOverrides","activeOverrides","setProps","setValues","isActive","priority","_d","resolveVariant","targetValue","checkForNewValues","newValueKeys","numNewValues","getAnimatableNone","variant","custom","getHighestPriority","setOverride","overrideIndex","children","startOverride","override","clearOverride","highest","resetIsAnimating","highestOverride","overrideTarget","remainingValues","onStart","onComplete","applyVariantLabels","variantLabelList","reversedList","reverse","animateVariantLabels","animateVariant","animationDefinition","_e","getOrigin","animatable","animations","valueTarget","allAnimations","variantLabels","label","variantLabel","getAnimations","getChildrenAnimations","animateChildren","first","last","maxStaggerDuration","generateStaggerDuration","childControls","onAnimationStart","onAnimationComplete","checkOverrideIsAnimating","numOverrides","resolvedOverride","addChild","removeChild","resetChildren","getOriginFromTransition","valueTransition","useVisualElementAnimation","subscribeToParentControls","parentControls","isPresent","unmountProps","MotionPluginContext","autoValues","features","MotionPlugins","pluginContext","Provider","SharedLayoutContext","Presence","VisibilityAction","StackPosition","session","syncRenderSession","isOpen","open","view","usePresence","onExitComplete","useIsPresent","convertSingleRadius","parsed","factor","radiusAsPixels","singleBorderRadius","targetBox","originAsPixels","targetAsPixels","vx","vy","targetX","targetY","defaultMagicValues","background","boxShadow","isEmptyBoxShadow","originShadow","getAnimatableShadow","targetShadow","currentShadow","mixShadowColor","shadowTemplate","createTransformer","dx","dy","averageXYScale","averageTreeXTScale","shadow","createLock","name","lock","openLock","globalHorizontalLock","globalVerticalLock","getGlobalLock","openHorizontal_1","openVertical_1","isViewportScrollBlocked","isBrowser","document","addEventListener","event","preventDefault","passive","blockViewportScroll","unblockViewportScroll","addDomEvent","eventName","removeEventListener","useDomEvent","isMouseEvent","PointerEvent","pointerType","MouseEvent","isTouchEvent","hasTouches","touches","filterPrimaryPointer","eventHandler","isPrimaryPointer","button","defaultPagePoint","pageX","pageY","pointFromTouch","primaryTouch","changedTouches","pointFromMouse","extractEventInfo","wrapHandler","shouldFilterPrimaryPointer","listener","isBrowser$1","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","addPointerEvent","usePointerEvent","Point","subtract","relativeTo","idOrElem","elem","getElem","getElementById","localElem","rect","scrollX","scrollY","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","onMove","initialInfo","onSessionStart","removeOnPointerMove","handlePointerMove","removeOnPointerUp","handlePointerUp","removeListeners","buttons","end","onEnd","panInfo","updateHandlers","lastDevicePoint","startDevicePoint","getVelocity$1","timestampedPoint","lastPoint","time","currentVelocity","Infinity","elementDragControls","WeakMap","VisualElementDragControls","isDragging","currentDirection","constraints","openGlobalLock","panSession","originEvent","snapToCursor","stopMotion","resolveDragConstraints","bothAxis","axisPoint","dragPropagation","onDragStart","convertPanToDrag","dragDirectionLock","getCurrentDirection","onDirectionLock","onDrag","constraintsNeedResolution","dragConstraints","onMeasureDragConstraints","constraintsElement","calculateConstraintsFromDom","applyConstraintsToPoint","cancelDrag","dragMomentum","dragElastic","onDragEnd","animateDragEnd","recordBoxInfo","prevConstraints","center","setPoint","shouldDrag","applyConstraints","updateProps","_f","_g","remainingProps","_dragValueX","_dragValueY","dragOriginX","dragOriginY","dragTransition","_dragTransitionControls","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","externalAxisMotionValue","scalePoint","onDragTransitionEnd","constraintsBox","draggableBox","scaleAxisPoint","pointToScale","constraintsWidth","draggableWidth","abs","stopPointerListener","dragListener","stopResizeListener","direction","lockThreshold","draggableElement","_point","parentBoundingBox","draggableTransform","draggableBoundingBox","calculateConstraints","calculateAxisConstraints","parentAxis","draggableAxis","parentBox","constrainedValue","applyOverdrag","dragFactor","SharedLayoutContextProvider","safeToRemove","sharedLayoutContext","Auto","willAnimate","shouldAnimate","correctedLayout","frameTarget","hasAnimatedRotate","localContext","_shouldAnimate","animatableStyles","componentDidMount","unregisterSharedLayoutContext","componentDidUpdate","prevProps","layoutOrder","move","getSnapshotBeforeUpdate","snapshotOrigin","componentWillUnmount","stopLayoutAnimation","shouldComponentUpdate","nextProps","hasDependency","magicDependency","dependencyHasChanged","presenceHasChanged","resetRotation","measuredOrigin","measuredTarget","popFromFlow","hide","show","newOpacity","setVisibility","visibilityAction","Show","animationPromise","visualTarget","visualOrigin","parentDeltas","startLayoutAnimation","startStyleAnimation","onMagicComplete","originStyle","targetStyle","isAnimatingRotate","updaters","frame","updateBoundingBox","updateTransform","updateRotate","updater","crossfade","progressOrigin","progressTarget","dragControls","scheduleUpdate","unsubscribeProgress","unsubscribeParentProgress","shouldAnimateStyle","numAnimatableStyles","Auto$1","shouldRender","hasAutoAnimateProps","useDrag","groupDragControls","useDisableDragOnExit","makeRenderlessComponent","hook","Drag","useUnmountEffect","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","onPointerDown","isNodeOrChild","parentElement","order$1","getGesturePriority","gesture","tapGesturePriority","useTapGesture","onTap","onTapStart","onTapCancel","hasTapListeners","isTapping","cancelPointerEventListener","removePointerUp","onPointerUp","openGestureLock","hoverPriority","filterTouch","useHoverGesture","onHoverStart","onHoverEnd","useGestures","gestureProps","Gestures","Exit","exit","isPlayingExitAnimation","AnimatePropType","shallowCompare","prevLength","hasUpdated","targetWithoutTransition","mergeTransitionEnd","useAnimateProp","targetAndTransition","prevValues","targetToAnimate","animatingTarget","finalTarget","shouldAnimateOnMount","isValidValue","valueHasUpdated","labelsToArray","resolveVariantLabels","unresolvedVariant","asDependencyList","list","join","hasVariantChanged","oldVariant","newVariant","useVariants","targetVariants","parentAlreadyMounted","useAnimationGroupSubscription","AnimatePropComponents","Target","VariantLabel","AnimationSubscription","isVariantLabel$1","prop","isAnimationSubscription","animationProps","animatePropTypeTests","getAnimationComponent","animatePropType","defaultFeatures","useFeatures","shouldInheritVariant","plugins","allFeatures","numFeatures","Animation","createMotionComponent","useVisualElement","animationControlsConfig","MotionComponent","component","componentCache","Proxy","useForceUpdate","forcedRenderCount","setForcedRenderCount","getPresenceId","PresenceChild","numPresenceChildren","numExitComplete","allComplete","getChildKey","updateChildLookup","allChildren","seenChildren","process","env","NODE_ENV","console","warn","onlyElements","filtered","AnimatePresence","exitBeforeEnter","forceRender","layoutContext","isControlledSharedLayoutContext","filteredChildren","presentChildren","exiting","childrenToRender","presentKeys","targetKeys","numPresent","insertionIndex","onExit","removeIndex","findIndex","presentChild","splice","createSwitchAnimation","_isRoot","stack","lead","Hide","presence","Entering","prevLead","getFollowOrigin","Exiting","getFollowTarget","createCrossfadeAnimation","isRoot","stackLead","stackLeadPresence","follow","getLeadTarget","getLeadOrigin","crossfadeIn","crossfadeOut","compress","easing","easeCrossfadeIn","easeCrossfadeOut","_origin","_target","findLeadAndFollow","prevFollow","leadIndex","numInStack","lastIsPresent","isLastInStack","stackChild","LayoutStack","hasChildren","index","Present","remove","updateLeadAndFollow","updateSnapshot","isLeadPresent","shouldStackAnimate","defaultLayoutTransition","AnimateSharedLayout","stacks","batch","shouldRerender","state","setState","removeChildFromStack","addChildToStack","nextState","shouldTransition","dependency","hasChanged","supportRotate","setRootDepth","getStack","rootDepth","createAnimation","numAnimations","numCompletedAnimations","isCustomValueType","getMixer","args","_i","useImmediate","argOffset","inputValue","inputRange","outputRange","interpolator","mixer","isTransformer","useTransform","customTransform","comparitor","transformer","initialValue","maxScale","invertScale","useInvertedScale","parentScaleX","parentScaleY","useOnChange","useSpring","activeSpringAnimation","createScrollMotionValues","scrollXProgress","scrollYProgress","setProgress","maxOffset","createScrollUpdater","getOffsets","xOffset","yOffset","xMaxOffset","yMaxOffset","isBrowser$2","useIsomorphicLayoutEffect","getElementScrollOffsets","scrollLeft","scrollTop","scrollWidth","offsetWidth","scrollHeight","offsetHeight","useElementScroll","updateScrollValues","scrollListener","resizeListener","viewportScrollValues","getViewportScrollOffsets","pageXOffset","pageYOffset","body","clientWidth","innerWidth","clientHeight","innerHeight","hasListeners","addEventListeners","useViewportScroll","useAnimation","useCycle","items","item","setItem","prefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","determineShouldReduceMotion","prefersReduced","useReducedMotion","shouldReduceMotion","setShouldReduceMotion","ReducedMotion","enabled","DragControls","nativeEvent","createDragControls","useDragControls","useExternalRef","StateVisualElement","latestState","useAnimatedState","animationState","setAnimationState"],"mappings":"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","sourcesContent":["import { __assign, __spreadArrays, __extends, __rest } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, clamp, distance, mix, progress, mixColor, interpolate, wrap } from '@popmotion/popcorn';\nimport { invariant, warning } from 'hey-listen';\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage, rgba } from 'style-value-types';\nimport { useRef, createElement, createContext, useContext, useMemo, useEffect, Component, forwardRef, Fragment, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear, circOut } from '@popmotion/easing';\n\nvar isRefObject = function (ref) {\n    return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\n};\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init) {\n        var _this = this;\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            if (_this.updateSubscribers && _this.prev !== _this.current) {\n                _this.updateSubscribers.forEach(_this.notifySubscriber);\n            }\n            if (render && _this.renderSubscribers) {\n                _this.renderSubscribers.forEach(_this.notifySubscriber);\n            }\n            // Update timestamp\n            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync.postRender(_this.scheduleVelocityCheck);\n            }\n        };\n        /**\n         * Notify a subscriber with the latest value.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @param subscriber - The subscriber to notify.\n         *\n         * @internal\n         */\n        this.notifySubscriber = function (subscriber) {\n            subscriber(_this.current);\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return sync.postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n            }\n        };\n        this.set(init, false);\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Subscribes a subscriber function to a subscription list.\n     *\n     * @param subscriptions - A `Set` of subscribers.\n     * @param subscription - A subscriber function.\n     */\n    MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\n        var _this = this;\n        var updateSubscriber = function () { return subscription(_this.current); };\n        subscriptions.add(updateSubscriber);\n        return function () { return subscriptions.delete(updateSubscriber); };\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * @library\n     *\n     * ```jsx\n     * function MyComponent() {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <Frame x={x} />\n     * }\n     * ```\n     *\n     * @motion\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @internalremarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        if (!this.updateSubscribers)\n            this.updateSubscribers = new Set();\n        return this.subscribeTo(this.updateSubscribers, subscription);\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        if (!this.renderSubscribers)\n            this.renderSubscribers = new Set();\n        // Render immediately\n        this.notifySubscriber(subscription);\n        return this.subscribeTo(this.renderSubscribers, subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        return this.current;\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers && this.updateSubscribers.clear();\n        this.renderSubscribers && this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}());\n/**\n * @internal\n */\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n\n/**\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\n * underlying renderer.\n *\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\n * VisualElement and we can quickly offer all the same features.\n */\nvar VisualElement = /** @class */ (function () {\n    function VisualElement(parent, ref) {\n        var _this = this;\n        // The latest resolved MotionValues\n        this.latest = {};\n        // A map of MotionValues used to animate this element\n        this.values = new Map();\n        // Unsubscription callbacks for each MotionValue\n        this.valueSubscriptions = new Map();\n        // A configuration for this VisualElement, each derived class can extend this.\n        this.config = {};\n        // A pre-bound call to the user-provided `onUpdate` callback. This won't\n        // be called more than once per frame.\n        this.update = function () { return _this.config.onUpdate(_this.latest); };\n        // Pre-bound version of render\n        this.triggerRender = function () { return _this.render(); };\n        // This function gets passed to the rendered component's `ref` prop\n        // and is used to mount/unmount the VisualElement\n        this.ref = function (element) {\n            element ? _this.mount(element) : _this.unmount();\n            if (!_this.externalRef)\n                return;\n            if (typeof _this.externalRef === \"function\") {\n                _this.externalRef(element);\n            }\n            else if (isRefObject(_this.externalRef)) {\n                _this.externalRef.current = element;\n            }\n        };\n        // Create a relationship with the provided parent. When we come to replace\n        // the auto-animation stuff with VisualElement we might need to make this\n        // relationship two-way\n        this.parent = parent;\n        // Calculate the depth of this node in the VisualElement graph\n        this.depth = parent ? parent.depth + 1 : 0;\n        // A reference to any externally-defined React ref. This might live better\n        // outside the VisualElement and be handled in a hook.\n        this.externalRef = ref;\n    }\n    // Check whether this element has a MotionValue of the provided key\n    VisualElement.prototype.hasValue = function (key) {\n        return this.values.has(key);\n    };\n    // Add a MotionValue\n    VisualElement.prototype.addValue = function (key, value) {\n        if (this.hasValue(key))\n            this.removeValue(key);\n        this.values.set(key, value);\n        this.latest[key] = value.get();\n        if (this.element)\n            this.subscribeToValue(key, value);\n    };\n    // Remove a MotionValue\n    VisualElement.prototype.removeValue = function (key) {\n        var unsubscribe = this.valueSubscriptions.get(key);\n        unsubscribe && unsubscribe();\n        this.values.delete(key);\n        delete this.latest[key];\n        this.valueSubscriptions.delete(key);\n    };\n    VisualElement.prototype.getValue = function (key, defaultValue) {\n        var value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = new MotionValue(defaultValue);\n            this.addValue(key, value);\n        }\n        return value;\n    };\n    // Iterate over all MotionValues\n    VisualElement.prototype.forEachValue = function (callback) {\n        this.values.forEach(callback);\n    };\n    // Get the underlying rendered instance of this VisualElement. For instance in\n    // HTMLVisualElement this will be a HTMLElement.\n    VisualElement.prototype.getInstance = function () {\n        return this.element;\n    };\n    VisualElement.prototype.updateConfig = function (config) {\n        if (config === void 0) { config = {}; }\n        this.config = __assign({}, config);\n    };\n    // Set a single `latest` value\n    VisualElement.prototype.setSingleStaticValue = function (key, value) {\n        this.latest[key] = value;\n    };\n    // Statically set values to `latest` without needing a MotionValue\n    VisualElement.prototype.setStaticValues = function (values, value) {\n        if (typeof values === \"string\") {\n            this.setSingleStaticValue(values, value);\n        }\n        else {\n            for (var key in values) {\n                this.setSingleStaticValue(key, values[key]);\n            }\n        }\n    };\n    // Subscribe to changes in a MotionValue\n    VisualElement.prototype.subscribeToValue = function (key, value) {\n        var _this = this;\n        var onChange = function (latest) {\n            _this.setSingleStaticValue(key, latest);\n            _this.latest[key] = latest;\n            _this.config.onUpdate && sync.update(_this.update, false, true);\n        };\n        var onRender = function () { return sync.render(_this.triggerRender, false, true); };\n        var unsubscribeOnChange = value.onChange(onChange);\n        var unsubscribeOnRender = value.onRenderRequest(onRender);\n        this.valueSubscriptions.set(key, function () {\n            unsubscribeOnChange();\n            unsubscribeOnRender();\n        });\n    };\n    // Mount the VisualElement with the actual DOM element\n    VisualElement.prototype.mount = function (element) {\n        var _this = this;\n        invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\n        this.element = this.current = element;\n        // Subscribe to any pre-existing MotionValues\n        this.forEachValue(function (value, key) { return _this.subscribeToValue(key, value); });\n    };\n    // Unmount the VisualElement and cancel any scheduled updates\n    VisualElement.prototype.unmount = function () {\n        var _this = this;\n        this.forEachValue(function (_, key) { return _this.removeValue(key); });\n        cancelSync.update(this.update);\n        cancelSync.render(this.render);\n    };\n    return VisualElement;\n}());\n\nfunction noop(any) {\n    return any;\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        bottom: y.max,\n        left: x.min,\n        right: x.max,\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    if (transformPoint === void 0) { transformPoint = noop; }\n    var topLeft = transformPoint({ x: left, y: top });\n    var bottomRight = transformPoint({ x: right, y: bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n/**\n * Calculate the center point of the provided axis\n */\nfunction calcAxisCenter(_a) {\n    var min = _a.min, max = _a.max;\n    return (max - min) / 2 + min;\n}\n\n/**\n * ValueType for \"auto\"\n */\nvar auto = {\n    test: function (v) { return v === \"auto\"; },\n    parse: function (v) { return v; },\n};\n/**\n * ValueType for ints\n */\nvar int = __assign(__assign({}, number), { transform: Math.round });\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = {\n    // Color props\n    color: color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Transform props\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale: scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n    axes.forEach(function (axesKey) { return transformProps.push(operationKey + axesKey); });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n    if (enableHardwareAcceleration === void 0) { enableHardwareAcceleration = true; }\n    if (allowTransformNone === void 0) { allowTransformNone = true; }\n    // The transform string we're going to build into\n    var transformString = \"\";\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        if (key === \"z\")\n            transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    }\n    else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable(key) {\n    return key.startsWith(\"--\");\n}\n\n/**\n * Build style and CSS variables\n *\n * This function converts a Motion style prop:\n *\n * { x: 100, width: 100, originX: 0.5 }\n *\n * Into an object with default value types applied and default\n * transform order set:\n *\n * {\n *   transform: 'translateX(100px) translateZ(0)`,\n *   width: '100px',\n *   transformOrigin: '50% 50%'\n * }\n *\n * Styles are saved to `style` and CSS vars to `vars`.\n *\n * This function works with mutative data structures.\n */\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a) {\n    var enableHardwareAcceleration = _a.enableHardwareAcceleration, transformTemplate = _a.transformTemplate, allowTransformNone = _a.allowTransformNone;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable. Transforms and transform origins are kept seperately\n     * for further processing\n     */\n    for (var key in latest) {\n        var value = latest[key];\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = getDefaultValueType(key);\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag and enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            if (!transformIsNone)\n                continue;\n            // If all the transform keys we've so far encountered are their default value\n            // then check to see if this one isn't\n            var defaultValue = valueType.default !== undefined ? valueType.default : 0;\n            if (value !== defaultValue)\n                transformIsNone = false;\n        }\n        else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            hasTransformOrigin = true;\n        }\n        else if (key !== \"transform\" || typeof value !== \"function\") {\n            var bucket = isCSSVariable(key) ? vars : style;\n            bucket[key] = valueAsType;\n        }\n    }\n    // Only process transform if values aren't defaults\n    if (hasTransform || transformTemplate) {\n        style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\n    }\n    // Only process transform origin if values aren't default\n    if (hasTransformOrigin) {\n        var originX = transformOrigin.originX || \"50%\";\n        var originY = transformOrigin.originY || \"50%\";\n        var originZ = transformOrigin.originZ || \"0\";\n        style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\n    }\n}\n\n/**\n * A VisualElement for HTMLElements\n */\nvar HTMLVisualElement = /** @class */ (function (_super) {\n    __extends(HTMLVisualElement, _super);\n    function HTMLVisualElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable record of styles we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.style = {};\n        /**\n         * A record of styles we only want to apply via React. This gets set in useMotionValues\n         * and applied in the render function. I'd prefer this to live somewhere else to decouple\n         * VisualElement from React but works for now.\n         */\n        _this.reactStyle = {};\n        /**\n         * A mutable record of CSS variables we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.vars = {};\n        /**\n         * A mutable record of transforms we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.transform = {};\n        /**\n         * A mutable record of transform origins we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.transformOrigin = {};\n        /**\n         * A mutable record of transform keys we want to apply to the rendered Element. We order\n         * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.transformKeys = [];\n        _this.defaultConfig = {\n            enableHardwareAcceleration: true,\n            allowTransformNone: true,\n        };\n        _this.config = _this.defaultConfig;\n        return _this;\n    }\n    /**\n     * The measured bounding box as it exists on the page with no transforms applied.\n     */\n    //private measuredBox = axisBox()\n    /**\n     * The `measuredBox` layout as corrected for all the transforms being applied up the\n     * tree. We use this as the final bounding box from which we calculate a transform\n     * delta to our desired visual position on any given frame.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n    //private correctedBox = axisBox()\n    /**\n     * The visual target we want to project our component into on a given frame.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n    //private targetBox = axisBox()\n    /**\n     * The overall scale of the local coordinate system as transformed by all parents of this component. We use this\n     * for scale correction on our calculated layouts and scale-affected values like `boxShadow`.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n    //private treeScale = { x: 1, y: 1 }\n    /**\n     * When a value is removed, we want to make sure it's removed from all rendered data structures.\n     */\n    HTMLVisualElement.prototype.removeValue = function (key) {\n        _super.prototype.removeValue.call(this, key);\n        delete this.vars[key];\n        delete this.style[key];\n    };\n    /**\n     * Empty the mutable data structures by re-creating them. We can do this every React render\n     * as the comparative workload to the rest of the render is very low and this is also when\n     * we want to reflect values that might have been removed by the render.\n     */\n    HTMLVisualElement.prototype.clean = function () {\n        this.style = {};\n        this.vars = {};\n        this.transform = {};\n    };\n    HTMLVisualElement.prototype.updateConfig = function (config) {\n        if (config === void 0) { config = {}; }\n        this.config = __assign(__assign({}, this.defaultConfig), config);\n    };\n    /**\n     * Measure and return the Element's bounding box. We convert it to a AxisBox2D\n     * structure to make it easier to work on each individual axis generically.\n     */\n    HTMLVisualElement.prototype.getBoundingBox = function () {\n        var transformPagePoint = this.config.transformPagePoint;\n        var box = this.element.getBoundingClientRect();\n        box = transformBoundingBox(box, transformPagePoint);\n        return convertBoundingBoxToAxisBox(box);\n    };\n    /**\n     * Build a style prop using the latest resolved MotionValues\n     */\n    HTMLVisualElement.prototype.build = function () {\n        // TODO: Add shadow bounding box resolution\n        buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config);\n    };\n    /**\n     * Read a value directly from the HTMLElement style.\n     */\n    HTMLVisualElement.prototype.read = function (key) {\n        return this.getComputedStyle()[key] || 0;\n    };\n    /**\n     * Read a value directly from the HTMLElement in case it's not defined by a Motion\n     * prop. If it's a transform, we just return a pre-defined default value as reading these\n     * out of a matrix is either error-prone or can incur a big payload for little benefit.\n     */\n    HTMLVisualElement.prototype.readNativeValue = function (key) {\n        if (isTransformProp(key)) {\n            var defaultValueType = getDefaultValueType(key);\n            return defaultValueType ? defaultValueType.default || 0 : 0;\n        }\n        else {\n            return this.read(key);\n        }\n    };\n    /**\n     * Return the computed style after a render.\n     */\n    HTMLVisualElement.prototype.getComputedStyle = function () {\n        return window.getComputedStyle(this.getInstance());\n    };\n    /**\n     * Render the Element by rebuilding and applying the latest styles and vars.\n     */\n    HTMLVisualElement.prototype.render = function () {\n        // Rebuild the latest animated values into style and vars caches.\n        this.build();\n        // Directly assign style into the Element's style prop. In tests Object.assign is the\n        // fastest way to assign styles.\n        Object.assign(this.element.style, this.style);\n        // Loop over any CSS variables and assign those.\n        for (var key in this.vars) {\n            this.element.style.setProperty(key, this.vars[key]);\n        }\n    };\n    return HTMLVisualElement;\n}(VisualElement));\n// const axisBox = (): AxisBox2D => ({\n//     x: { min: 0, max: 0 },\n//     y: { min: 0, max: 0 },\n// })\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n    return pxOriginX + \" \" + pxOriginY;\n}\n\n// Convert a progress 0-1 to a pixels value based on the provided length\nvar progressToPixels = function (progress, length) {\n    return px.transform(progress * length);\n};\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) { spacing = 1; }\n    if (offset === void 0) { offset = 0; }\n    if (useDashCase === void 0) { useDashCase = true; }\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\n    // Build the dash array\n    var pathLength = progressToPixels(length, totalLength);\n    var pathSpacing = progressToPixels(spacing, totalLength);\n    attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\nvar unmeasured = { x: 0, y: 0, width: 0, height: 0 };\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    /**\n     * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\n     */\n    buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (originX !== undefined || originY !== undefined || style.transform) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been measured\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n    }\n    return attrs;\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n]);\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\n/**\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\n * share data structures.\n */\nvar SVGVisualElement = /** @class */ (function (_super) {\n    __extends(SVGVisualElement, _super);\n    function SVGVisualElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable record of attributes we want to apply directly to the rendered Element\n         * every frame. We use a mutable data structure to reduce GC during animations.\n         */\n        _this.attrs = {};\n        /**\n         * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\n         */\n        _this.defaultConfig = {\n            enableHardwareAcceleration: false,\n        };\n        /**\n         * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\n         * being assigned to config\n         */\n        _this.config = _this.defaultConfig;\n        return _this;\n    }\n    /**\n     * Measure the SVG element on mount. This can affect page rendering so there might be a\n     * better time to perform this - for instance dynamically only if there's a transform-origin dependent\n     * transform being set (like rotate)\n     */\n    SVGVisualElement.prototype.mount = function (element) {\n        _super.prototype.mount.call(this, element);\n        this.measure();\n    };\n    /**\n     * Update the SVG dimensions and path length\n     */\n    SVGVisualElement.prototype.measure = function () {\n        try {\n            this.dimensions =\n                typeof this.element.getBBox ===\n                    \"function\"\n                    ? this.element.getBBox()\n                    : this.element.getBoundingClientRect();\n        }\n        catch (e) {\n            // Most likely trying to measure an unrendered element under Firefox\n            this.dimensions = { x: 0, y: 0, width: 0, height: 0 };\n        }\n        if (isPath(this.element)) {\n            this.totalPathLength = this.element.getTotalLength();\n        }\n    };\n    /**\n     * Empty the mutable data structures in case attrs have been removed between renders.\n     */\n    SVGVisualElement.prototype.clean = function () {\n        _super.prototype.clean.call(this);\n        this.attrs = {};\n    };\n    /**\n     * Read an attribute directly from the SVGElement\n     */\n    SVGVisualElement.prototype.read = function (key) {\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return this.element.getAttribute(key);\n    };\n    SVGVisualElement.prototype.build = function () {\n        buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\n    };\n    SVGVisualElement.prototype.render = function () {\n        // Update HTML styles and CSS variables\n        _super.prototype.render.call(this);\n        // Loop through attributes and apply them to the SVGElement\n        for (var key in this.attrs) {\n            this.element.setAttribute(camelToDash(key), this.attrs[key]);\n        }\n    };\n    return SVGVisualElement;\n}(HTMLVisualElement));\nfunction isPath(element) {\n    return element.tagName === \"path\";\n}\n\n/**\n * @internal\n */\n/**\n * @internal\n */\nvar svgElements = [\n    \"animate\",\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\",\n    \"filter\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textPath\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nvar svgTagNames = new Set(svgElements);\n/**\n * Determine whether this is a HTML or SVG component based on if the provided\n * Component is a string and a recognised SVG tag. A potentially better way to\n * do this would be to offer a `motion.customSVG` function and determine this\n * when we generate the `motion.circle` etc components.\n */\nfunction isSVGComponent(Component) {\n    return typeof Component === \"string\" && svgTagNames.has(Component);\n}\n\n/**\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\n * or SVGVisualElement for the component.\n */\nvar useDomVisualElement = function (Component, props, parent, isStatic, ref) {\n    var visualElement = useConstant(function () {\n        var DOMVisualElement = isSVGComponent(Component)\n            ? SVGVisualElement\n            : HTMLVisualElement;\n        return new DOMVisualElement(parent, ref);\n    });\n    visualElement.updateConfig(__assign({ enableHardwareAcceleration: !isStatic }, props));\n    return visualElement;\n};\n\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"static\",\n    \"layoutId\",\n    \"layoutOrder\",\n    \"_shouldAnimate\",\n    \"isPresent\",\n    \"magicDependency\",\n    \"allowTransformNone\",\n    \"onMagicComplete\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"_dragValueX\",\n    \"_dragValueY\",\n    \"_dragTransitionControls\",\n    \"dragOriginX\",\n    \"dragOriginY\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"whileHover\",\n    \"whileTap\",\n    \"onHoverEnd\",\n    \"onHoverStart\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\n\nvar isPropValid = function (key) { return !isValidMotionProp(key); };\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n    isPropValid = function (key) {\n        // Handle events explicitly as Emotion validates them all as true\n        if (key.startsWith(\"on\")) {\n            return !isValidMotionProp(key);\n        }\n        else {\n            return emotionIsPropValid_1(key);\n        }\n    };\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props) {\n    var domProps = {};\n    for (var key in props) {\n        if (isPropValid(key))\n            domProps[key] = props[key];\n    }\n    return domProps;\n}\n\nfunction buildHTMLProps(visualElement, _a) {\n    var drag = _a.drag;\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {\n        style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars),\n    };\n    if (!!drag) {\n        // Disable text selection\n        htmlProps.style.userSelect = \"none\";\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n    }\n    return htmlProps;\n}\n\n/**\n * Build React props for SVG elements\n */\nfunction buildSVGProps(visualElement) {\n    return __assign(__assign({}, visualElement.attrs), { style: __assign({}, visualElement.reactStyle) });\n}\n\nfunction render(Component, props, visualElement) {\n    // Only filter props from components we control, ie `motion.div`. If this\n    // is a custom component pass along everything provided to it.\n    var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\n    /**\n     * Every render, empty and rebuild the animated values to be applied to our Element.\n     * During animation these data structures are used in a mutable fashion to reduce\n     * garbage collection, but between renders we can flush them to remove values\n     * that might have been taken out of the provided props.\n     */\n    visualElement.clean();\n    visualElement.build();\n    // Generate props to visually render this component\n    var visualProps = isSVGComponent(Component)\n        ? buildSVGProps(visualElement)\n        : buildHTMLProps(visualElement, props);\n    return createElement(Component, __assign(__assign(__assign({}, forwardedProps), { ref: visualElement.ref }), visualProps));\n}\n\nfunction isCSSVariable$1(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var token = match[1], fallback = match[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n    var _a = parseCSSVariable(current), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved;\n    }\n    else if (isCSSVariable$1(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var target = __rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof HTMLElement))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = __assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable$1(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable$1(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd && transitionEnd[key] === undefined) {\n            transitionEnd[key] = current;\n        }\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === number || v === px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform)\n        return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n}; };\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.render();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a) {\n        var x = _a.x;\n        return x.max - x.min;\n    },\n    height: function (_a) {\n        var y = _a.y;\n        return y.max - y.min;\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.getBoundingBox();\n    var elementComputedStyle = visualElement.getComputedStyle();\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValues(\"display\", target.display || \"block\");\n    }\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.render();\n    var targetBbox = visualElement.getBoundingBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = __assign({}, target);\n    transitionEnd = __assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var to = target[key];\n        var fromType = findDimensionValueType(from);\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.render();\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n/**\n * Use callback either only on the initial render or on all renders. In concurrent mode\n * the \"initial\" render might run multiple times\n *\n * @param callback - Callback to run\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\n *\n * @public\n */\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\n    if (isInitialOnly === void 0) { isInitialOnly = false; }\n    var isInitialRender = useRef(true);\n    if (!isInitialOnly || (isInitialOnly && isInitialRender.current)) {\n        callback();\n    }\n    isInitialRender.current = false;\n}\n\n/**\n * Control animations on one or more components.\n *\n * @public\n */\nvar AnimationControls = /** @class */ (function () {\n    function AnimationControls() {\n        /**\n         * Track whether the host component has mounted.\n         *\n         * @internal\n         */\n        this.hasMounted = false;\n        /**\n         * Pending animations that are started before a component is mounted.\n         *\n         * @internal\n         */\n        this.pendingAnimations = [];\n        /**\n         * A collection of linked component animation controls.\n         *\n         * @internal\n         */\n        this.componentControls = new Set();\n    }\n    /**\n     * Set variants on this and all child components.\n     *\n     * @param variants - The variants to set\n     *\n     * @internal\n     */\n    AnimationControls.prototype.setVariants = function (variants) {\n        this.variants = variants;\n        this.componentControls.forEach(function (controls) {\n            return controls.setVariants(variants);\n        });\n    };\n    /**\n     * Set a default transition on this and all child components\n     *\n     * @param transition - The default transition to set\n     *\n     * @internal\n     */\n    AnimationControls.prototype.setDefaultTransition = function (transition) {\n        this.defaultTransition = transition;\n        this.componentControls.forEach(function (controls) {\n            return controls.setDefaultTransition(transition);\n        });\n    };\n    /**\n     * Subscribes a component's animation controls to this.\n     *\n     * @param controls - The controls to subscribe\n     * @returns An unsubscribe function.\n     *\n     * @internal\n     */\n    AnimationControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        if (this.variants)\n            controls.setVariants(this.variants);\n        if (this.defaultTransition)\n            controls.setDefaultTransition(this.defaultTransition);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Starts an animation on all linked components.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * controls.start(\"variantLabel\")\n     * controls.start({\n     *   x: 0,\n     *   transition: { duration: 1 }\n     * })\n     * ```\n     *\n     * @param definition - Properties or variant label to animate to\n     * @param transition - Optional `transtion` to apply to a variant\n     * @returns - A `Promise` that resolves when all animations have completed.\n     *\n     * @public\n     */\n    AnimationControls.prototype.start = function (definition, transitionOverride) {\n        var _this = this;\n        if (this.hasMounted) {\n            var animations_1 = [];\n            this.componentControls.forEach(function (controls) {\n                var animation = controls.start(definition, {\n                    transitionOverride: transitionOverride,\n                });\n                animations_1.push(animation);\n            });\n            return Promise.all(animations_1);\n        }\n        else {\n            return new Promise(function (resolve) {\n                _this.pendingAnimations.push({\n                    animation: [definition, transitionOverride],\n                    resolve: resolve,\n                });\n            });\n        }\n    };\n    /**\n     * Instantly set to a set of properties or a variant.\n     *\n     * ```jsx\n     * // With properties\n     * controls.set({ opacity: 0 })\n     *\n     * // With variants\n     * controls.set(\"hidden\")\n     * ```\n     *\n     * @internalremarks\n     * We could perform a similar trick to `.start` where this can be called before mount\n     * and we maintain a list of of pending actions that get applied on mount. But the\n     * expectation of `set` is that it happens synchronously and this would be difficult\n     * to do before any children have even attached themselves. It's also poor practise\n     * and we should discourage render-synchronous `.start` calls rather than lean into this.\n     *\n     * @public\n     */\n    AnimationControls.prototype.set = function (definition) {\n        invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n        return this.componentControls.forEach(function (controls) {\n            return controls.apply(definition);\n        });\n    };\n    /**\n     * Stops animations on all linked components.\n     *\n     * ```jsx\n     * controls.stop()\n     * ```\n     *\n     * @public\n     */\n    AnimationControls.prototype.stop = function () {\n        this.componentControls.forEach(function (controls) { return controls.stop(); });\n    };\n    /**\n     * Initialises the animation controls.\n     *\n     * @internal\n     */\n    AnimationControls.prototype.mount = function () {\n        var _this = this;\n        this.hasMounted = true;\n        this.pendingAnimations.forEach(function (_a) {\n            var animation = _a.animation, resolve = _a.resolve;\n            return _this.start.apply(_this, animation).then(resolve);\n        });\n    };\n    /**\n     * Stops all child animations when the host component unmounts.\n     *\n     * @internal\n     */\n    AnimationControls.prototype.unmount = function () {\n        this.hasMounted = false;\n        this.stop();\n    };\n    return AnimationControls;\n}());\n/**\n * @internal\n */\nvar animationControls = function () { return new AnimationControls(); };\n\n/**\n * @public\n */\nvar PresenceContext = createContext(null);\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    return useConstant(function () { return motionValue(initial); });\n}\n\nvar isCustomValue = function (v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\nfunction resolveMotionValue(value) {\n    var unwrappedValue = value instanceof MotionValue ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\n\n/**\n * If a bounding box is measured as 0 on either axis we encounter\n * divide by zero errors. We can prevent the actual errors by dividing by\n * an arbitrarily low amount, but then it's possible to see bugs where\n * child elements appear smeared across the screen. By setting each axis\n * to a non-zero measurement, the element itself will disappear (as you\n * can't invert scale: 0) but it will correctly animate back out, and it\n * fixes distortion on any children.\n */\nfunction safeBoundingBox(box) {\n    var safePixels = 0.5;\n    eachAxis(function (axis) {\n        var boxAxis = box[axis];\n        if (boxAxis.min === boxAxis.max) {\n            boxAxis.min -= safePixels;\n            boxAxis.max += safePixels;\n        }\n    });\n    return box;\n}\n\nvar clampProgress = clamp(0, 1);\nfunction snapshotLayout(element) {\n    var boundingBox = element.getBoundingBox();\n    return safeBoundingBox(boundingBox);\n}\nfunction snapshotStyle(element, valueHandlers) {\n    var computedStyle = element.getComputedStyle();\n    var style = {\n        position: computedStyle.position,\n    };\n    for (var key in valueHandlers) {\n        var handler = valueHandlers[key];\n        if (handler.read === false) {\n            continue;\n        }\n        else if (handler.read) {\n            style[key] = handler.read(computedStyle[key]);\n        }\n        else {\n            style[key] = computedStyle[key];\n        }\n    }\n    warning(computedStyle.display !== \"inline\", \"Magic components can't be display: inline, as inline elements don't accept a transform. Try inline-block instead.\");\n    return style;\n}\nfunction snapshot(element, valueHandlers) {\n    return {\n        layout: snapshotLayout(element),\n        style: snapshotStyle(element, valueHandlers),\n    };\n}\n/**\n * Calculate an appropriate transform origin for this delta.\n *\n * If components don't change size, it isn't really relavent what origin we provide.\n * When a component is scaling, we want to generate a visually appeasing transform origin and allow\n * the component to scale out (or in) from there. This means 0 for components whose left edge\n * is the same or beyond the `before`, 1 for the inverse, and 0-1 for in between.\n */\nfunction calcOrigin$1(before, after) {\n    var origin = 0.5;\n    var beforeSize = before.max - before.min;\n    var afterSize = after.max - after.min;\n    if (beforeSize > afterSize) {\n        origin = progress(before.min, before.max - afterSize, after.min);\n    }\n    else if (afterSize > beforeSize) {\n        origin = progress(after.min, after.max - beforeSize, before.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Calculate a translation value that, if applied to `after` with the given\n * `origin`, would return `before`\n */\nfunction calcTranslate(before, after, origin) {\n    var beforePoint = mix(before.min, before.max, origin);\n    var afterPoint = mix(after.min, after.max, origin);\n    return beforePoint - afterPoint;\n}\n/**\n * Applies a `scale` to a `point` from the given `originPoint`.\n */\nfunction scaledPoint(_a, point) {\n    var scale = _a.scale, originPoint = _a.originPoint;\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Calculate a transform delta that, if applied to `after`, will\n * create `before`.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\nfunction calcDelta(delta, before, after, origin) {\n    var beforeSize = before.max - before.min;\n    var afterSize = after.max - after.min;\n    delta.scale = beforeSize / afterSize;\n    delta.origin = origin !== undefined ? origin : calcOrigin$1(before, after);\n    delta.originPoint = after.min + delta.origin * afterSize;\n    delta.translate = calcTranslate(before, after, delta.origin);\n    // Clamp\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Calculate a transform delta between before and after.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\nfunction calcBoxDelta(delta, before, after, origin) {\n    calcDelta(delta.x, before.x, after.x, origin);\n    calcDelta(delta.y, before.y, after.y, origin);\n}\n/**\n * Apple the translation and scale delta to a single point.\n */\nfunction applyDelta(point, delta) {\n    return scaledPoint(delta, point) + delta.translate;\n}\n/**\n * Scale and translate both points on an axis.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\nfunction applyAxisDelta(axis, delta) {\n    axis.min = applyDelta(axis.min, delta);\n    axis.max = applyDelta(axis.max, delta);\n}\n/**\n * Scale and translate both axis of a box.\n */\nfunction applyBoxDelta(box, delta) {\n    applyAxisDelta(box.x, delta.x);\n    applyAxisDelta(box.y, delta.y);\n}\n/**\n * Apply a whole tree of deltas to a box. Along the way, keep track of the\n * resultant scale of the tree.\n *\n * This is a mutative operation to avoid creating new objects every frame.\n */\nfunction applyTreeDeltas(box, treeScale, deltas) {\n    var numDeltas = deltas.length;\n    treeScale.x = treeScale.y = 1;\n    for (var i = 0; i < numDeltas; i++) {\n        var delta = deltas[i];\n        applyBoxDelta(box, delta);\n        treeScale.x *= delta.x.scale;\n        treeScale.y *= delta.y.scale;\n    }\n}\nfunction resolve(defaultValue, value) {\n    return value === undefined ? defaultValue : resolveMotionValue(value);\n}\n/**\n * Reset `element.style` to ensure we're not reading styles that have previously been animated.\n * If anything is set in the incoming style prop, use that, otherwise unset to ensure the\n * underlying CSS is read.\n *\n * @param styleProp\n */\nfunction resetStyles(style, valueHandlers) {\n    var reset = {\n        x: 0,\n        y: 0,\n        scale: 1,\n        scaleX: 1,\n        scaleY: 1,\n        rotate: 0,\n    };\n    // TODO: We need to resolve MotionValues\n    for (var key in valueHandlers) {\n        var handler = valueHandlers[key];\n        if (style[key] !== undefined) {\n            reset[key] = style[key];\n        }\n        else if (handler.reset) {\n            reset[key] = handler.reset(style);\n        }\n        else {\n            reset[key] = \"\";\n        }\n    }\n    // if (offsetSnapshot) {\n    //     Object.assign(reset, offsetSnapshot, { position: \"absolute\" })\n    // }\n    return reset;\n}\n/**\n * Apply the saved current styles to the provided style object.\n */\nfunction applyCurrent(style, current) {\n    for (var key in current) {\n        style[key] = current[key];\n    }\n}\n/**\n * An object representing a zero or neutral delta. Applying this as a\n * transform would leave a bounding box unchanged.\n */\nvar zeroDelta = {\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n};\n/**\n * Tween a single axis between two bounding boxes.\n *\n * This is a mutative operation.\n */\nfunction tweenAxis(axis, target, prev, next, p) {\n    target[axis].min = mix(prev[axis].min, next[axis].min, p);\n    target[axis].max = mix(prev[axis].max, next[axis].max, p);\n}\n/**\n * Tween between two bounding boxes.\n *\n * This is a mutative operation.\n */\nfunction tweenAxisBox(target, prev, next, p) {\n    tweenAxis(\"x\", target, prev, next, p);\n    tweenAxis(\"y\", target, prev, next, p);\n}\nvar defaultHandler = {\n    snapshotTarget: function (child) { return child.snapshotTarget(); },\n    startAnimation: function (child) { return child.startAnimation(); },\n};\n// const isPresent = (child: Auto) => child.isPresent()\n// const isExiting = (child: Auto) => !isPresent(child)\n// const isExitingRoot = (child: Auto) => !isPresent(child)\nvar batchTransitions = function () {\n    var queue = new Set();\n    var add = function (child) { return queue.add(child); };\n    var flush = function (_a) {\n        var _b = _a === void 0 ? defaultHandler : _a, snapshotTarget = _b.snapshotTarget, startAnimation = _b.startAnimation;\n        if (!queue.size)\n            return;\n        var order = Array.from(queue).sort(sortByDepth);\n        order.forEach(function (child) { return child.resetStyles(); });\n        order.forEach(snapshotTarget);\n        // const present = order.filter(isPresent)\n        // const exiting = order.filter(isExiting)\n        // const exitingRoots = exiting.filter(isExitingRoot)\n        // // Snapshot the position of all the exiting components, as we will use\n        // // these bounding boxes to project into\n        // exiting.forEach(child => child.snapshotTarget())\n        // // Reset all styles to figure out where everything would be laid out\n        // order.forEach(child => child.resetStyles())\n        // // For each exiting root, we use the snapshot information to pop from the document flow.\n        // // TODO: We actually probably want to loop through all children and checking if we're popped and still exiting\n        // exitingRoots.forEach(child => child.popFromFlow())\n        // // TODO: Reset snapshot origin?\n        // // Snapshot all present components in their new layout positions\n        // present.forEach(snapshotTarget)\n        // Start the layout animations\n        order.forEach(startAnimation);\n        queue.clear();\n    };\n    return { add: add, flush: flush };\n};\nvar sortByDepth = function (a, b) { return a.depth - b.depth; };\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return distance(value, target) < maxDistance;\n}\n/**\n * Check if the provided context is the SharedLayoutContext default\n * or if we're the child of an AnimateSharedLayout component.\n */\nfunction isSharedLayoutTree(context) {\n    return !!context.register;\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n    resetAxis(box.x, originBox.x);\n    resetAxis(box.y, originBox.y);\n}\n/**\n * Look up the tree to check whether we're in a visible portion\n * of the tree. If we're not, we can optimise away this animation.\n */\nfunction isTreeVisible(deltas) {\n    var isVisible = true;\n    var numDeltas = deltas.length;\n    for (var i = 0; i < numDeltas; i++) {\n        if (!deltas[i].isVisible) {\n            isVisible = false;\n            continue;\n        }\n    }\n    return isVisible;\n}\n/**\n * Detect which automatically animatable values don't need scale correction and can be animated normally.\n */\nfunction getAnimatableValues(supportedAutoValues) {\n    return Object.keys(supportedAutoValues).filter(function (key) { return !supportedAutoValues[key].createUpdater; });\n}\nfunction fixTransparentRGB(a, b) {\n    var isBlack = !a.red && !a.green && !a.blue;\n    var isTransparent = !a.alpha;\n    var fixed = isBlack && isTransparent ? __assign(__assign({}, b), { alpha: 0 }) : a;\n    return rgba.transform(fixed);\n}\nfunction fixTransparentRGBPair(origin, target) {\n    var parsedOrigin = rgba.parse(origin);\n    var parsedTarget = rgba.parse(target);\n    return [\n        fixTransparentRGB(parsedOrigin, parsedTarget),\n        fixTransparentRGB(parsedTarget, parsedOrigin),\n    ];\n}\n\n/**\n * @internal\n */\nvar MotionContext = createContext({\n    static: false,\n    layoutDepth: -1,\n});\nvar isVariantLabel = function (v) {\n    return typeof v === \"string\" || Array.isArray(v);\n};\nvar isAnimationControls = function (v) {\n    return v instanceof AnimationControls;\n};\n/**\n * Set up the context for children motion components.\n *\n * We also use this opportunity to apply `initial` values\n */\nvar useMotionContext = function (parentContext, controls, visualElement, isStatic, _a) {\n    if (isStatic === void 0) { isStatic = false; }\n    var initial = _a.initial, animate = _a.animate, variants = _a.variants, whileTap = _a.whileTap, whileHover = _a.whileHover, layoutId = _a.layoutId;\n    var _b, _c;\n    var presenceContext = useContext(PresenceContext);\n    var presenceId = (_b = presenceContext) === null || _b === void 0 ? void 0 : _b.id;\n    var isPresenceRoot = parentContext.presenceId !== presenceId;\n    // Override initial with that from a parent context, if defined\n    if (((_c = presenceContext) === null || _c === void 0 ? void 0 : _c.initial) !== undefined) {\n        initial = presenceContext.initial;\n    }\n    var initialState;\n    if (initial === false && !isAnimationControls(animate)) {\n        initialState = animate;\n    }\n    else if (typeof initial !== \"boolean\") {\n        initialState = initial;\n    }\n    // Track mounted status so children can detect whether they were present during their\n    // parent's first render\n    var hasMounted = useRef(false);\n    // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\n    // if we're being used to control variants, or if we're being passed animation controls.\n    // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\n    // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\n    // that this restriction is removed.\n    var shouldPropagateControls = variants ||\n        isVariantLabel(animate) ||\n        isVariantLabel(whileTap) ||\n        isVariantLabel(whileHover) ||\n        isAnimationControls(animate);\n    // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\n    var targetInitial = isVariantLabel(initialState)\n        ? initialState\n        : parentContext.initial;\n    // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\n    // the tree initially animates.\n    var targetAnimate = isVariantLabel(animate)\n        ? animate\n        : parentContext.animate;\n    // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\n    // or in another non-animation/interaction environment.\n    var initialDependency = isStatic ? targetInitial : null;\n    // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\n    // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\n    // We want to do this as we rely on React's component rendering order each render cycle to determine\n    // the new order of any child components for the `staggerChildren` functionality.\n    var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate)\n        ? targetAnimate\n        : null;\n    // TODO: We need every motion component in the stack to communicate down - for performance we can look into\n    // ditching zero deltas if this isn't a motion component\n    var layoutDelta = useConstant(createZeroDelta);\n    var layoutDeltas = useRef(__spreadArrays((parentContext.layoutDeltas || []), [\n        layoutDelta,\n    ]));\n    var layoutProgress = useMotionValue(0);\n    // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\n    // unlikely to change, by making the context an object it'll be considered a new value every render.\n    // So all child motion components will re-render as a result.\n    var context = useMemo(function () { return ({\n        controls: shouldPropagateControls\n            ? controls\n            : parentContext.controls,\n        initial: targetInitial,\n        animate: targetAnimate,\n        visualElement: visualElement,\n        hasMounted: hasMounted,\n        isReducedMotion: parentContext.isReducedMotion,\n        presenceId: presenceId,\n        layoutDepth: \n        // TODO: Make nice isMagic\n        animate || layoutId !== undefined\n            ? parentContext.layoutDepth + 1\n            : parentContext.layoutDepth,\n        layoutDelta: layoutDelta,\n        layoutDeltas: layoutDeltas.current,\n        layoutProgress: layoutProgress,\n        isPresenceRoot: isPresenceRoot,\n    }); }, [\n        initialDependency,\n        animateDependency,\n        parentContext.isReducedMotion,\n        animate,\n        layoutId,\n        presenceId,\n    ]);\n    // Update the `static` property every render. This is unlikely to change but also essentially free.\n    context.static = isStatic;\n    // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\n    // in `initial`.\n    useInitialOrEveryRender(function () {\n        var initialToApply = initialState || parentContext.initial;\n        initialToApply && controls.apply(initialToApply);\n    }, !isStatic);\n    useEffect(function () {\n        hasMounted.current = true;\n    }, []);\n    return context;\n};\nfunction createZeroDelta() {\n    return {\n        x: __assign({}, zeroDelta),\n        y: __assign({}, zeroDelta),\n        isVisible: true,\n    };\n}\n\nvar checkShouldInheritVariant = function (_a) {\n    var animate = _a.animate, variants = _a.variants, _b = _a.inherit, inherit = _b === void 0 ? true : _b;\n    return (inherit &&\n        !!variants &&\n        (!animate || animate instanceof AnimationControls));\n};\n\nvar isMotionValue = function (value) {\n    return value instanceof MotionValue;\n};\n\n/**\n * Scrape props for MotionValues and add/remove them to this component's\n * VisualElement\n */\nfunction useMotionValues(visualElement, props) {\n    var prev = useConstant(empty);\n    /**\n     * Remove MotionValues that are no longer present\n     */\n    for (var key in prev) {\n        var isTransform = isTransformProp(key) || isTransformOriginProp(key);\n        var existsAsProp = props[key];\n        var existsAsStyle = props.style && props.style[key];\n        var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\n        var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\n        var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\n        var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\n        if (transformRemoved || motionValueRemoved) {\n            visualElement.removeValue(key);\n            delete prev[key];\n        }\n    }\n    /**\n     * Add incoming MotionValues\n     */\n    addMotionValues(visualElement, prev, props);\n    if (props.style)\n        addMotionValues(visualElement, prev, props.style, true);\n    /**\n     * Transform custom values if provided a handler, ie size -> width/height\n     * Ideally we'd ditch this by removing support for size and other custom values from Framer.\n     */\n    if (props.transformValues) {\n        visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\n    }\n}\n/**\n * Add incoming MotionValues\n *\n * TODO: Type the VisualElements properly\n */\nfunction addMotionValues(visualElement, prev, source, isStyle) {\n    if (isStyle === void 0) { isStyle = false; }\n    if (isStyle)\n        visualElement.reactStyle = {};\n    for (var key in source) {\n        var value = source[key];\n        var foundMotionValue = false;\n        if (isMotionValue(value)) {\n            // If this is a MotionValue, add it if it isn't a reserved key\n            if (!reservedNames.has(key)) {\n                visualElement.addValue(key, value);\n                foundMotionValue = true;\n            }\n        }\n        else if (isTransformProp(key) || isTransformOriginProp(key)) {\n            // If this is a transform prop, always create a MotionValue\n            // to ensure we can reconcile them all together.\n            if (!visualElement.hasValue(key)) {\n                visualElement.addValue(key, motionValue(value));\n            }\n            else if (value !== prev[key]) {\n                // If the MotionValue already exists, update it with the\n                // latest incoming value\n                var motion = visualElement.getValue(key);\n                motion.set(value);\n            }\n            foundMotionValue = true;\n        }\n        else if (isStyle) {\n            visualElement.reactStyle[key] = value;\n        }\n        if (foundMotionValue)\n            prev[key] = value;\n    }\n}\n/**\n * These are props we accept as MotionValues but don't want to add\n * to the VisualElement\n */\nvar reservedNames = new Set([\n    \"dragOriginX\",\n    \"dragOriginY\",\n    \"_dragValueX\",\n    \"_dragValueY\",\n]);\nvar empty = function () { return ({}); };\n\nvar underDampedSpring = function () { return ({\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10,\n}); };\nvar overDampedSpring = function (to) { return ({\n    type: \"spring\",\n    stiffness: 700,\n    damping: to === 0 ? 100 : 35,\n}); };\nvar linearTween = function () { return ({\n    ease: \"linear\",\n    duration: 0.3,\n}); };\nvar keyframes = function (values) { return ({\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: overDampedSpring,\n    scaleY: overDampedSpring,\n    scale: overDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: overDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return __assign({ to: to }, transitionFactory(to));\n};\n\n/**\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\n * updates with `to` and then completes. By using this we can compose instant transitions\n * in with the same logic that applies `delay` or returns a `Promise` etc.\n *\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\n * the animation until after the duration finishes. This is for situations when you're **only**\n * animating non-animatable values and then setting something on `transitionEnd`. Really\n * you want this to fire after the \"animation\" finishes, rather than instantly.\n *\n * ```\n * animate={{\n *   display: 'block',\n *   transitionEnd: { display: 'none' }\n * }}\n * ```\n */\nvar just = function (_a) {\n    var to = _a.to, duration = _a.duration;\n    return action(function (_a) {\n        var update = _a.update, complete = _a.complete;\n        update(to);\n        duration ? delay(duration).start({ complete: complete }) : complete();\n    });\n};\n\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var x1 = definition[0], y1 = definition[1], x2 = definition[2], y2 = definition[3];\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nvar isDurationAnimation = function (v) {\n    return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar transitions = { tween: tween, spring: spring, keyframes: keyframes$1, inertia: inertia, just: just };\nvar transitionOptionParser = {\n    tween: function (opts) {\n        if (opts.ease) {\n            var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\n            opts.ease = easingDefinitionToFunction(ease);\n        }\n        return opts;\n    },\n    keyframes: function (_a) {\n        var from = _a.from, to = _a.to, velocity = _a.velocity, opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\n        if (opts.values && opts.values[0] === null) {\n            var values = __spreadArrays(opts.values);\n            values[0] = from;\n            opts.values = values;\n        }\n        if (opts.ease) {\n            opts.easings = isEasingArray(opts.ease)\n                ? opts.ease.map(easingDefinitionToFunction)\n                : easingDefinitionToFunction(opts.ease);\n        }\n        opts.ease = linear;\n        return opts;\n    },\n};\nvar isTransitionDefined = function (_a) {\n    var when = _a.when, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\n    return Object.keys(transition).length;\n};\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\n    var delay = transitionDefinition ? transitionDefinition.delay : 0;\n    // If no object, return default transition\n    // A better way to handle this would be to deconstruct out all the shared Orchestration props\n    // and see if there's any props remaining\n    if (transitionDefinition === undefined ||\n        !isTransitionDefined(transitionDefinition)) {\n        return __assign({ delay: delay }, getDefaultTransition(key, to));\n    }\n    var valueTransitionDefinition = transitionDefinition[key] ||\n        transitionDefinition.default ||\n        transitionDefinition;\n    if (valueTransitionDefinition.type === false) {\n        return {\n            delay: valueTransitionDefinition.hasOwnProperty(\"delay\")\n                ? valueTransitionDefinition.delay\n                : delay,\n            to: isKeyframesTarget(to)\n                ? to[to.length - 1]\n                : to,\n            type: \"just\",\n        };\n    }\n    else if (isKeyframesTarget(to)) {\n        return __assign(__assign({ values: to, duration: 0.8, delay: delay, ease: \"linear\" }, valueTransitionDefinition), { \n            // This animation must be keyframes if we're animating through an array\n            type: \"keyframes\" });\n    }\n    else {\n        return __assign({ type: \"tween\", to: to,\n            delay: delay }, valueTransitionDefinition);\n    }\n};\nvar preprocessOptions = function (type, opts) {\n    return transitionOptionParser[type]\n        ? transitionOptionParser[type](opts)\n        : opts;\n};\nvar getAnimation = function (key, value, target, transition) {\n    var origin = value.get();\n    var isOriginAnimatable = isAnimatable(key, origin);\n    var isTargetAnimatable = isAnimatable(key, target);\n    // TODO we could probably improve this check to ensure both values are of the same type -\n    // for instance 100 to #fff. This might live better in Popmotion.\n    warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n    // Parse the `transition` prop and return options for the Popmotion animation\n    var _a = getTransitionDefinition(key, target, transition), _b = _a.type, type = _b === void 0 ? \"tween\" : _b, transitionDefinition = __rest(_a, [\"type\"]);\n    // If this is an animatable pair of values, return an animation, otherwise use `just`\n    var actionFactory = isOriginAnimatable && isTargetAnimatable\n        ? transitions[type]\n        : just;\n    var opts = preprocessOptions(type, __assign({ from: origin, velocity: value.getVelocity() }, transitionDefinition));\n    // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\n    if (isDurationAnimation(opts)) {\n        if (opts.duration) {\n            opts.duration = secondsToMilliseconds(opts.duration);\n        }\n        if (opts.repeatDelay) {\n            opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\n        }\n    }\n    return [actionFactory, opts];\n};\n/**\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\n *\n * @internal\n */\nfunction startAnimation(key, value, target, _a) {\n    if (_a === void 0) { _a = {}; }\n    var _b = _a.delay, delay$1 = _b === void 0 ? 0 : _b, transition = __rest(_a, [\"delay\"]);\n    return value.start(function (complete) {\n        var activeAnimation;\n        var _a = getAnimation(key, value, target, transition), animationFactory = _a[0], _b = _a[1], valueDelay = _b.delay, options = __rest(_b, [\"delay\"]);\n        if (valueDelay !== undefined) {\n            delay$1 = valueDelay;\n        }\n        var animate = function () {\n            var animation = animationFactory(options);\n            // Bind animation opts to animation\n            activeAnimation = animation.start({\n                update: function (v) { return value.set(v); },\n                complete: complete,\n            });\n        };\n        // If we're delaying this animation, only resolve it **after** the delay to\n        // ensure the value's resolve velocity is up-to-date.\n        if (delay$1) {\n            activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\n                complete: animate,\n            });\n        }\n        else {\n            animate();\n        }\n        return function () {\n            if (activeAnimation)\n                activeAnimation.stop();\n        };\n    });\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\n\n/**\n * Get the current value of every `MotionValue` in a `VisualElement`\n */\nvar getCurrent = function (visualElement) {\n    var current = {};\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\n    return current;\n};\n/**\n * Get the current velocity of every `MotionValue` in a `VisualElement`\n */\nvar getVelocity = function (visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\n    return velocity;\n};\n/**\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\n * check, just helps with typing.\n */\nvar isTargetResolver = function (p) {\n    return typeof p === \"function\";\n};\n/**\n * Check if value is a list of variant labels\n */\nvar isVariantLabels = function (v) { return Array.isArray(v); };\n/**\n * Control animations for a single component\n *\n * @internal\n */\nvar VisualElementAnimationControls = /** @class */ (function () {\n    function VisualElementAnimationControls(visualElement, _a) {\n        var _this = this;\n        var makeTargetAnimatable = _a.makeTargetAnimatable;\n        /**\n         * A reference to the component's latest props. We could probably ditch this in\n         * favour to a reference to the `custom` prop now we don't send all props through\n         * to target resolvers.\n         */\n        this.props = {};\n        /**\n         * The component's variants, as provided by `variants`\n         */\n        this.variants = {};\n        /**\n         * A set of values that we animate back to when a value is cleared of all overrides.\n         */\n        this.baseTarget = {};\n        /**\n         * A series of target overrides that we can animate to/from when overrides are set/cleared.\n         */\n        this.overrides = [];\n        /**\n         * A series of target overrides as they were originally resolved.\n         */\n        this.resolvedOverrides = [];\n        /**\n         * A Set of currently active override indexes\n         */\n        this.activeOverrides = new Set();\n        /**\n         * A Set of value keys that are currently animating.\n         */\n        this.isAnimating = new Set();\n        /**\n         * Check if the associated `VisualElement` has a key with the provided string.\n         * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\n         */\n        this.hasValue = function (key) { return !_this.visualElement.hasValue(key); };\n        this.visualElement = visualElement;\n        this.makeTargetAnimatable = makeTargetAnimatable;\n        this.visualElement.forEachValue(function (value, key) { return (_this.baseTarget[key] = value.get()); });\n    }\n    /**\n     * Set the reference to the component's props.\n     * @param props -\n     */\n    VisualElementAnimationControls.prototype.setProps = function (props) {\n        this.props = props;\n    };\n    /**\n     * Set the reference to the component's variants\n     * @param variants -\n     */\n    VisualElementAnimationControls.prototype.setVariants = function (variants) {\n        if (variants)\n            this.variants = variants;\n    };\n    /**\n     * Set the component's default transition\n     * @param transition -\n     */\n    VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\n        if (transition)\n            this.defaultTransition = transition;\n    };\n    /**\n     * Set motion values without animation.\n     *\n     * @param definition -\n     * @param isActive -\n     */\n    VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.isActive, isActive = _c === void 0 ? new Set() : _c, priority = _b.priority;\n        var _d = this.resolveVariant(definition), target = _d.target, transitionEnd = _d.transitionEnd;\n        target = this.transformValues(__assign(__assign({}, target), transitionEnd));\n        for (var key in target) {\n            if (isActive.has(key))\n                return;\n            isActive.add(key);\n            if (target) {\n                var targetValue = resolveFinalValueInKeyframes(target[key]);\n                if (this.visualElement.hasValue(key)) {\n                    var value = this.visualElement.getValue(key);\n                    value && value.set(targetValue);\n                }\n                else {\n                    this.visualElement.addValue(key, motionValue(targetValue));\n                }\n                if (!priority)\n                    this.baseTarget[key] = targetValue;\n            }\n        }\n    };\n    /**\n     * Allows `transformValues` to be set by a component that allows us to\n     * transform the values in a given `Target`. This allows Framer Library\n     * to extend Framer Motion to animate `Color` variables etc. Currently we have\n     * to manually support these extended types here in Framer Motion.\n     *\n     * @param values -\n     */\n    VisualElementAnimationControls.prototype.transformValues = function (values) {\n        var transformValues = this.props.transformValues;\n        return transformValues ? transformValues(values) : values;\n    };\n    /**\n     * Check a `Target` for new values we haven't animated yet, and add them\n     * to the `MotionValueMap`.\n     *\n     * Currently there's functionality here that is DOM-specific, we should allow\n     * this functionality to be injected by the factory that creates DOM-specific\n     * components.\n     *\n     * @param target -\n     */\n    VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\n        var newValueKeys = Object.keys(target).filter(this.hasValue);\n        var numNewValues = newValueKeys.length;\n        if (!numNewValues)\n            return;\n        for (var i = 0; i < numNewValues; i++) {\n            var key = newValueKeys[i];\n            var targetValue = target[key];\n            var value = null;\n            // If this is a keyframes value, we can attempt to use the first value in the\n            // array as that's going to be the first value of the animation anyway\n            if (Array.isArray(targetValue)) {\n                value = targetValue[0];\n            }\n            // If it isn't a keyframes or the first keyframes value was set as `null`, read the\n            // value from the DOM. It might be worth investigating whether to check props (for SVG)\n            // or props.style (for HTML) if the value exists there before attempting to read.\n            if (value === null) {\n                value = this.visualElement.readNativeValue(key);\n                invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\n            }\n            if (typeof value === \"string\" && isNumericalString(value)) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(targetValue)) {\n                // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n                value = complex.getAnimatableNone(targetValue);\n            }\n            this.visualElement.addValue(key, motionValue(value));\n            this.baseTarget[key] = value;\n        }\n    };\n    /**\n     * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\n     * @param variant -\n     */\n    VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\n        if (!variant) {\n            return {\n                target: undefined,\n                transition: undefined,\n                transitionEnd: undefined,\n            };\n        }\n        if (isTargetResolver(variant)) {\n            // resolve current and velocity\n            variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\n        }\n        var _a = variant.transition, transition = _a === void 0 ? this.defaultTransition : _a, transitionEnd = variant.transitionEnd, target = __rest(variant, [\"transition\", \"transitionEnd\"]);\n        return { transition: transition, transitionEnd: transitionEnd, target: target };\n    };\n    /**\n     * Get the highest active override priority index\n     */\n    VisualElementAnimationControls.prototype.getHighestPriority = function () {\n        if (!this.activeOverrides.size)\n            return 0;\n        return Math.max.apply(Math, Array.from(this.activeOverrides));\n    };\n    /**\n     * Set an override. We add this layer of indirection so if, for instance, a tap gesture\n     * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\n     * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\n     * than the one that was resolved when the hover gesture animation started.\n     *\n     * @param definition -\n     * @param overrideIndex -\n     */\n    VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\n        this.overrides[overrideIndex] = definition;\n        if (this.children) {\n            this.children.forEach(function (child) {\n                return child.setOverride(definition, overrideIndex);\n            });\n        }\n    };\n    /**\n     * Start an override animation.\n     * @param overrideIndex -\n     */\n    VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\n        var override = this.overrides[overrideIndex];\n        if (override) {\n            return this.start(override, { priority: overrideIndex });\n        }\n    };\n    /**\n     * Clear an override. We check every value we animated to in this override to see if\n     * its present on any lower-priority overrides. If not, we animate it back to its base target.\n     * @param overrideIndex -\n     */\n    VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\n        var _this = this;\n        if (this.children) {\n            this.children.forEach(function (child) { return child.clearOverride(overrideIndex); });\n        }\n        var override = this.overrides[overrideIndex];\n        if (!override)\n            return;\n        this.activeOverrides.delete(overrideIndex);\n        var highest = this.getHighestPriority();\n        this.resetIsAnimating();\n        if (highest) {\n            var highestOverride = this.overrides[highest];\n            highestOverride && this.startOverride(highest);\n        }\n        // Figure out which remaining values were affected by the override and animate those\n        var overrideTarget = this.resolvedOverrides[overrideIndex];\n        if (!overrideTarget)\n            return;\n        var remainingValues = {};\n        for (var key in this.baseTarget) {\n            if (overrideTarget[key] !== undefined) {\n                remainingValues[key] = this.baseTarget[key];\n            }\n        }\n        this.onStart();\n        this.animate(remainingValues).then(function () { return _this.onComplete(); });\n    };\n    /**\n     * Apply a target/variant without any animation\n     */\n    VisualElementAnimationControls.prototype.apply = function (definition) {\n        if (Array.isArray(definition)) {\n            return this.applyVariantLabels(definition);\n        }\n        else if (typeof definition === \"string\") {\n            return this.applyVariantLabels([definition]);\n        }\n        else {\n            this.setValues(definition);\n        }\n    };\n    /**\n     * Apply variant labels without animation\n     */\n    VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\n        var _this = this;\n        var isActive = new Set();\n        var reversedList = __spreadArrays(variantLabelList).reverse();\n        reversedList.forEach(function (key) {\n            var _a = _this.resolveVariant(_this.variants[key]), target = _a.target, transitionEnd = _a.transitionEnd;\n            if (transitionEnd) {\n                _this.setValues(transitionEnd, { isActive: isActive });\n            }\n            if (target) {\n                _this.setValues(target, { isActive: isActive });\n            }\n            if (_this.children && _this.children.size) {\n                _this.children.forEach(function (child) {\n                    return child.applyVariantLabels(variantLabelList);\n                });\n            }\n        });\n    };\n    VisualElementAnimationControls.prototype.start = function (definition, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        if (opts.priority) {\n            this.activeOverrides.add(opts.priority);\n        }\n        this.resetIsAnimating(opts.priority);\n        var animation;\n        if (isVariantLabels(definition)) {\n            animation = this.animateVariantLabels(definition, opts);\n        }\n        else if (typeof definition === \"string\") {\n            animation = this.animateVariant(definition, opts);\n        }\n        else {\n            animation = this.animate(definition, opts);\n        }\n        this.onStart();\n        return animation.then(function () { return _this.onComplete(); });\n    };\n    VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.delay, delay = _c === void 0 ? 0 : _c, _d = _b.priority, priority = _d === void 0 ? 0 : _d, transitionOverride = _b.transitionOverride;\n        var _e = this.resolveVariant(animationDefinition), target = _e.target, transition = _e.transition, transitionEnd = _e.transitionEnd;\n        if (transitionOverride) {\n            transition = transitionOverride;\n        }\n        if (!target)\n            return Promise.resolve();\n        target = this.transformValues(target);\n        if (transitionEnd) {\n            transitionEnd = this.transformValues(transitionEnd);\n        }\n        this.checkForNewValues(target);\n        var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\n        if (this.makeTargetAnimatable) {\n            var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\n            target = animatable.target;\n            transitionEnd = animatable.transitionEnd;\n        }\n        if (priority) {\n            this.resolvedOverrides[priority] = target;\n        }\n        this.checkForNewValues(target);\n        var animations = [];\n        for (var key in target) {\n            var value = this.visualElement.getValue(key);\n            if (!value || !target || target[key] === undefined)\n                continue;\n            var valueTarget = target[key];\n            if (!priority) {\n                this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\n            }\n            if (this.isAnimating.has(key))\n                continue;\n            this.isAnimating.add(key);\n            animations.push(startAnimation(key, value, valueTarget, __assign({ delay: delay }, transition)));\n        }\n        var allAnimations = Promise.all(animations);\n        return transitionEnd\n            ? allAnimations.then(function () {\n                _this.setValues(transitionEnd, { priority: priority });\n            })\n            : allAnimations;\n    };\n    VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\n        var _this = this;\n        var animations = __spreadArrays(variantLabels).reverse()\n            .map(function (label) { return _this.animateVariant(label, opts); });\n        return Promise.all(animations);\n    };\n    VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\n        var _this = this;\n        var when = false;\n        var delayChildren = 0;\n        var staggerChildren = 0;\n        var staggerDirection = 1;\n        var priority = (opts && opts.priority) || 0;\n        var variant = this.variants[variantLabel];\n        var getAnimations = variant\n            ? function () { return _this.animate(variant, opts); }\n            : function () { return Promise.resolve(); };\n        var getChildrenAnimations = this.children\n            ? function () {\n                return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\n            }\n            : function () { return Promise.resolve(); };\n        if (variant && this.children) {\n            var transition = this.resolveVariant(variant).transition;\n            if (transition) {\n                when = transition.when || when;\n                delayChildren = transition.delayChildren || delayChildren;\n                staggerChildren = transition.staggerChildren || staggerChildren;\n                staggerDirection =\n                    transition.staggerDirection || staggerDirection;\n            }\n        }\n        if (when) {\n            var _a = when === \"beforeChildren\"\n                ? [getAnimations, getChildrenAnimations]\n                : [getChildrenAnimations, getAnimations], first = _a[0], last = _a[1];\n            return first().then(last);\n        }\n        else {\n            return Promise.all([getAnimations(), getChildrenAnimations()]);\n        }\n    };\n    VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\n        if (delayChildren === void 0) { delayChildren = 0; }\n        if (staggerChildren === void 0) { staggerChildren = 0; }\n        if (staggerDirection === void 0) { staggerDirection = 1; }\n        if (priority === void 0) { priority = 0; }\n        if (!this.children) {\n            return Promise.resolve();\n        }\n        var animations = [];\n        var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\n        var generateStaggerDuration = staggerDirection === 1\n            ? function (i) { return i * staggerChildren; }\n            : function (i) { return maxStaggerDuration - i * staggerChildren; };\n        Array.from(this.children).forEach(function (childControls, i) {\n            var animation = childControls.animateVariant(variantLabel, {\n                priority: priority,\n                delay: delayChildren + generateStaggerDuration(i),\n            });\n            animations.push(animation);\n        });\n        return Promise.all(animations);\n    };\n    VisualElementAnimationControls.prototype.onStart = function () {\n        var onAnimationStart = this.props.onAnimationStart;\n        onAnimationStart && onAnimationStart();\n    };\n    VisualElementAnimationControls.prototype.onComplete = function () {\n        var onAnimationComplete = this.props.onAnimationComplete;\n        onAnimationComplete && onAnimationComplete();\n    };\n    VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\n        var numOverrides = this.overrides.length;\n        for (var i = priority + 1; i < numOverrides; i++) {\n            var resolvedOverride = this.resolvedOverrides[i];\n            if (resolvedOverride) {\n                for (var key in resolvedOverride) {\n                    this.isAnimating.add(key);\n                }\n            }\n        }\n    };\n    VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\n        if (priority === void 0) { priority = 0; }\n        this.isAnimating.clear();\n        // If this isn't the highest priority gesture, block the animation\n        // of anything that's currently being animated\n        if (priority < this.getHighestPriority()) {\n            this.checkOverrideIsAnimating(priority);\n        }\n        if (this.children) {\n            this.children.forEach(function (child) { return child.resetIsAnimating(priority); });\n        }\n    };\n    VisualElementAnimationControls.prototype.stop = function () {\n        this.visualElement.forEachValue(function (value) { return value.stop(); });\n    };\n    /**\n     * Add the controls of a child component.\n     * @param controls -\n     */\n    VisualElementAnimationControls.prototype.addChild = function (controls) {\n        if (!this.children) {\n            this.children = new Set();\n        }\n        this.children.add(controls);\n        // We set child overrides when `setOverride` is called, but also have to do it here\n        // as the first time `setOverride` is called all the children might not have been added yet.\n        this.overrides.forEach(function (override, i) {\n            override && controls.setOverride(override, i);\n        });\n    };\n    VisualElementAnimationControls.prototype.removeChild = function (controls) {\n        if (!this.children) {\n            return;\n        }\n        this.children.delete(controls);\n    };\n    VisualElementAnimationControls.prototype.resetChildren = function () {\n        if (this.children)\n            this.children.clear();\n    };\n    return VisualElementAnimationControls;\n}());\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] = (_a = getOriginFromTransition(key, transition), (_a !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get()));\n    }\n    return origin;\n}\n\n/**\n * Creates an imperative set of controls to trigger animations.\n *\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\n *\n * @internal\n */\nfunction useVisualElementAnimation(visualElement, props, config) {\n    var subscribeToParentControls = checkShouldInheritVariant(props);\n    var variants = props.variants, transition = props.transition;\n    var parentControls = useContext(MotionContext).controls;\n    var presenceContext = useContext(PresenceContext);\n    var controls = useConstant(function () { return new VisualElementAnimationControls(visualElement, config); });\n    // Reset and resubscribe children every render to ensure stagger order is correct\n    if (!presenceContext || presenceContext.isPresent) {\n        controls.resetChildren();\n        controls.setProps(props);\n        controls.setVariants(variants);\n        controls.setDefaultTransition(transition);\n    }\n    // We have to subscribe to the parent controls within a useEffect rather than during render,\n    // as\n    useEffect(function () {\n        if (subscribeToParentControls && parentControls) {\n            parentControls.addChild(controls);\n        }\n    });\n    useEffect(function () {\n        return function () {\n            // Remove reference to onAnimationComplete from controls. All the MotionValues\n            // are unsubscribed from this component separately. We let animations run out\n            // as they might be animating other components.\n            var onAnimationComplete = props.onAnimationComplete, unmountProps = __rest(props, [\"onAnimationComplete\"]);\n            controls.setProps(unmountProps);\n            parentControls && parentControls.removeChild(controls);\n        };\n    }, []);\n    return controls;\n}\n\n/**\n * @internal\n */\nvar MotionPluginContext = createContext({\n    transformPagePoint: function (p) { return p; },\n    autoValues: {},\n    features: [],\n});\n/**\n * @remarks For now I think this should remain a private API for our own use\n * until we can figure out a nicer way of allowing people to add these\n *\n * @internal\n */\nfunction MotionPlugins(_a) {\n    var children = _a.children, props = __rest(_a, [\"children\"]);\n    var pluginContext = useContext(MotionPluginContext);\n    var value = useRef(__assign({}, pluginContext)).current;\n    // Mutative to prevent triggering rerenders in all listening\n    // components every time this component renders\n    for (var key in props) {\n        value[key] = props[key];\n    }\n    return (createElement(MotionPluginContext.Provider, { value: value }, children));\n}\n\n/**\n * @internal\n */\nvar SharedLayoutContext = createContext(batchTransitions());\n\nvar Presence;\n(function (Presence) {\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\nvar VisibilityAction;\n(function (VisibilityAction) {\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\nvar StackPosition;\n(function (StackPosition) {\n    StackPosition[StackPosition[\"Lead\"] = 0] = \"Lead\";\n    StackPosition[StackPosition[\"Previous\"] = 1] = \"Previous\";\n})(StackPosition || (StackPosition = {}));\n\nvar session = null;\nvar syncRenderSession = {\n    isOpen: function () { return session !== null; },\n    open: function () {\n        invariant(!session, \"Sync render session already open\");\n        session = [];\n    },\n    flush: function () {\n        invariant(session !== null, \"No sync render session found\");\n        session && session.forEach(function (view) { return view.render(); });\n        session = null;\n    },\n    push: function (view) {\n        invariant(session !== null, \"No sync render session found\");\n        session && session.push(view);\n    },\n};\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n    var context = useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // Context will never change without full re-renders so it's safe to call this hook conditionally\n    useEffect(register, []);\n    return !isPresent && onExitComplete ? [false, onExitComplete] : [true];\n}\n/**\n * @public\n */\nfunction useIsPresent() {\n    var context = useContext(PresenceContext);\n    return context === null ? true : context.isPresent;\n}\n\nfunction convertSingleRadius(value, axis) {\n    var parsed = parseFloat(value);\n    if (px.test(value)) {\n        return parsed;\n    }\n    else {\n        var factor = parsed / 100;\n        return factor * (axis.max - axis.min);\n    }\n}\nfunction radiusAsPixels(value, box) {\n    var _a = value.split(\" \"), x = _a[0], y = _a[1];\n    return {\n        x: convertSingleRadius(x, box.x),\n        y: convertSingleRadius(y || x, box.y),\n    };\n}\nvar singleBorderRadius = function (key) { return ({\n    reset: function (style) {\n        return style.borderRadius !== undefined ? style.borderRadius : \"\";\n    },\n    createUpdater: function (visualElement, origin, target, current, delta, treeScale, originBox, targetBox) {\n        if (!origin && !target)\n            return;\n        var motionValue = visualElement.getValue(key, \"\");\n        var originAsPixels = radiusAsPixels(origin, originBox);\n        var targetAsPixels = radiusAsPixels(target, targetBox);\n        return function (p) {\n            var vx = mix(originAsPixels.x, targetAsPixels.x, p);\n            var vy = mix(originAsPixels.y, targetAsPixels.y, p);\n            current[key] = vx + \"px \" + vy + \"px\";\n            var targetX = vx / delta.x.scale / treeScale.x;\n            var targetY = vy / delta.y.scale / treeScale.y;\n            // Perform the animation in pixels but if we don't need correction just set\n            // to the target so percentages have an affect going forward\n            var latest = p === 1 &&\n                delta.x.scale / treeScale.x / delta.y.scale / treeScale.y === 1\n                ? target\n                : targetX + \"px \" + targetY + \"px\";\n            motionValue.set(latest);\n        };\n    },\n}); };\nvar defaultMagicValues = {\n    backgroundColor: {\n        reset: function (style) {\n            return style.background !== undefined ? style.background : \"\";\n        },\n    },\n    borderRadius: {\n        read: false,\n    },\n    borderTopLeftRadius: singleBorderRadius(\"borderTopLeftRadius\"),\n    borderTopRightRadius: singleBorderRadius(\"borderTopRightRadius\"),\n    borderBottomLeftRadius: singleBorderRadius(\"borderBottomLeftRadius\"),\n    borderBottomRightRadius: singleBorderRadius(\"borderBottomRightRadius\"),\n    boxShadow: {\n        createUpdater: function (visualElement, origin, target, current, delta, treeScale) {\n            if (isEmptyBoxShadow(origin) && isEmptyBoxShadow(target)) {\n                return;\n            }\n            var originShadow = getAnimatableShadow(origin, target);\n            var targetShadow = getAnimatableShadow(target, origin);\n            var currentShadow = __spreadArrays(originShadow);\n            var mixShadowColor = mixColor(originShadow[0], currentShadow[0]);\n            var shadowTemplate = complex.createTransformer(target !== \"none\" ? target : origin);\n            var dx = delta.x;\n            var dy = delta.y;\n            var boxShadow = visualElement.getValue(\"boxShadow\", \"\");\n            return function (p) {\n                // Update box shadow\n                currentShadow[0] = mixShadowColor(p); // color\n                currentShadow[1] = mix(originShadow[1], targetShadow[1], p); // x\n                currentShadow[2] = mix(originShadow[2], targetShadow[2], p); // y\n                currentShadow[3] = mix(originShadow[3], targetShadow[3], p); // blur\n                currentShadow[4] = mix(originShadow[4], targetShadow[4], p); // spread\n                // Update prev box shadow before FLIPPing\n                current.boxShadow = shadowTemplate(currentShadow);\n                // Apply FLIP inversion to physical dimensions. We need to take an average scale for XY to apply\n                // to blur and spread, which affect both axis equally.\n                currentShadow[1] = currentShadow[1] / dx.scale / treeScale.x;\n                currentShadow[2] = currentShadow[2] / dy.scale / treeScale.y;\n                var averageXYScale = mix(dx.scale, dy.scale, 0.5);\n                var averageTreeXTScale = mix(treeScale.x, treeScale.y, 0.5);\n                currentShadow[3] =\n                    currentShadow[3] / averageXYScale / averageTreeXTScale; // blur\n                currentShadow[4] =\n                    currentShadow[4] / averageXYScale / averageTreeXTScale; // spread\n                boxShadow.set(shadowTemplate(currentShadow));\n            };\n        },\n    },\n    color: {},\n    opacity: {\n        read: function (opacity) { return (opacity !== null ? parseFloat(opacity) : 0); },\n    },\n};\nfunction getAnimatableShadow(shadow, fallback) {\n    if (shadow === \"none\") {\n        shadow = complex.getAnimatableNone(fallback);\n    }\n    return complex.parse(shadow);\n}\nfunction isEmptyBoxShadow(shadow) {\n    return !shadow || shadow === \"none\";\n}\n\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\n\nvar isViewportScrollBlocked = false;\nvar isBrowser = typeof window !== \"undefined\";\nif (isBrowser) {\n    document.addEventListener(\"touchmove\", function (event) {\n        if (isViewportScrollBlocked) {\n            event.preventDefault();\n        }\n    }, { passive: false });\n}\nvar blockViewportScroll = function () { return (isViewportScrollBlocked = true); };\nvar unblockViewportScroll = function () { return (isViewportScrollBlocked = false); };\n\nfunction addDomEvent(target, eventName, handler, options) {\n    if (!handler)\n        return;\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler, options); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    useEffect(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    if (!eventHandler)\n        return undefined;\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e) {\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var _a = primaryTouch || defaultPagePoint, pageX = _a.pageX, pageY = _a.pageY;\n    return { x: pageX, y: pageY };\n}\nfunction pointFromMouse(_a) {\n    var _b = _a.pageX, pageX = _b === void 0 ? 0 : _b, _c = _a.pageY, pageY = _c === void 0 ? 0 : _c;\n    return { x: pageX, y: pageY };\n}\nfunction extractEventInfo(event) {\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event)\n            : pointFromMouse(event),\n    };\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    if (!handler)\n        return;\n    var listener = function (event) { return handler(event, extractEventInfo(event)); };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\nvar isBrowser$1 = typeof window !== \"undefined\";\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser$1 && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser$1 && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser$1 && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\",\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\n/** @public */\nvar Point;\n(function (Point) {\n    /** @beta */\n    Point.subtract = function (a, b) {\n        return { x: a.x - b.x, y: a.y - b.y };\n    };\n    /** @beta */\n    Point.relativeTo = function (idOrElem) {\n        var elem;\n        var getElem = function () {\n            // Caching element here could be leaky because of React lifecycle\n            if (elem !== undefined)\n                return elem;\n            if (typeof idOrElem === \"string\") {\n                elem = document.getElementById(idOrElem);\n            }\n            else {\n                elem = idOrElem;\n            }\n            return elem;\n        };\n        return function (_a) {\n            var x = _a.x, y = _a.y;\n            var localElem = getElem();\n            if (!localElem)\n                return undefined;\n            var rect = localElem.getBoundingClientRect();\n            return {\n                x: x - rect.left - window.scrollX,\n                y: y - rect.top - window.scrollY,\n            };\n        };\n    };\n})(Point || (Point = {}));\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) { return _this.handlePointerMove(event, info); });\n        var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) { return _this.handlePointerUp(event, info); });\n        this.removeListeners = function () {\n            removeOnPointerMove && removeOnPointerMove();\n            removeOnPointerUp && removeOnPointerUp();\n        };\n    }\n    PanSession.prototype.handlePointerMove = function (event, info) {\n        this.lastMoveEvent = event;\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n        // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n        if (isMouseEvent(event) && event.buttons === 0) {\n            this.handlePointerUp(event, info);\n            return;\n        }\n        // Throttle mouse move event to once per frame\n        sync.update(this.updatePoint, true);\n    };\n    PanSession.prototype.handlePointerUp = function (event, info) {\n        this.end();\n        var onEnd = this.handlers.onEnd;\n        if (!onEnd)\n            return;\n        var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n        onEnd && onEnd(event, panInfo);\n    };\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n        unblockViewportScroll();\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: Point.subtract(point, lastDevicePoint(history)),\n        offset: Point.subtract(point, startDevicePoint(history)),\n        velocity: getVelocity$1(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity$1(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nvar elementDragControls = new WeakMap();\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement, controls = _a.controls;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * References to the MotionValues used for tracking the current dragged point.\n         *\n         * @internal\n         */\n        this.point = {};\n        /**\n         * The origin point for the current drag gesture.\n         *\n         * @internal\n         */\n        this.origin = {\n            x: motionValue(0),\n            y: motionValue(0),\n        };\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.prev = {\n            x: 0,\n            y: 0,\n        };\n        this.visualElement = visualElement;\n        this.controls = controls;\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Start dragging the host component.\n     *\n     * @param event - The originating pointer event.\n     * @param options -\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = (_a === void 0 ? {} : _a).snapToCursor, snapToCursor = _b === void 0 ? false : _b;\n        snapToCursor && this.snapToCursor(originEvent);\n        var onSessionStart = function () {\n            // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\n            // which has come out of the difficulty in us being able to do this once a scroll gesture\n            // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\n            // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\n            // trigger this once we've got a scroll direction determined. This approach sort-of worked\n            // but if the component was dragged too far in a single frame page scrolling would initiate.\n            blockViewportScroll();\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n        };\n        var onStart = function (event, info) {\n            // If constraints are an element, resolve them again in case they've updated.\n            _this.resolveDragConstraints();\n            // Set point origin and stop any existing animations.\n            bothAxis(function (axis) {\n                var axisPoint = _this.point[axis];\n                if (!axisPoint)\n                    return;\n                _this.origin[axis].set(axisPoint.get());\n            });\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _a = _this.props, drag = _a.drag, dragPropagation = _a.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            var onDragStart = _this.props.onDragStart;\n            onDragStart &&\n                onDragStart(event, convertPanToDrag(info, _this.point));\n        };\n        var onMove = function (event, info) {\n            var _a = _this.props, dragPropagation = _a.dragPropagation, dragDirectionLock = _a.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    var onDirectionLock = _this.props.onDirectionLock;\n                    onDirectionLock && onDirectionLock(_this.currentDirection);\n                }\n                return;\n            }\n            _this.updatePoint(\"x\", offset);\n            _this.updatePoint(\"y\", offset);\n            var onDrag = _this.props.onDrag;\n            onDrag && onDrag(event, convertPanToDrag(info, _this.point));\n        };\n        var onEnd = function (event, info) {\n            _this.stop(event, info);\n        };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onEnd: onEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        if (!this.constraintsNeedResolution)\n            return;\n        var _a = this.props, dragConstraints = _a.dragConstraints, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = dragConstraints\n            .current;\n        this.constraints = calculateConstraintsFromDom(constraintsElement, this.visualElement.getInstance(), this.point, transformPagePoint);\n        if (onMeasureDragConstraints) {\n            var constraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(this.constraints));\n            if (constraints)\n                this.constraints = convertBoundingBoxToAxisBox(constraints);\n        }\n        this.applyConstraintsToPoint();\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        unblockViewportScroll();\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a;\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var _b = this.props, dragMomentum = _b.dragMomentum, dragElastic = _b.dragElastic, onDragEnd = _b.onDragEnd;\n        if (dragMomentum || dragElastic) {\n            var velocity = info.velocity;\n            this.animateDragEnd(velocity);\n        }\n        else {\n            this.recordBoxInfo(this.constraints);\n        }\n        onDragEnd && onDragEnd(event, convertPanToDrag(info, this.point));\n    };\n    VisualElementDragControls.prototype.recordBoxInfo = function (constraints) {\n        if (constraints)\n            this.prevConstraints = constraints;\n        if (this.point.x)\n            this.prev.x = this.point.x.get();\n        if (this.point.y)\n            this.prev.y = this.point.y.get();\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (event) {\n        var _this = this;\n        var transformPagePoint = this.props.transformPagePoint;\n        var point = extractEventInfo(event).point;\n        var boundingBox = getBoundingBox(this.visualElement.getInstance(), transformPagePoint);\n        var center = {\n            x: calcAxisCenter(boundingBox.x) + window.scrollX,\n            y: calcAxisCenter(boundingBox.y) + window.scrollY,\n        };\n        var offset = {\n            x: point.x - center.x,\n            y: point.y - center.y,\n        };\n        bothAxis(function (axis) {\n            var axisPoint = _this.point[axis];\n            if (!axisPoint)\n                return;\n            _this.origin[axis].set(axisPoint.get());\n        });\n        this.updatePoint(\"x\", offset);\n        this.updatePoint(\"y\", offset);\n    };\n    VisualElementDragControls.prototype.setPoint = function (axis, value) {\n        this.point[axis] = value;\n    };\n    VisualElementDragControls.prototype.updatePoint = function (axis, offset) {\n        var _a = this.props, drag = _a.drag, dragElastic = _a.dragElastic;\n        var axisPoint = this.point[axis];\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection) || !axisPoint)\n            return;\n        var current = applyConstraints(axis, this.origin[axis].get() + offset[axis], this.constraints, dragElastic);\n        axisPoint.set(current);\n    };\n    VisualElementDragControls.prototype.updateProps = function (_a) {\n        var _this = this;\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? true : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = __assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n        var _dragValueX = remainingProps._dragValueX, _dragValueY = remainingProps._dragValueY, dragOriginX = remainingProps.dragOriginX, dragOriginY = remainingProps.dragOriginY;\n        if (dragOriginX)\n            this.origin.x = dragOriginX;\n        if (dragOriginY)\n            this.origin.y = dragOriginY;\n        // Get the `MotionValue` for both draggable axes, or create them if they don't already\n        // exist on this component.\n        bothAxis(function (axis) {\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var defaultValue = axis === \"x\" ? _dragValueX : _dragValueY;\n            _this.setPoint(axis, defaultValue || _this.visualElement.getValue(axis, 0));\n        });\n        // If `dragConstraints` is a React `ref`, we should resolve the constraints once the\n        // component has rendered.\n        this.constraintsNeedResolution = isRefObject(dragConstraints);\n        if (this.constraintsNeedResolution) {\n            this.constraints = this.constraints || false;\n        }\n        else {\n            this.constraints =\n                dragConstraints && dragConstraints !== false\n                    ? convertBoundingBoxToAxisBox(dragConstraints)\n                    : false;\n        }\n    };\n    VisualElementDragControls.prototype.applyConstraintsToPoint = function () {\n        var _this = this;\n        return bothAxis(function (axis) {\n            var axisPoint = _this.point[axis];\n            axisPoint &&\n                !axisPoint.isAnimating() &&\n                applyConstraints(axis, axisPoint, _this.constraints, 0);\n        });\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, _dragValueX = _a._dragValueX, _dragValueY = _a._dragValueY, _dragTransitionControls = _a._dragTransitionControls;\n        var momentumAnimations = bothAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = _this.constraints ? _this.constraints[axis] : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var animationControls = _dragTransitionControls || _this.controls;\n            var inertia = __assign(__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1 }, dragTransition), transition);\n            var externalAxisMotionValue = axis === \"x\" ? _dragValueX : _dragValueY;\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return externalAxisMotionValue\n                ? startAnimation(axis, externalAxisMotionValue, 0, inertia)\n                : animationControls.start((_a = {},\n                    _a[axis] = 0,\n                    _a.transition = inertia,\n                    _a));\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            _this.recordBoxInfo(_this.constraints);\n            _this.scalePoint();\n            var onDragTransitionEnd = _this.props.onDragTransitionEnd;\n            onDragTransitionEnd && onDragTransitionEnd();\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        var _this = this;\n        bothAxis(function (axis) {\n            var axisPoint = _this.point[axis];\n            axisPoint && axisPoint.stop();\n        });\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, dragConstraints = _a.dragConstraints, transformPagePoint = _a.transformPagePoint;\n        if (!isRefObject(dragConstraints))\n            return;\n        var constraintsBox = getBoundingBox(dragConstraints.current, transformPagePoint);\n        var draggableBox = getBoundingBox(this.visualElement.getInstance(), transformPagePoint);\n        // Scale a point relative to the transformation of a constraints-providing element.\n        var scaleAxisPoint = function (axis) {\n            var pointToScale = _this.point[axis];\n            if (!pointToScale)\n                return;\n            // Stop any current animations as they bug out if you resize during one\n            if (pointToScale.isAnimating()) {\n                pointToScale.stop();\n                _this.recordBoxInfo();\n                return;\n            }\n            // If the previous dimension was `0` (default), set `scale` to `1` to prevent\n            // divide by zero errors.\n            var _a = _this.prevConstraints[axis], min = _a.min, max = _a.max;\n            var width = max - min;\n            var constraintsWidth = constraintsBox[axis].max - constraintsBox[axis].min;\n            var draggableWidth = draggableBox[axis].max - draggableBox[axis].min;\n            var scale = width\n                ? (constraintsWidth - draggableWidth) / width\n                : 1;\n            pointToScale.set(_this.prev[axis] * Math.abs(scale));\n        };\n        scaleAxisPoint(\"x\");\n        scaleAxisPoint(\"y\");\n    };\n    VisualElementDragControls.prototype.mount = function (element) {\n        var _this = this;\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            return _this.scalePoint();\n        });\n        if (this.constraintsNeedResolution) {\n            this.resolveDragConstraints();\n            this.recordBoxInfo(this.constraints);\n        }\n        else if (!this.isDragging && this.constraints) {\n            this.applyConstraintsToPoint();\n        }\n        return function () {\n            stopPointerListener && stopPointerListener();\n            stopResizeListener && stopResizeListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\n// Call a handler once for each axis\nfunction bothAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\nfunction convertPanToDrag(info, point) {\n    return __assign(__assign({}, info), { point: {\n            x: point.x ? point.x.get() : 0,\n            y: point.y ? point.y.get() : 0,\n        } });\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n/**\n * Takes a parent Element and a draggable Element and returns pixel-based drag constraints.\n *\n * @param constraintsRef\n * @param draggableRef\n */\nfunction calculateConstraintsFromDom(constraintsElement, draggableElement, _point, // TODO: Remove this argument if we keep transform reset\ntransformPagePoint) {\n    invariant(constraintsElement !== null && draggableElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    var parentBoundingBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var draggableTransform = draggableElement.style.transform;\n    draggableElement.style.transform = \"none\";\n    var draggableBoundingBox = getBoundingBox(draggableElement, transformPagePoint);\n    draggableElement.style.transform = draggableTransform;\n    return calculateConstraints(parentBoundingBox, draggableBoundingBox);\n}\nfunction calculateAxisConstraints(parentAxis, draggableAxis) {\n    var _a;\n    var min = parentAxis.min - draggableAxis.min;\n    var max = parentAxis.max - draggableAxis.max;\n    // If the parent axis is actually smaller than the draggable axis then we can\n    // flip the constraints\n    if (parentAxis.max - parentAxis.min <\n        draggableAxis.max - draggableAxis.min) {\n        _a = [max, min], min = _a[0], max = _a[1];\n    }\n    return { min: min, max: max };\n}\nfunction calculateConstraints(parentBox, draggableBox) {\n    return {\n        x: calculateAxisConstraints(parentBox.x, draggableBox.x),\n        y: calculateAxisConstraints(parentBox.y, draggableBox.y),\n    };\n}\nfunction getBoundingBox(element, transformPagePoint) {\n    var rect = element.getBoundingClientRect();\n    return convertBoundingBoxToAxisBox(transformBoundingBox(rect, transformPagePoint));\n}\n// function getCurrentOffset(point?: MotionValue<number>) {\n//     return point ? point.get() : 0\n// }\nfunction applyConstraints(axis, value, constraints, dragElastic) {\n    var constrainedValue = value instanceof MotionValue ? value.get() : value;\n    if (!constraints) {\n        return constrainedValue;\n    }\n    var _a = constraints[axis], min = _a.min, max = _a.max;\n    if (min !== undefined && constrainedValue < min) {\n        constrainedValue = dragElastic\n            ? applyOverdrag(min, constrainedValue, dragElastic)\n            : Math.max(min, constrainedValue);\n    }\n    else if (max !== undefined && constrainedValue > max) {\n        constrainedValue = dragElastic\n            ? applyOverdrag(max, constrainedValue, dragElastic)\n            : Math.min(max, constrainedValue);\n    }\n    if (value instanceof MotionValue) {\n        value.set(constrainedValue);\n    }\n    return constrainedValue;\n}\nfunction applyOverdrag(origin, current, dragElastic) {\n    var dragFactor = typeof dragElastic === \"number\" ? dragElastic : 0.35;\n    return mix(origin, current, dragFactor);\n}\n\n/**\n * Magic Motion relies on multiple components and class components only support, hence this\n * wrapper component that provides those contexts as props.\n */\nvar SharedLayoutContextProvider = function (props) {\n    var _a = usePresence(), isPresent = _a[0], safeToRemove = _a[1];\n    var sharedLayoutContext = useContext(SharedLayoutContext);\n    var autoValues = useContext(MotionPluginContext).autoValues;\n    return (createElement(Auto\n    // We allow isPresent to be overwritten by manually setting it to true/false\n    // This is only intended for optimisations in Framer\n    , __assign({ \n        // We allow isPresent to be overwritten by manually setting it to true/false\n        // This is only intended for optimisations in Framer\n        isPresent: isPresent }, props, { safeToRemove: safeToRemove, sharedLayoutContext: sharedLayoutContext, autoValues: autoValues })));\n};\nvar Auto = /** @class */ (function (_super) {\n    __extends(Auto, _super);\n    function Auto(props) {\n        var _this = _super.call(this, props) || this;\n        /**\n         * If this component is a child of both AnimateSharedLayout and AnimatePresence we need to know if\n         * it's safe to remove. This logic usually runs when AnimateSharedLayout triggers this component's\n         * startAnimation method. But if this component renders apart from AnimateSharedLayout, it needs to know\n         * that it didn't run this method and in the event that it's leaving the tree, can safely call `safeToRemove`.\n         */\n        _this.willAnimate = false;\n        /**\n         * We use this value to track whether, on a given render, this component should animate. This is\n         * decided in shouldComponentUpdate, but the logic governing both is different.\n         */\n        _this.shouldAnimate = true;\n        /**\n         * The `measuredOrigin` layout as corrected for all the transforms being applied up the\n         * auto-animate tree. We use this as the final bounding box from which we calculate a transform\n         * delta to our desired visual position on any given frame.\n         *\n         * This is mutable to avoid object creation on each frame.\n         */\n        _this.correctedLayout = {\n            x: { min: 0, max: 0 },\n            y: { min: 0, max: 0 },\n        };\n        /**\n         * The visual target we want to project our component into on a given frame.\n         *\n         * This is mutable to avoid object creation on each frame.\n         */\n        _this.frameTarget = {\n            x: { min: 0, max: 0 },\n            y: { min: 0, max: 0 },\n        };\n        /**\n         * A flag to check whether this component has ever animated rotate. We use this to force\n         * originX/Y to 0.5\n         */\n        _this.hasAnimatedRotate = false;\n        /**\n         * The overall scale of the local coordinate system as transformed by all parents of this component. We use this\n         * for scale correction on our calculated layouts and scale-affected values like `boxShadow`.\n         *\n         * This is mutable to avoid object creation on each frame.\n         */\n        _this.treeScale = { x: 1, y: 1 };\n        /**\n         * The current, pre-correction values of every scale-corrected value. We keep a record of these throughout\n         * an animation so if the animation is interrupted we can resume from this value instead of a scale-corrected\n         * value that may have no relevance in the next treeScale context.\n         */\n        _this.current = {\n            rotate: 0,\n        };\n        // TODO: Can we move these back here somehow\n        _this.delta = props.localContext.layoutDelta;\n        _this.depth = props.localContext.layoutDepth;\n        _this.progress = props.localContext.layoutProgress;\n        _this.shouldAnimate =\n            props._shouldAnimate !== undefined\n                ? props._shouldAnimate\n                : _this.shouldAnimate;\n        var autoValues = props.autoValues;\n        _this.supportedAutoValues = __assign(__assign({}, defaultMagicValues), autoValues);\n        _this.animatableStyles = getAnimatableValues(_this.supportedAutoValues);\n        return _this;\n    }\n    Auto.prototype.componentDidMount = function () {\n        var _this = this;\n        var sharedLayoutContext = this.props.sharedLayoutContext;\n        if (isSharedLayoutTree(sharedLayoutContext)) {\n            this.unregisterSharedLayoutContext = sharedLayoutContext.register(this);\n            // Check if this render was handled by AnimateSharedLayout. If it was,\n            // the usual logic in startAnimation to tell AnimatePresence that this component is safe to remove\n            // will have run. If it wasn't, we have to do that here.\n            this.componentDidUpdate = function (prevProps) {\n                var _a = _this.props, layoutId = _a.layoutId, layoutOrder = _a.layoutOrder;\n                if (layoutId !== prevProps.layoutId) {\n                    _this.unregisterSharedLayoutContext &&\n                        _this.unregisterSharedLayoutContext();\n                    _this.unregisterSharedLayoutContext = sharedLayoutContext.register(_this);\n                }\n                else if (layoutOrder !== undefined &&\n                    layoutOrder !== prevProps.layoutOrder) {\n                    sharedLayoutContext.move(_this);\n                    _this.resetStyles();\n                }\n                if (!_this.willAnimate)\n                    _this.safeToRemove();\n                _this.willAnimate = false;\n            };\n        }\n        else {\n            /**\n             * If we're not a child of AnimateSharedLayout we can use some default batching that will\n             * ensure all auto-animation read/write cycles are batched across components. This\n             * reduces layout thrashing and ensures all measurements are correct. Currently, because componentDidUpdate\n             * fires before new component componentDidMount, newly entering components are missed out and need\n             * AnimateSharedLayout to work correctly.\n             */\n            this.getSnapshotBeforeUpdate = function () {\n                _this.snapshotOrigin();\n                sharedLayoutContext.add(_this);\n                return null;\n            };\n            this.componentDidUpdate = function () { return sharedLayoutContext.flush(); };\n        }\n    };\n    Auto.prototype.componentWillUnmount = function () {\n        this.unregisterSharedLayoutContext &&\n            this.unregisterSharedLayoutContext();\n        this.stopLayoutAnimation && this.stopLayoutAnimation();\n    };\n    Auto.prototype.shouldComponentUpdate = function (nextProps) {\n        if (this.props._shouldAnimate !== undefined) {\n            this.shouldAnimate = this.props._shouldAnimate;\n            return true;\n        }\n        var hasDependency = this.props.magicDependency !== undefined ||\n            nextProps.magicDependency !== undefined;\n        var dependencyHasChanged = this.props.magicDependency !== nextProps.magicDependency;\n        var presenceHasChanged = this.props.isPresent !== nextProps.isPresent;\n        this.shouldAnimate =\n            !hasDependency ||\n                (hasDependency && dependencyHasChanged) ||\n                presenceHasChanged;\n        return true;\n    };\n    /**\n     * Reset the component's rotation so we can accurately measure its bounding box. If it's rotated\n     * when we snapshot, the bounding box will be reported as larger than the component's actual size.\n     *\n     * This is currently only available inside of Framer by setting supportRotate on AnimateSharedLayout.\n     * It incurs an extra read/write cycle triggered on shouldComponentUpdate which, in concurrent mode,\n     * might trigger more than once per render. So it isn't recommended for production.\n     */\n    Auto.prototype.resetRotation = function () {\n        var visualElement = this.props.visualElement;\n        var rotate = visualElement.getValue(\"rotate\");\n        this.current.rotate = rotate ? rotate.get() : 0;\n        if (!this.current.rotate)\n            return;\n        visualElement.setStaticValues(\"rotate\", 0);\n        visualElement.render();\n    };\n    /**\n     * Reset styles that we might be currently animating so we can read their target values from the DOM.\n     */\n    Auto.prototype.resetStyles = function () {\n        var _a = this.props, animate = _a.animate, visualElement = _a.visualElement, _b = _a.style, style = _b === void 0 ? {} : _b;\n        var reset = resetStyles(style, this.supportedAutoValues);\n        // If we're animating opacity separately, we don't want to reset\n        // as it causes a visual flicker when adding the component\n        // TODO: We should do this universally for all animating props\n        // and account for variants too.\n        if (typeof animate === \"object\" && animate.hasOwnProperty(\"opacity\")) {\n            delete reset.opacity;\n        }\n        visualElement.setStaticValues(reset);\n        visualElement.render();\n    };\n    /**\n     * Take a snapshot of the component as it currently exists before a render.\n     */\n    Auto.prototype.snapshotOrigin = function () {\n        this.willAnimate = true;\n        var visualElement = this.props.visualElement;\n        var origin = snapshot(visualElement, this.supportedAutoValues);\n        applyCurrent(origin.style, this.current);\n        return (this.measuredOrigin = origin);\n    };\n    /**\n     * Take a snapshot of a component as it will exist after a render.\n     */\n    Auto.prototype.snapshotTarget = function () {\n        var _a = this.props, visualElement = _a.visualElement, style = _a.style;\n        var target = snapshot(visualElement, this.supportedAutoValues);\n        target.style.rotate = resolve(0, style && style.rotate);\n        this.measuredTarget = target;\n    };\n    Auto.prototype.popFromFlow = function () {\n        var visualElement = this.props.visualElement;\n        var position = this.measuredTarget.style.position;\n        if (position === \"absolute\" || position === \"fixed\")\n            return;\n        var _a = this.measuredTarget.layout, x = _a.x, y = _a.y;\n        visualElement.setStaticValues({\n            position: \"absolute\",\n            width: x.max - x.min,\n            height: y.max - y.min,\n        });\n        visualElement.render();\n    };\n    /**\n     * Hide this component using opacity. We can't set it to display: none as we might\n     * still need to measure it or its children.\n     *\n     * This is triggered if the component is a child of AnimateSharedLayout and a new component\n     * enters the tree that shares this component's layoutId.\n     */\n    Auto.prototype.hide = function () {\n        this.delta.isVisible = false;\n        this.stopLayoutAnimation && this.stopLayoutAnimation();\n        var visualElement = this.props.visualElement;\n        var opacity = visualElement.getValue(\"opacity\", 0);\n        opacity.set(0);\n        visualElement.render();\n        if (!this.isPresent())\n            this.safeToRemove();\n    };\n    Auto.prototype.show = function () {\n        this.delta.isVisible = true;\n        var _a = this.props, visualElement = _a.visualElement, style = _a.style;\n        var opacity = visualElement.getValue(\"opacity\", 1);\n        var newOpacity = style ? resolve(1, style.opacity) : 1;\n        opacity.set(newOpacity);\n    };\n    Auto.prototype.setVisibility = function (visibilityAction) {\n        if (visibilityAction === VisibilityAction.Show) {\n            this.show();\n        }\n        else {\n            this.hide();\n        }\n        return this.safeToRemove();\n    };\n    /**\n     * Start an auto or shared layout animation.\n     */\n    Auto.prototype.startAnimation = function (_a) {\n        var _this = this;\n        if (_a === void 0) { _a = {}; }\n        var _b, _c;\n        var origin = _a.origin, target = _a.target, visibilityAction = _a.visibilityAction, opts = __rest(_a, [\"origin\", \"target\", \"visibilityAction\"]);\n        if (visibilityAction !== undefined) {\n            return this.setVisibility(visibilityAction);\n        }\n        var animationPromise;\n        var animations = [];\n        // Restore rotation before any writes. If we don't do this, and for whatever\n        // reason the animation doesn't execute, rotation will be left at 0\n        var visualElement = this.props.visualElement;\n        var rotate = visualElement.getValue(\"rotate\");\n        rotate &&\n            visualElement.setStaticValues(\"rotate\", rotate.get());\n        this.visualTarget = target || this.measuredTarget;\n        // If we don't have a provided or measured origin, for instance if this is a newly-added component,\n        // we can just take the target and use that to at least maintain its position on screen as parent\n        // components animate\n        this.visualOrigin = origin || this.measuredOrigin || this.visualTarget;\n        this.delta.isVisible =\n            ((_b = this.visualOrigin) === null || _b === void 0 ? void 0 : _b.style.opacity) !== 0 ||\n                ((_c = this.visualTarget) === null || _c === void 0 ? void 0 : _c.style.opacity) !== 0;\n        var parentContext = this.props.parentContext;\n        var parentDeltas = parentContext.layoutDeltas || [];\n        this.shouldAnimate =\n            opts.shouldAnimate !== undefined\n                ? opts.shouldAnimate\n                : this.shouldAnimate;\n        if (this.shouldAnimate &&\n            this.visualOrigin &&\n            this.visualTarget &&\n            this.measuredTarget &&\n            this.delta.isVisible &&\n            isTreeVisible(parentDeltas)) {\n            syncRenderSession.open();\n            animations = [\n                this.startLayoutAnimation(opts),\n                this.startStyleAnimation(opts),\n            ].filter(Boolean);\n            animationPromise = Promise.all(animations).then(function () {\n                var onMagicComplete = _this.props.onMagicComplete;\n                onMagicComplete && onMagicComplete();\n            });\n            syncRenderSession.flush();\n        }\n        // If we don't animate, make sure we call safeToRemove so if this is an\n        // exiting component it'll get removed\n        !animations.length && this.safeToRemove();\n        // Force render to ensure there's no flashes of unstyled content from the reset\n        visualElement.render();\n        return animationPromise;\n    };\n    /**\n     * This uses the FLIP animation technique to animate physical dimensions\n     * and correct distortion on related styles (ie borderRadius etc)\n     */\n    Auto.prototype.startLayoutAnimation = function (opts) {\n        var _this = this;\n        var animation;\n        this.stopLayoutAnimation && this.stopLayoutAnimation();\n        var originStyle = this.visualOrigin.style;\n        var targetStyle = this.visualTarget.style;\n        var isAnimatingRotate = Boolean(originStyle.rotate || targetStyle.rotate);\n        // We really want to know if its ever animated rotate and the above isn't good enough\n        if (isAnimatingRotate)\n            this.hasAnimatedRotate = isAnimatingRotate;\n        var visualElement = this.props.visualElement;\n        var updaters = {};\n        for (var key in this.supportedAutoValues) {\n            var handler = this.supportedAutoValues[key];\n            if (!handler.createUpdater)\n                continue;\n            updaters[key] = handler.createUpdater(visualElement, originStyle[key], targetStyle[key], this.current, this.delta, this.treeScale, this.visualOrigin.layout, this.visualTarget.layout);\n        }\n        this.frameTarget = {\n            x: { min: 0, max: 0 },\n            y: { min: 0, max: 0 },\n        };\n        var x = visualElement.getValue(\"x\", 0);\n        var y = visualElement.getValue(\"y\", 0);\n        var scaleX = visualElement.getValue(\"scaleX\", 1);\n        var scaleY = visualElement.getValue(\"scaleY\", 1);\n        var rotate = visualElement.getValue(\"rotate\", 0);\n        // TODO: Make API for this, stop all values. Currently just doing this to stop drag inertia animations\n        x.stop();\n        y.stop();\n        var opacity = visualElement.getValue(\"opacity\", originStyle.opacity);\n        var frame = function () {\n            // TODO: Break up each of these so we can animate separately\n            var p = _this.progress.get() / 1000;\n            _this.updateBoundingBox(p, _this.hasAnimatedRotate ? 0.5 : undefined);\n            _this.updateTransform(x, y, scaleX, scaleY);\n            _this.hasAnimatedRotate && _this.updateRotate(p, rotate);\n            for (var key in updaters) {\n                var updater = updaters[key];\n                updater && updater(p);\n            }\n            if (opts.crossfade) {\n                opacity.set(opts.crossfade(originStyle.opacity, targetStyle.opacity, p));\n            }\n        };\n        var progressOrigin = 0;\n        var progressTarget = 1000;\n        this.progress.set(progressOrigin);\n        this.progress.set(progressOrigin); // Set twice to hard-reset velocity\n        var _a = this.props, transition = _a.transition, animate = _a.animate;\n        if (animate !== false) {\n            var dragControls = elementDragControls.get(visualElement);\n            if (!dragControls || !dragControls.isDragging) {\n                animation = startAnimation(\"progress\", this.progress, progressTarget, __assign(__assign({}, (opts.transition || transition)), { restDelta: 1, restSpeed: 10 })).then(function () { return _this.safeToRemove(); });\n            }\n            else {\n                this.updateBoundingBox(progressOrigin);\n                // Reset drag origin so the element doesn't look like it's moved in the DOM\n                // TODO: This is currently lossy with big mouse movements\n                var _b = dragControls.origin, dragOriginX = _b.x, dragOriginY = _b.y;\n                dragOriginX.set(dragOriginX.get() + this.delta.x.translate - x.get());\n                dragOriginY.set(dragOriginY.get() + this.delta.y.translate - y.get());\n                this.safeToRemove();\n            }\n        }\n        else {\n            this.safeToRemove();\n        }\n        var parentContext = this.props.parentContext;\n        var layoutProgress = parentContext.layoutProgress;\n        var scheduleUpdate = function () { return sync.update(frame, false, true); };\n        var unsubscribeProgress = this.progress.onChange(scheduleUpdate);\n        var unsubscribeParentProgress;\n        if (layoutProgress) {\n            unsubscribeParentProgress = layoutProgress.onChange(scheduleUpdate);\n        }\n        this.stopLayoutAnimation = function () {\n            cancelSync.update(frame);\n            _this.progress.stop();\n            unsubscribeProgress();\n            unsubscribeParentProgress && unsubscribeParentProgress();\n        };\n        // TODO: I would prefer this to be a scheduleUpdate call, for some reason this is breaking\n        // visualOrigin in the sharedLayoutFramerSetup demonstration\n        frame();\n        return animation;\n    };\n    /**\n     * This is a straight animation between prev/next styles. This animates\n     * styles that don't need scale inversion correction.\n     */\n    Auto.prototype.startStyleAnimation = function (opts) {\n        var _a;\n        var shouldAnimateStyle = false;\n        var target = {};\n        var visualElement = this.props.visualElement;\n        var numAnimatableStyles = this.animatableStyles.length;\n        for (var i = 0; i < numAnimatableStyles; i++) {\n            var key = this.animatableStyles[i];\n            if (key === \"opacity\" && opts.crossfade)\n                continue;\n            var originStyle = this.visualOrigin.style[key];\n            var targetStyle = this.visualTarget.style[key];\n            /**\n             * If backgroundColor has been read as `rgba(0 0 0 0)` it's mostly likely got a fully\n             * transparent background. If we animate to/from this color, we'll animate to/from transparent\n             * black rather than the transparent origin/target colour.\n             */\n            if (key === \"backgroundColor\") {\n                _a = fixTransparentRGBPair(originStyle, targetStyle), originStyle = _a[0], targetStyle = _a[1];\n            }\n            if (originStyle !== targetStyle) {\n                shouldAnimateStyle = true;\n                var value = visualElement.getValue(key, originStyle);\n                value.set(originStyle);\n                target[key] = targetStyle;\n            }\n        }\n        var _b = this.props, transition = _b.transition, controls = _b.controls;\n        target.transition = opts.transition || transition || {};\n        if (shouldAnimateStyle) {\n            return controls.start(target);\n        }\n    };\n    Auto.prototype.updateBoundingBox = function (p, origin) {\n        var parentContext = this.props.parentContext;\n        var parentDeltas = parentContext.layoutDeltas || [];\n        resetBox(this.correctedLayout, this.measuredTarget.layout);\n        applyTreeDeltas(this.correctedLayout, this.treeScale, parentDeltas);\n        tweenAxisBox(this.frameTarget, this.visualOrigin.layout, this.visualTarget.layout, p);\n        calcBoxDelta(this.delta, this.frameTarget, this.correctedLayout, origin);\n    };\n    Auto.prototype.updateTransform = function (x, y, scaleX, scaleY) {\n        var visualElement = this.props.visualElement;\n        var dx = this.delta.x;\n        var dy = this.delta.y;\n        visualElement.setStaticValues(\"originX\", dx.origin);\n        visualElement.setStaticValues(\"originY\", dy.origin);\n        x.set(dx.translate / this.treeScale.x);\n        y.set(dy.translate / this.treeScale.y);\n        scaleX.set(dx.scale);\n        scaleY.set(dy.scale);\n    };\n    Auto.prototype.updateRotate = function (p, rotate) {\n        var target = mix(this.visualOrigin.style.rotate, this.visualTarget.style.rotate, p);\n        rotate.set(target);\n    };\n    Auto.prototype.isPresent = function () {\n        return this.props.isPresent;\n    };\n    Auto.prototype.safeToRemove = function () {\n        var safeToRemove = this.props.safeToRemove;\n        safeToRemove && safeToRemove();\n    };\n    Auto.prototype.render = function () {\n        return null;\n    };\n    return Auto;\n}(Component));\n\nvar Auto$1 = {\n    key: \"auto\",\n    shouldRender: function (_a) {\n        var animate = _a.animate, layoutId = _a.layoutId;\n        var hasAutoAnimateProps = typeof animate === \"boolean\" || layoutId !== undefined;\n        return hasAutoAnimateProps && typeof window !== \"undefined\";\n    },\n    Component: SharedLayoutContextProvider,\n};\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @param param\n * @param ref\n * @param values\n * @param controls\n *\n * @internal\n */\nfunction useDrag(props, visualElement, controls) {\n    var groupDragControls = props.dragControls;\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n    var dragControls = useConstant(function () { return new VisualElementDragControls({ visualElement: visualElement, controls: controls }); });\n    dragControls.updateProps(__assign(__assign({}, props), { transformPagePoint: transformPagePoint }));\n    useDisableDragOnExit(dragControls);\n    useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\n    useEffect(function () { return dragControls.mount(visualElement.getInstance()); }, []);\n}\nfunction useDisableDragOnExit(dragControls) {\n    var isPresent = useIsPresent();\n    useEffect(function () {\n        if (!isPresent)\n            dragControls.stopMotion();\n    }, [isPresent]);\n}\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\n    hook(props);\n    return null;\n}; };\n\nvar Drag = {\n    key: \"drag\",\n    shouldRender: function (props) {\n        return !!props.drag || !!props.dragConstraints;\n    },\n    Component: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, controls = _a.controls, props = __rest(_a, [\"visualElement\", \"controls\"]);\n        return useDrag(props, visualElement, controls);\n    }),\n};\n\nfunction useUnmountEffect(callback) {\n    return useEffect(function () { return function () { return callback(); }; }, []);\n}\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a, ref) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = useRef(null);\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    useEffect(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\nvar getGesturePriority = function (gesture) {\n    return order$1.indexOf(gesture) + 1;\n};\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a, ref) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, controls = _a.controls;\n    var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isTapping = useRef(false);\n    var cancelPointerEventListener = useRef(null);\n    function removePointerUp() {\n        cancelPointerEventListener.current &&\n            cancelPointerEventListener.current();\n        cancelPointerEventListener.current = null;\n    }\n    if (whileTap && controls) {\n        controls.setOverride(whileTap, tapGesturePriority);\n    }\n    // We load this event handler into a ref so we can later refer to\n    // onPointerUp.current which will always have reference to the latest props\n    var onPointerUp = useRef(null);\n    onPointerUp.current = function (event, info) {\n        var element = ref.current;\n        removePointerUp();\n        if (!isTapping.current || !element)\n            return;\n        isTapping.current = false;\n        if (controls && whileTap) {\n            controls.clearOverride(tapGesturePriority);\n        }\n        // Check the gesture lock - if we get it, it means no drag gesture is active\n        // and we can safely fire the tap gesture.\n        var openGestureLock = getGlobalLock(true);\n        if (!openGestureLock)\n            return;\n        openGestureLock();\n        if (!isNodeOrChild(element, event.target)) {\n            onTapCancel && onTapCancel(event, info);\n        }\n        else {\n            onTap && onTap(event, info);\n        }\n    };\n    function onPointerDown(event, info) {\n        removePointerUp();\n        cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) { return onPointerUp.current(event, info); });\n        var element = ref.current;\n        if (!element || isTapping.current)\n            return;\n        isTapping.current = true;\n        onTapStart && onTapStart(event, info);\n        if (controls && whileTap) {\n            controls.startOverride(tapGesturePriority);\n        }\n    }\n    usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\n    useUnmountEffect(removePointerUp);\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\nvar filterTouch = function (listener) { return function (event, info) {\n    if (isMouseEvent(event))\n        listener(event, info);\n}; };\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useHoverGesture(_a, ref) {\n    var whileHover = _a.whileHover, onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, controls = _a.controls;\n    if (whileHover && controls) {\n        controls.setOverride(whileHover, hoverPriority);\n    }\n    usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\n        if (onHoverStart)\n            onHoverStart(event, info);\n        if (whileHover && controls) {\n            controls.startOverride(hoverPriority);\n        }\n    }));\n    usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\n        if (onHoverEnd)\n            onHoverEnd(event, info);\n        if (whileHover && controls) {\n            controls.clearOverride(hoverPriority);\n        }\n    }));\n}\n\n/**\n * Add pan and tap gesture recognition to an element.\n *\n * @param props - Gesture event handlers\n * @param ref - React `ref` containing a DOM `Element`\n * @public\n */\nfunction useGestures(props, ref) {\n    usePanGesture(props, ref);\n    useTapGesture(props, ref);\n    useHoverGesture(props, ref);\n}\n\nvar gestureProps = [\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"whileTap\",\n    \"whileHover\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n];\nvar Gestures = {\n    key: \"gestures\",\n    shouldRender: function (props) {\n        return gestureProps.some(function (key) { return props.hasOwnProperty(key); });\n    },\n    Component: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, props = __rest(_a, [\"visualElement\"]);\n        useGestures(props, visualElement);\n    }),\n};\n\nvar Exit = {\n    key: \"exit\",\n    shouldRender: function (props) { return !!props.exit && !checkShouldInheritVariant(props); },\n    Component: makeRenderlessComponent(function (props) {\n        var _a;\n        var animate = props.animate, controls = props.controls, exit = props.exit;\n        var _b = usePresence(), isPresent = _b[0], onExitComplete = _b[1];\n        var presenceContext = useContext(PresenceContext);\n        var isPlayingExitAnimation = useRef(false);\n        var custom = ((_a = presenceContext) === null || _a === void 0 ? void 0 : _a.custom) !== undefined\n            ? presenceContext.custom\n            : props.custom;\n        useEffect(function () {\n            if (!isPresent) {\n                if (!isPlayingExitAnimation.current && exit) {\n                    controls.setProps(__assign(__assign({}, props), { custom: custom }));\n                    controls.start(exit).then(onExitComplete);\n                }\n                isPlayingExitAnimation.current = true;\n            }\n            else if (isPlayingExitAnimation.current &&\n                animate &&\n                typeof animate !== \"boolean\" &&\n                !(animate instanceof AnimationControls)) {\n                controls.start(animate);\n            }\n            if (isPresent) {\n                isPlayingExitAnimation.current = false;\n            }\n        }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\n    }),\n};\n\nvar AnimatePropType;\n(function (AnimatePropType) {\n    AnimatePropType[\"Target\"] = \"Target\";\n    AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\n    AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\n    if (prev === null)\n        return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (var i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\nvar hasUpdated = function (prev, next) {\n    return (next !== undefined &&\n        (Array.isArray(prev) && Array.isArray(next)\n            ? !shallowCompare(next, prev)\n            : prev !== next));\n};\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\n    if (mergeTransitionEnd === void 0) { mergeTransitionEnd = false; }\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n    return mergeTransitionEnd\n        ? __assign(__assign({}, target), transitionEnd)\n        : target;\n}\n/**\n * Handle the `animate` prop when its an object of values, ie:\n *\n * ```jsx\n * <motion.div animate={{ opacity: 1 }} />\n * ```\n *\n * @internalremarks\n * It might be worth consolidating this with `use-variants`\n *\n * ```jsx\n * <motion.div animate=\"visible\" />\n * ```\n *\n * @param target\n * @param controls\n * @param values\n * @param transition\n *\n * @internal\n */\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\n    var isInitialRender = useRef(true);\n    var prevValues = useRef(null);\n    if (!prevValues.current) {\n        prevValues.current = targetWithoutTransition(targetAndTransition, true);\n    }\n    useEffect(function () {\n        var targetToAnimate = {};\n        // These are the values we're actually animating\n        var animatingTarget = targetWithoutTransition(targetAndTransition);\n        // This is the target as it'll be once transitionEnd values are applied\n        var finalTarget = targetWithoutTransition(targetAndTransition, true);\n        // Detect which values have changed between renders\n        for (var key in animatingTarget) {\n            // This value should animate on mount if this value doesn't already exist (wasn't\n            // defined in `style` or `initial`) or if it does exist and it's already changed.\n            var shouldAnimateOnMount = isInitialRender.current &&\n                (!visualElement.hasValue(key) ||\n                    visualElement.getValue(key).get() !== finalTarget[key]);\n            // If this value has updated between renders or it's we're animating this value on mount,\n            // add it to the animate target.\n            var isValidValue = finalTarget[key] !== null;\n            var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\n            if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\n                targetToAnimate[key] = animatingTarget[key];\n            }\n        }\n        isInitialRender.current = false;\n        prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\n        if (Object.keys(targetToAnimate).length) {\n            controls.start(__assign(__assign({}, targetToAnimate), { transition: targetAndTransition.transition || defaultTransition, transitionEnd: targetAndTransition.transitionEnd }));\n        }\n    }, [targetAndTransition]);\n}\n\nvar labelsToArray = function (label) {\n    if (!label) {\n        return [];\n    }\n    if (Array.isArray(label)) {\n        return label;\n    }\n    return [label];\n};\nvar resolveVariantLabels = function (variant) {\n    var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\n    return Array.from(new Set(labelsToArray(unresolvedVariant)));\n};\n/**\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\n * When values in this array change, React re-runs the dependency. However if the array\n * contains a variable number of items, React throws an error.\n */\nvar asDependencyList = function (list) { return [\n    list.join(\",\"),\n]; };\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\n    return oldVariant.join(\",\") !== newVariant.join(\",\");\n};\n/**\n * Handle variants and the `animate` prop when its set as variant labels.\n *\n * @param initial - Initial variant(s)\n * @param animate - Variant(s) to animate to\n * @param inherit - `true` is inheriting animations from parent\n * @param controls - Animation controls\n *\n * @internal\n */\nfunction useVariants(initial, animate, inherit, controls) {\n    var targetVariants = resolveVariantLabels(animate);\n    var context = useContext(MotionContext);\n    var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\n    var hasMounted = useRef(false);\n    useEffect(function () {\n        var shouldAnimate = false;\n        if (inherit) {\n            // If we're inheriting variant changes and the parent has already\n            // mounted when this component loads, we need to manually trigger\n            // this animation.\n            shouldAnimate = !!parentAlreadyMounted;\n            targetVariants = resolveVariantLabels(context.animate);\n        }\n        else {\n            shouldAnimate =\n                hasMounted.current ||\n                    hasVariantChanged(resolveVariantLabels(initial), targetVariants);\n        }\n        shouldAnimate && controls.start(targetVariants);\n        hasMounted.current = true;\n    }, asDependencyList(targetVariants));\n}\n\n/**\n * `useAnimationGroupSubscription` allows a component to subscribe to an\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\n *\n * @param animation\n * @param controls\n *\n * @internal\n */\nfunction useAnimationGroupSubscription(animation, controls) {\n    var unsubscribe = useMemo(function () { return animation.subscribe(controls); }, [\n        animation,\n    ]);\n    useEffect(function () { return function () {\n        unsubscribe && unsubscribe();\n    }; }, [unsubscribe]);\n}\n\nvar _a, _b;\nvar AnimatePropComponents = (_a = {},\n    _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\n        var animate = _a.animate, controls = _a.controls, visualElement = _a.visualElement, transition = _a.transition;\n        return useAnimateProp(animate, controls, visualElement, transition);\n    }),\n    _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\n        var animate = _a.animate, _b = _a.inherit, inherit = _b === void 0 ? true : _b, controls = _a.controls, initial = _a.initial;\n        return useVariants(initial, animate, inherit, controls);\n    }),\n    _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\n        var animate = _a.animate, controls = _a.controls;\n        return useAnimationGroupSubscription(animate, controls);\n    }),\n    _a);\nvar isVariantLabel$1 = function (prop) {\n    return Array.isArray(prop) || typeof prop === \"string\";\n};\nvar isAnimationSubscription = function (_a) {\n    var animate = _a.animate;\n    return animate instanceof AnimationControls;\n};\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\nvar animatePropTypeTests = (_b = {},\n    _b[AnimatePropType.Target] = function (props) {\n        return (props.animate !== undefined &&\n            !isVariantLabel$1(props.animate) &&\n            !isAnimationSubscription(props));\n    },\n    _b[AnimatePropType.VariantLabel] = function (props) {\n        return (props.variants !== undefined ||\n            animationProps.some(function (key) { return typeof props[key] === \"string\"; }));\n    },\n    _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription,\n    _b);\nvar getAnimationComponent = function (props) {\n    var animatePropType = undefined;\n    for (var key in AnimatePropType) {\n        if (animatePropTypeTests[key](props)) {\n            animatePropType = key;\n        }\n    }\n    return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\n};\n\n/**\n * Currently we load all features synchronously, but it would be better to offer multiple entry points\n * that allow these to be loaded in asynchronously.\n */\nvar defaultFeatures = [Auto$1, Drag, Gestures, Exit];\n/**\n * Load features via renderless components based on the provided MotionProps\n */\nfunction useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\n    var plugins = useContext(MotionPluginContext);\n    // If this is a static component, or we're rendering on the server, we don't load\n    // any feature components\n    if (isStatic || typeof window === \"undefined\")\n        return null;\n    var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\n    var numFeatures = allFeatures.length;\n    var features = [];\n    // TODO: Consolidate Animation feature loading strategy with other functionality components\n    var Animation = getAnimationComponent(props);\n    if (Animation) {\n        features.push(createElement(Animation, { key: \"animation\", initial: props.initial, animate: props.animate, variants: props.variants, transition: props.transition, controls: controls, inherit: shouldInheritVariant, visualElement: visualElement }));\n    }\n    // Decide which features we should render and add them to the returned array\n    for (var i = 0; i < numFeatures; i++) {\n        var _a = allFeatures[i], shouldRender = _a.shouldRender, key = _a.key, Component = _a.Component;\n        if (shouldRender(props, parentContext)) {\n            features.push(createElement(Component, __assign({ key: key }, props, { localContext: context, parentContext: parentContext, visualElement: visualElement, controls: controls })));\n        }\n    }\n    return features;\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(Component, _a) {\n    var useVisualElement = _a.useVisualElement, render = _a.render, animationControlsConfig = _a.animationControlsConfig;\n    function MotionComponent(props, externalRef) {\n        var parentContext = useContext(MotionContext);\n        var shouldInheritVariant = checkShouldInheritVariant(props);\n        /**\n         * If a component isStatic, we only visually update it as a\n         * result of a React re-render, rather than any interactions or animations.\n         * If this component or any ancestor isStatic, we disable hardware acceleration\n         * and don't load any additional functionality.\n         */\n        var isStatic = parentContext.static || props.static || false;\n        /**\n         * Create a VisualElement for this component. A VisualElement provides a common\n         * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n         * providing a way of rendering to these APIs outside of the React render loop\n         * for more performant animations and interactions\n         */\n        var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\n        /**\n         * Scrape MotionValues from props and add/remove them to/from\n         * the VisualElement as necessary.\n         */\n        useMotionValues(visualElement, props);\n        /**\n         * Create animation controls for the VisualElement. It might be\n         * interesting to try and combine this with VisualElement itself in a further refactor.\n         */\n        var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\n        /**\n         * Build the MotionContext to pass on to the next `motion` component.\n         */\n        var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\n        /**\n         * Load features as renderless components unless the component isStatic\n         */\n        var features = useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\n        var component = render(Component, props, visualElement);\n        // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\n        // all plugins and features has to execute.\n        return (createElement(Fragment, null,\n            createElement(MotionContext.Provider, { value: context }, component),\n            features));\n    }\n    return forwardRef(MotionComponent);\n}\n\n/**\n * DOM-specific config for `motion` components\n */\nvar config = {\n    useVisualElement: useDomVisualElement,\n    render: render,\n    animationControlsConfig: {\n        makeTargetAnimatable: parseDomVariant,\n    },\n};\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion.custom(Component)\n * ```\n *\n * @public\n */\nfunction custom(Component) {\n    return createMotionComponent(Component, config);\n}\nvar componentCache = new Map();\nfunction get(target, key) {\n    if (key === \"custom\")\n        return target.custom;\n    if (!componentCache.has(key)) {\n        componentCache.set(key, createMotionComponent(key, config));\n    }\n    return componentCache.get(key);\n}\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = new Proxy({ custom: custom }, { get: get });\n\nfunction useForceUpdate() {\n    var _a = useState(0), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    return useCallback(function () { return setForcedRenderCount(forcedRenderCount + 1); }, [\n        forcedRenderCount,\n    ]);\n}\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom;\n    var id = useConstant(getPresenceId);\n    var numPresenceChildren = useRef(0);\n    var numExitComplete = useRef(0);\n    var context = {\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function () {\n            numExitComplete.current++;\n            var allComplete = numExitComplete.current >= numPresenceChildren.current;\n            onExitComplete && allComplete && onExitComplete();\n        },\n    };\n    var register = useMemo(function () {\n        numExitComplete.current = 0;\n        return function () {\n            numPresenceChildren.current++;\n            return function () { return numPresenceChildren.current--; };\n        };\n    }, [isPresent]);\n    return (createElement(PresenceContext.Provider, { value: __assign(__assign({ id: id }, context), { register: register }) }, children));\n};\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = useContext(SharedLayoutContext);\n    if (isControlledSharedLayoutContext(layoutContext)) {\n        forceRender = layoutContext.forceRender;\n    }\n    var isInitialRender = useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (createElement(Fragment, null, filteredChildren.map(function (child) { return (createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = __spreadArrays(filteredChildren);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (createElement(PresenceChild, { key: getChildKey(child), isPresent: true }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (createElement(Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\nfunction isControlledSharedLayoutContext(context) {\n    return !!context.forceRender;\n}\n\nfunction createSwitchAnimation(child, _isRoot, stack) {\n    var _a, _b;\n    if (stack && child !== stack.lead) {\n        return { visibilityAction: VisibilityAction.Hide };\n    }\n    else if (stack &&\n        child.presence !== Presence.Entering &&\n        child === stack.lead &&\n        stack.lead !== stack.prevLead) {\n        return { visibilityAction: VisibilityAction.Show };\n    }\n    var origin;\n    var target;\n    if (child.presence === Presence.Entering) {\n        origin = (_a = stack) === null || _a === void 0 ? void 0 : _a.getFollowOrigin();\n    }\n    else if (child.presence === Presence.Exiting) {\n        target = (_b = stack) === null || _b === void 0 ? void 0 : _b.getFollowTarget();\n    }\n    return { origin: origin, target: target };\n}\nfunction createCrossfadeAnimation(child, isRoot, stack) {\n    var _a;\n    var config = {};\n    var stackLead = stack && stack.lead;\n    var stackLeadPresence = (_a = stackLead) === null || _a === void 0 ? void 0 : _a.presence;\n    if (stack && child === stackLead) {\n        if (child.presence === Presence.Entering) {\n            config.origin = stack.getFollowOrigin();\n        }\n        else if (child.presence === Presence.Exiting) {\n            config.target = stack.getFollowTarget();\n        }\n    }\n    else if (stack && child === stack.follow) {\n        if (stackLeadPresence === Presence.Entering) {\n            config.target = stack.getLeadTarget();\n        }\n        else if (stackLeadPresence === Presence.Exiting) {\n            config.origin = stack.getLeadOrigin();\n        }\n    }\n    // // Handle crossfade opacity\n    if (!isRoot)\n        return config;\n    if (!stack || child === stackLead) {\n        if (child.presence === Presence.Entering) {\n            config.crossfade = crossfadeIn;\n        }\n        else if (child.presence === Presence.Exiting) {\n            config.crossfade = crossfadeOut;\n        }\n    }\n    else if (stack && child === stack.follow) {\n        if (!stackLead || stackLeadPresence === Presence.Entering) {\n            config.crossfade = crossfadeOut;\n        }\n        else if (stackLeadPresence === Presence.Exiting) {\n            config.crossfade = crossfadeIn;\n        }\n    }\n    else {\n        config.visibilityAction = VisibilityAction.Hide;\n    }\n    return config;\n}\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nvar crossfadeIn = function (_origin, target, p) {\n    return mix(0, target, easeCrossfadeIn(p));\n};\nvar crossfadeOut = function (origin, _target, p) {\n    return mix(origin, 0, easeCrossfadeOut(p));\n};\n\n/**\n * For each layout animation, we want to identify two components\n * within a stack that will serve as the \"lead\" and \"follow\" components.\n *\n * In the switch animation, the lead component performs the entire animation.\n * It uses the follow bounding box to animate out from and back to. The follow\n * component is hidden.\n *\n * In the crossfade animation, both the lead and follow components perform\n * the entire animation, animating from the follow origin bounding box to the lead\n * target bounding box.\n *\n * Generalising a stack as First In Last Out, *searching from the end* we can\n * generally consider the lead component to be:\n *  - If the last child is present, the last child\n *  - If the last child is exiting, the last *encountered* exiting component\n */\nfunction findLeadAndFollow(stack, _a) {\n    var prevLead = _a[0], prevFollow = _a[1];\n    var lead = undefined;\n    var leadIndex = 0;\n    var follow = undefined;\n    // Find the lead child first\n    var numInStack = stack.length;\n    var lastIsPresent = false;\n    for (var i = numInStack - 1; i >= 0; i--) {\n        var child = stack[i];\n        var isLastInStack = i === numInStack - 1;\n        if (isLastInStack) {\n            lastIsPresent = child.isPresent();\n        }\n        if (lastIsPresent) {\n            lead = child;\n        }\n        else {\n            // If the child before this will be present, make this the\n            // lead.\n            var prev = stack[i - 1];\n            if (prev && prev.isPresent())\n                lead = child;\n        }\n        if (lead) {\n            leadIndex = i;\n            break;\n        }\n    }\n    if (!lead)\n        lead = stack[0];\n    // Find the follow child\n    follow = stack[leadIndex - 1];\n    // If the lead component is exiting, find the closest follow\n    // present component\n    if (lead) {\n        for (var i = leadIndex - 1; i >= 0; i--) {\n            var child = stack[i];\n            if (child.isPresent()) {\n                follow = child;\n                break;\n            }\n        }\n    }\n    // If the lead has changed and the previous lead still exists in the\n    // stack, set it to the previous lead. This allows us to differentiate between\n    // a, b, c(exit) -> a, b(exit), c(exit)\n    // and\n    // a, b(exit), c -> a, b(exit), c(exit)\n    if (lead !== prevLead &&\n        !lastIsPresent &&\n        follow === prevFollow &&\n        stack.find(function (stackChild) { return stackChild === prevLead; })) {\n        lead = prevLead;\n    }\n    return [lead, follow];\n}\nvar LayoutStack = /** @class */ (function () {\n    function LayoutStack() {\n        this.order = [];\n        // Track whether we've ever had a child\n        this.hasChildren = false;\n    }\n    LayoutStack.prototype.add = function (child) {\n        var layoutOrder = child.props.layoutOrder;\n        if (layoutOrder === undefined) {\n            this.order.push(child);\n        }\n        else {\n            var index = this.order.findIndex(function (stackChild) { return layoutOrder <= (stackChild.props.layoutOrder || 0); });\n            if (index === -1) {\n                child.presence = this.hasChildren\n                    ? Presence.Entering\n                    : Presence.Present;\n                index = this.order.length;\n            }\n            this.order.splice(index, 0, child);\n        }\n        this.hasChildren = true;\n    };\n    LayoutStack.prototype.remove = function (child) {\n        var index = this.order.findIndex(function (stackChild) { return child === stackChild; });\n        if (index !== -1)\n            this.order.splice(index, 1);\n    };\n    LayoutStack.prototype.updateLeadAndFollow = function () {\n        this.prevLead = this.lead;\n        this.prevFollow = this.follow;\n        var _a = findLeadAndFollow(this.order, [\n            this.lead,\n            this.follow,\n        ]), lead = _a[0], follow = _a[1];\n        this.lead = lead;\n        this.follow = follow;\n    };\n    LayoutStack.prototype.updateSnapshot = function () {\n        if (this.lead)\n            this.snapshot = this.lead.measuredOrigin;\n    };\n    LayoutStack.prototype.isLeadPresent = function () {\n        var _a;\n        return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\n    };\n    LayoutStack.prototype.shouldStackAnimate = function () {\n        var _a, _b, _c, _d;\n        return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.isPresent())\n            ? (_c = (_b = this.lead) === null || _b === void 0 ? void 0 : _b.props) === null || _c === void 0 ? void 0 : _c._shouldAnimate : this.follow && ((_d = this.follow) === null || _d === void 0 ? void 0 : _d.props._shouldAnimate);\n    };\n    LayoutStack.prototype.getFollowOrigin = function () {\n        return this.follow ? this.follow.measuredOrigin : this.snapshot;\n    };\n    LayoutStack.prototype.getFollowTarget = function () {\n        var _a;\n        return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.measuredTarget;\n    };\n    LayoutStack.prototype.getLeadOrigin = function () {\n        var _a;\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.measuredOrigin;\n    };\n    LayoutStack.prototype.getLeadTarget = function () {\n        var _a;\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.measuredTarget;\n    };\n    return LayoutStack;\n}());\n\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * Keep track of all animate children.\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Create an instance of the update batcher so we can run snapshots across\n         * components and fire animate transitions in the correct order.\n         */\n        _this.batch = batchTransitions();\n        /**\n         * We're tracking mount status as only subsequently-entering components need\n         * tagging with `shouldResumeFromPrevious`.\n         */\n        _this.hasMounted = false;\n        /**\n         * Keep track of whether we're currently animating layout and block forced re-renders\n         * until we're not.\n         */\n        _this.isAnimating = false;\n        /**\n         * If a forced re-render is triggered while there's a shared layout animation we block\n         * it and check this boolean after all animations are complete.\n         */\n        _this.shouldRerender = false;\n        _this.state = {\n            /**\n             * Allow children, like AnimatePresence, to force-render this component\n             * to ensure animate children correctly identify parallel state changes that\n             * might affect their layout.\n             */\n            forceRender: function () {\n                if (!_this.isAnimating) {\n                    _this.shouldRerender = false;\n                    _this.setState(__assign({}, _this.state));\n                }\n                else {\n                    _this.shouldRerender = true;\n                }\n            },\n            register: function (child) { return _this.addChild(child); },\n            move: function (child) {\n                _this.removeChildFromStack(child);\n                _this.addChildToStack(child);\n            },\n        };\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    /**\n     * We always want the component to re-render but for performance reasons we might\n     * want to control whether we take snapshots and perform animate transitions.\n     */\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n        this.shouldTransition = false;\n        if (this.state !== nextState) {\n            // This should always be true if we've got a new state as a result of a forced render\n            this.shouldTransition = true;\n        }\n        else {\n            // If we don't have a defined dependency, or we do and it's changed,\n            // we want to transition\n            var dependency = this.props.dependency;\n            var hasDependency = !!((dependency !== null && dependency !== void 0 ? dependency : nextProps.dependency));\n            var hasChanged = dependency !== nextProps.dependency;\n            this.shouldTransition =\n                !hasDependency || (hasDependency && hasChanged);\n        }\n        /**\n         * Reset rotation on all children so we can properly measure the correct bounding box.\n         * The supportRotate prop isn't public API so this should only run in Framer.\n         *\n         * Ideally this would run in getSnapshotBeforeUpdate as shouldComponentUpdate may run\n         * multiple times in concurrent mode, but currently this is introducing bugs.\n         */\n        if (this.shouldTransition) {\n            var supportRotate = this.props.supportRotate;\n            supportRotate &&\n                this.children.forEach(function (child) { return child.resetRotation(); });\n        }\n        return true;\n    };\n    /**\n     * Loop through all children and update their latest origin snapshots.\n     */\n    AnimateSharedLayout.prototype.getSnapshotBeforeUpdate = function () {\n        if (!this.shouldTransition)\n            return null;\n        /**\n         * Snapshot the visual origin of every child.\n         */\n        this.children.forEach(function (child) { return child.snapshotOrigin(); });\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        return null;\n    };\n    /**\n     * Once all children have updated, snapshot their target snapshots and run\n     * animate transitions.\n     */\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        // TODO: This would currently prevent animate children from working\n        if (this.shouldTransition) {\n            this.startAnimation();\n        }\n        else {\n            this.children.forEach(function (child) {\n                child.stopLayoutAnimation && child.stopLayoutAnimation();\n                // Warning - this will stop all other animations even non-magic ones\n                child.props.controls.stop();\n            });\n        }\n    };\n    /**\n     * Register a new `Auto` child\n     */\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        var _this = this;\n        this.setRootDepth(child);\n        this.children.add(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n        this.addChildToStack(child);\n        return function () { return _this.removeChild(child); };\n    };\n    AnimateSharedLayout.prototype.addChildToStack = function (child) {\n        var layoutId = child.props.layoutId;\n        if (layoutId === undefined)\n            return;\n        var stack = this.getStack(layoutId);\n        stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.children.delete(child);\n        this.removeChildFromStack(child);\n    };\n    AnimateSharedLayout.prototype.removeChildFromStack = function (child) {\n        var layoutId = child.props.layoutId;\n        if (layoutId === undefined)\n            return;\n        var stack = this.getStack(layoutId);\n        stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (id) {\n        !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\n        return this.stacks.get(id);\n    };\n    /**\n     * The root depth is the shallowest `depth` of all our children.\n     * Children with the shallowest depth get used to crossfade between trees.\n     */\n    AnimateSharedLayout.prototype.setRootDepth = function (child) {\n        if (this.rootDepth === undefined) {\n            this.rootDepth = child.depth;\n        }\n        else {\n            this.rootDepth = Math.min(child.depth, this.rootDepth);\n        }\n    };\n    AnimateSharedLayout.prototype.startAnimation = function () {\n        var _this = this;\n        var _a = this.props, type = _a.type, _b = _a.transition, transition = _b === void 0 ? defaultLayoutTransition : _b;\n        var options = { type: type, transition: transition };\n        var createAnimation = type === \"crossfade\"\n            ? createCrossfadeAnimation\n            : createSwitchAnimation;\n        // Update presence metadata based on latest AnimatePresence status\n        this.children.forEach(function (child) {\n            if (!child.isPresent()) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n        var handler = {\n            snapshotTarget: function (child) { return child.snapshotTarget(); },\n            startAnimation: function (child) {\n                var _a;\n                var numAnimations = 0;\n                var numCompletedAnimations = 0;\n                var layoutId = child.props.layoutId;\n                var stack = layoutId !== undefined ? _this.getStack(layoutId) : undefined;\n                var config = createAnimation(child, child.depth === _this.rootDepth, stack);\n                var shouldAnimate = type === \"crossfade\" && child.depth === _this.rootDepth\n                    ? true\n                    : (_a = stack) === null || _a === void 0 ? void 0 : _a.shouldStackAnimate();\n                var animation = child.startAnimation(__assign(__assign(__assign({}, options), config), { shouldAnimate: shouldAnimate }));\n                if (!animation)\n                    return;\n                _this.isAnimating = true;\n                numAnimations++;\n                animation.then(function () {\n                    if (child.isPresent())\n                        child.presence = Presence.Present;\n                    numCompletedAnimations++;\n                    if (numCompletedAnimations >= numAnimations) {\n                        _this.isAnimating = false;\n                    }\n                    if (_this.shouldRerender && !_this.isAnimating) {\n                        _this.state.forceRender();\n                    }\n                });\n            },\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.batch.add(child); });\n        this.batch.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return (stack.snapshot = undefined); });\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (createElement(SharedLayoutContext.Provider, { value: this.state }, this.props.children));\n    };\n    return AnimateSharedLayout;\n}(Component));\n\nvar isCustomValueType = function (v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\nfunction transform() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer(outputRange[0]) }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nvar isTransformer = function (v) {\n    return typeof v === \"function\";\n};\nfunction useTransform(parent, customTransform, to, options) {\n    var _a;\n    var comparitor = isTransformer(customTransform)\n        ? [parent]\n        : [parent, customTransform.join(\",\"), (_a = to) === null || _a === void 0 ? void 0 : _a.join(\",\")];\n    var transformer = useMemo(function () {\n        return isTransformer(customTransform)\n            ? customTransform\n            : transform(customTransform, to, options);\n    }, comparitor);\n    var initialValue = transformer(parent.get());\n    var value = useMotionValue(initialValue);\n    // Handle subscription to parent\n    var unsubscribe = useRef();\n    useMemo(function () {\n        unsubscribe.current && unsubscribe.current();\n        unsubscribe.current = parent.onChange(function (v) { return value.set(transformer(v)); });\n        // Manually set with the latest parent value in case we've re-parented\n        value.set(initialValue);\n    }, [parent, value, transformer]);\n    useUnmountEffect(function () { return unsubscribe.current && unsubscribe.current(); });\n    return value;\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @public\n */\nfunction useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useContext(MotionContext).visualElement;\n    invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX: scaleX, scaleY: scaleY };\n}\n\nfunction useOnChange(value, callback) {\n    useEffect(function () { return (isMotionValue(value) ? value.onChange(callback) : undefined); }, [value]);\n}\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n    if (config === void 0) { config = {}; }\n    var activeSpringAnimation = useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    useMemo(function () {\n        return value.attach(function (v, set) {\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = spring(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config)).start(set);\n            return value.get();\n        });\n    }, Object.values(config));\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\n    return value;\n}\n\nfunction createScrollMotionValues() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0),\n    };\n}\nfunction setProgress(offset, maxOffset, value) {\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n    var update = function () {\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\n        // Set absolute positions\n        values.scrollX.set(xOffset);\n        values.scrollY.set(yOffset);\n        // Set 0-1 progress\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n    };\n    update();\n    return update;\n}\n\nvar isBrowser$2 = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\n\nvar getElementScrollOffsets = function (element) { return function () {\n    return {\n        xOffset: element.scrollLeft,\n        yOffset: element.scrollTop,\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\n    };\n}; };\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction useElementScroll(ref) {\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function () {\n        var element = ref.current;\n        invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n        if (!element)\n            return;\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n        return function () {\n            scrollListener && scrollListener();\n            resizeListener && resizeListener();\n        };\n    }, []);\n    return values;\n}\n\nvar viewportScrollValues = createScrollMotionValues();\nfunction getViewportScrollOffsets() {\n    return {\n        xOffset: window.pageXOffset,\n        yOffset: window.pageYOffset,\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\n    };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n    hasListeners = true;\n    if (typeof window === \"undefined\")\n        return;\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\n    addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\nfunction useViewportScroll() {\n    useIsomorphicLayoutEffect(function () {\n        !hasListeners && addEventListeners();\n    }, []);\n    return viewportScrollValues;\n}\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimation() {\n    var animationControls = useConstant(function () { return new AnimationControls(); });\n    useEffect(function () {\n        animationControls.mount();\n        return function () { return animationControls.unmount(); };\n    }, []);\n    return animationControls;\n}\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    // TODO: After Framer X beta, remove this warning\n    warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\n    var index = useRef(0);\n    var _a = useState(items[index.current]), item = _a[0], setItem = _a[1];\n    return [\n        item,\n        function (next) {\n            index.current =\n                typeof next !== \"number\"\n                    ? wrap(0, items.length, index.current + 1)\n                    : next;\n            setItem(items[index.current]);\n        },\n    ];\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion = motionValue(null);\nif (typeof window !== \"undefined\") {\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function () {\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.set(false);\n    }\n}\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\n    return typeof isReducedMotion === \"boolean\"\n        ? isReducedMotion\n        : Boolean(prefersReduced);\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    var isReducedMotion = useContext(MotionContext).isReducedMotion;\n    var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\n    useEffect(function () {\n        return prefersReducedMotion.onChange(function (v) {\n            setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\n        });\n    }, [setShouldReduceMotion, isReducedMotion]);\n    return shouldReduceMotion;\n}\n\n/**\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\n * or disable device detection.\n *\n * @internal\n */\nfunction ReducedMotion(_a) {\n    var children = _a.children, enabled = _a.enabled;\n    var context = useContext(MotionContext);\n    context = useMemo(function () { return (__assign(__assign({}, context), { isReducedMotion: enabled })); }, [enabled]);\n    return (createElement(MotionContext.Provider, { value: context }, children));\n}\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */ (function () {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    DragControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - A mouse/touch/pointer event.\n     * @param options - Options\n     *\n     * @public\n     */\n    DragControls.prototype.start = function (event, options) {\n        this.componentControls.forEach(function (controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    return DragControls;\n}());\nvar createDragControls = function () { return new DragControls(); };\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\n/**\n * Uses the ref that is passed in, or creates a new one\n * @param external - External ref\n * @internal\n */\nfunction useExternalRef(externalRef) {\n    // We're conditionally calling `useRef` here which is sort of naughty as hooks\n    // shouldn't be called conditionally. However, Framer Motion will break if this\n    // condition changes anyway. It might be possible to use an invariant here to\n    // make it explicit, but I expect changing `ref` is not normal behaviour.\n    var ref = !externalRef || typeof externalRef === \"function\"\n        ? useRef(null)\n        : externalRef;\n    // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\n    // but `ref` types changing between renders would break Motion anyway. If we receive\n    // bug reports about this, we should track the provided ref and throw an invariant\n    // rather than move the conditional to inside the useEffect as this will be fired\n    // for every Frame component within Framer.\n    if (externalRef && typeof externalRef === \"function\") {\n        useEffect(function () {\n            externalRef(ref.current);\n            return function () { return externalRef(null); };\n        }, []);\n    }\n    return ref;\n}\n\nvar StateVisualElement = /** @class */ (function (_super) {\n    __extends(StateVisualElement, _super);\n    function StateVisualElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.latestState = {};\n        return _this;\n    }\n    StateVisualElement.prototype.build = function () { };\n    StateVisualElement.prototype.clean = function () { };\n    StateVisualElement.prototype.getBoundingBox = function () {\n        return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };\n    };\n    StateVisualElement.prototype.readNativeValue = function (key) {\n        return this.latestState[key] || 0;\n    };\n    StateVisualElement.prototype.render = function () { };\n    return StateVisualElement;\n}(VisualElement));\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\nfunction useAnimatedState(initialState) {\n    var _a = useState(initialState), animationState = _a[0], setAnimationState = _a[1];\n    var visualElement = useConstant(function () { return new StateVisualElement(); });\n    visualElement.updateConfig({\n        onUpdate: function (v) { return setAnimationState(__assign({}, v)); },\n    });\n    visualElement.latestState = animationState;\n    var controls = useVisualElementAnimation(visualElement, {}, {});\n    useEffect(function () {\n        visualElement.mount({});\n        return function () { return visualElement.unmount(); };\n    }, []);\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\n        return controls.start(animationDefinition);\n    }; });\n    return [animationState, startAnimation];\n}\n\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, SharedLayoutContext, VisualElementAnimationControls, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };\n"]},"metadata":{},"sourceType":"module"}